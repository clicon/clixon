/*
 *
  ***** BEGIN LICENSE BLOCK *****

  Copyright (C) 2009-2019 Olof Hagsand
  Copyright (C) 2020-2022 Olof Hagsand and Rubicon Communications, LLC(Netgate)

  This file is part of CLIXON.

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.

  Alternatively, the contents of this file may be used under the terms of
  the GNU General Public License Version 3 or later (the "GPL"),
  in which case the provisions of the GPL are applicable instead
  of those above. If you wish to allow use of your version of this file only
  under the terms of the GPL, and not to allow others to
  use your version of this file under the terms of Apache License version 2,
  indicate your decision by deleting the provisions above and replace them with
  the  notice and other provisions required by the GPL. If you do not delete
  the provisions above, a recipient may use your version of this file under
  the terms of any one of the Apache License version 2 or the GPL.

  ***** END LICENSE BLOCK *****

 *
 * Translation between database specs
 *   yang_spec                   CLIgen parse_tree
 *  +-------------+   yang2cli    +-------------+
 *  |             | ------------> | cli         |
 *  | list{key A;}|               | syntax      |
 *  +-------------+               +-------------+

 * YANG generate CLI

 * A special tree called @datamodel is generated by the yang2cli function.
 * This tree contains generated CLIgen syntax for loaded YANG modules, according to the
 * include/exclude logic in clixon-autocli.yang defined by the following fields:
 *   module-default
 *   rule/module-name
 *   rule/operation=exclude|include
 * The @datamodel tree can be used using the CLIgen "tree reference" functionality as described in
 * the cligen tutorial Secion 2.7.
 * The tree can be modified by removing labels.
 * By default "ac-state" are removed.
 * This means that using @datamodel without modifiers is a "clean" config tree.

 This is an example yang module:
module m {
  container x {
    namespace "urn:example:m";
    prefix m;
    list m1 {
      key "a";
      leaf a {
        type string;
      }
      leaf b {
        type string;
      }
    }
  }
}

You can see which CLISPEC it generates via clixon_cli -D 2:
  x,cli_set("/example:x");{
      m1         a (<a:string>|<a:string expand_dbvar("candidate","/example:x/m1=%s/a")>),overwrite_me("/example:x/m1=%s/");
{
         b (<b:string>|<b:string expand_dbvar("candidate","/example:x/m1=%s/b")>),overwrite_me("/example:x/m1=%s/b");
      }
   }
 */
#ifdef HAVE_CONFIG_H
#include "clixon_config.h" /* generated by config & autoconf */
#endif

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <errno.h>
#include <fcntl.h>
#include <syslog.h>
#include <signal.h>
#include <sys/param.h>
#include <sys/stat.h>

/* cligen */
#include <cligen/cligen.h>

/* libclixon */
#include <clixon/clixon.h>

#include "clixon_cli_api.h"
#include "cli_plugin.h"
#include "cli_generate.h"

/*! Add cv with name to cvec
 *
 * @param[in]  cvv   Either existing or NULL
 * @param[in]  name  Name of cv to add
 * @retval     cvv   Either same as in cvv parameter or new
 */
static cvec*
cvec_add_name(cvec *cvv,
              char *name)
{
    cg_var *cv= NULL;

    if (cvv == NULL &&
        (cvv = cvec_new(0)) == NULL){
        clixon_err(OE_UNIX, errno, "cvec_new");
        return NULL;
    }
    if ((cv = cvec_add(cvv, CGV_STRING)) == NULL){
        clixon_err(OE_UNIX, errno, "cvec_add");
        return NULL;
    }
    /* Filter out state data, use "nonconfig" as defined in RFC8040 4.8.1
     */
    cv_name_set(cv, name);
    return cvv;
}

/*! Recursive post processing of generated cligen parsetree: modify co_cvec labels
 *
 * Much of this is now changed when it was made yang independent and contains some ad-hoc
 * rules. It would be better to move all this to clixon_autocli_generate.c but much is difficult to do.
 * These labels can be filtered when applying them with the @treeref, @add:<label> syntax.
 * (terminal entry means eg "a ;" where ; is an "empty" child of "a" representing a terminal)
 * This function adds labels to the generated CLIgen tree using YANG as follows:
 * 1. Add "act-prekey" label on terminal entries of LIST keys, except last
 * 2. Add "act-lastkey" label on terminal entries of last LIST keys,
 * 3. Add "act-list" label on terminal entries of LIST
 * 4. Add "act-leafconst" label on terminal entries of non-empty LEAF/LEAF_LISTs
 * 5. Add "act-leafvar" label on nodes which are children of non-key LEAFs, eg "a <a>" -> "a <a>,leaf"
 * 7. Add "ac-config" label on nodes which have no config false children recursively
 *
 * @param[in]     h       Clixon handle
 * @param[in]     cop     Parent cligen object (if any)
 * @param[in]     pt      CLIgen parse-tree (generated syntax)
 * @param[in]     i0      Offset into pt
 * @param[in]     yp      YANG parent node of "pt"
 * @param[in,out] configp 0: state, 1: config
 * @retval        0       OK
 * @retval       -1       Error
 * @note A labels set as : "A, label;" is set on "A" not on ";", there is no way to set the
 *       label on the empty terminal ";". Therefore this function moves them all from the
 *       parent to the ";" child.
 * XXX: the above kludge can be fixed by:
 *   (1) change cligen syntax
 *   (2) rewrite yang2cli code to create pt directly instead of via a cbuf.
 */
static int
yang2cli_post(clixon_handle h,
              cg_obj       *cop,
              parse_tree   *pt,
              int           i0,
              int          *configp)
{
    int           retval = -1;
    cg_obj       *co;
    int           i;
    int           config;
    int           state = 0;

    for (i = i0; i<pt_len_get(pt); i++){
        if ((co = pt_vec_i_get(pt, i)) == NULL){
            clixon_err(OE_YANG, 0, "Empty object in parsetreelist"); /* shouldnt happen */
            goto done;
        }
        if (co->co_type == CO_EMPTY){
            char   *name;
            cg_var *cv = NULL;
            int     j=0;

            cv = NULL;
            while ((cv = cvec_each(cop->co_cvec, cv)) != NULL){
                name = cv_name_get(cv);
                if (strcmp(name, "act-leafvar")==0 && cvec_find(cop->co_cvec, "ac-leaf") != NULL)
                    ;
                else  if (strncmp(name, "act-", 4) == 0){
                    if ((co->co_cvec = cvec_add_name(co->co_cvec, name)) == NULL)
                        goto done;
                    cv_reset(cv);
                    cvec_del_i(cop->co_cvec, j);
                    if (cvec_len(cop->co_cvec) == 0){
                        cvec_free(cop->co_cvec);
                        cop->co_cvec = NULL;
                    }
                    cv = NULL; // trigger rerun
                    j = 0;
                }
                j++;
            }
            continue;
        }
        /* If state: Add nonconfig label*/
        config = *configp;
        if (cvec_find(co->co_cvec, "ac-state") != NULL)
            config = 0;
        /* Check if key, ad-hoc from autocli generation tags */
#if 0
        if (cvec_find(co->co_cvec, "act-prekey") != NULL || cvec_find(co->co_cvec, "act-lastkey") != NULL)
            yciskey = 1;
        else {
            parse_tree *ptc = co_pt_get(co);
            cg_obj     *coc;
            coc = pt_vec_i_get(ptc, 0);
            if (cvec_find(coc->co_cvec, "act-prekey") != NULL || cvec_find(coc->co_cvec, "act-lastkey") != NULL)
                yciskey = 1;
        }
#endif
        if (yang2cli_post(h, co, co_pt_get(co), 0, &config) < 0) // note yp not yc
            goto done;
        if (config){
            if ((co->co_cvec = cvec_add_name(co->co_cvec, "ac-config")) == NULL)
                goto done;
        }
        else
            state++;
    } /* for */
    if (state) // There exists at least one state child
        *configp = 0;
    else { /* Clear all ac-config labels in children */
        for (i = i0; i<pt_len_get(pt); i++){
            cg_var *cv;
            int j=0;

            co = pt_vec_i_get(pt, i);
            cv = NULL;
            while ((cv = cvec_each(co->co_cvec, cv)) != NULL){
                if (strcmp(cv_name_get(cv), "ac-config") == 0){
                    cv_reset(cv);
                    cvec_del_i(co->co_cvec, j);
                    break;
                }
                j++;
            }
        }
    }
    retval = 0;
 done:
    return retval;
}

/*! Helper function: add parsetree header and add parsetree
 */
static int
ph_add_set(cligen_handle h,
           const char   *treename,
           parse_tree   *pt)
{
    int      retval = -1;
    pt_head *ph;

    if ((ph = cligen_ph_add(h, treename)) == NULL){
        clixon_err(OE_UNIX, 0, "cligen_ph_add");
        goto done;
    }
    if (cligen_ph_parsetree_set(ph, pt) < 0){
        clixon_err(OE_UNIX, 0, "cligen_ph_parsetree_set");
        goto done;
    }
    retval = 0;
 done:
    return retval;
}

/*! Clientside generate clispec
 *
 * @param[in]  h        Clixon handle
 * @param[in]  str      CLIspec string
 * @param[in]  module   Yang module
 * @param[in]  keyword  Yang node keyword
 * @param[in]  argument Yang argument name
 * @param[out] pt       CLIspec Parse-tree
 * @retval     0        OK
 * @retval    -1        Error
 */
static int
yang2cli_client(clixon_handle h,
                const char   *str,
                const char   *module,
                const char   *keyword,
                const char   *name,
                parse_tree  **ptp)
{
    int         retval = -1;
    parse_tree *pt = NULL;
    cbuf       *cbname = NULL;
        int config = 1;

    if ((cbname = cbuf_new()) == NULL){
        clixon_err(OE_XML, errno, "cbuf_new");
        goto done;
    }
    cprintf(cbname, "Autocli for %s %s in %s", keyword, name, module);
    if ((pt = pt_new()) == NULL){
        clixon_err(OE_UNIX, errno, "pt_new");
        goto done;
    }
    /* Parse the buffer using cligen parser. load cli syntax */
    if (clispec_parse_str(cli_cligen(h), str, cbuf_get(cbname), NULL, pt, NULL) < 0){
        clixon_err(OE_PLUGIN, 0, "%s", str);
        goto done;
    }
    clixon_debug(CLIXON_DBG_CLI, "%s", cbuf_get(cbname));
    /* Post-processing, iterate over the generated cligen parse-tree
     * Note cannot do it inline in yang2cli above since:
     * 1. labels cannot be set on "empty"
     * 2. a; <a>, fn() cannot be set properly
     */
    if (yang2cli_post(h, NULL, pt, 0, &config) < 0)
        goto done;
    if (ptp)
        *ptp = pt;
    retval = 0;
 done:
    if (cbname)
        cbuf_free(cbname);
    return retval;
}

/*! Generate clispec for all modules in yspec (except excluded)
 *
 * Called in cli main function for top-level yangs. But may also be called dynamically for
 * mountpoints.
 * @param[in]  h         Clixon handle
 * @param[in]  yspec     Top-level Yang statement of type Y_SPEC
 * @param[in]  treename  Name of tree
 * @retval     0         OK
 * @retval    -1         Error
 * @note Tie-break of same top-level symbol: prefix is NYI
 * @see yang2cli_grouping_wrap  Generate grouping clispecs
 * @see yang2cli_yanglib        Generate clispec from yang-lib instead independent of yang structures
 */
int
yang2cli_yspec(clixon_handle h,
               yang_stmt    *yspec,
               char         *treename)
{
    int             retval = -1;
    parse_tree     *pt0 = NULL;
    parse_tree     *pt = NULL;
    yang_stmt      *ymod;
    yang_stmt      *yrev;
    yang_stmt      *ydomain;
    int             enable;
    cbuf           *cb = NULL;
    int             inext;
    char           *domain;
    char           *revision;
    const char     *keyword;
    char           *argument;
    autocli_cache_t cache = AUTOCLI_CACHE_DISABLED;

    if ((pt0 = pt_new()) == NULL){
        clixon_err(OE_UNIX, errno, "pt_new");
        goto done;
    }
    if ((cb = cbuf_new()) == NULL){
        clixon_err(OE_XML, errno, "cbuf_new");
        goto done;
    }
    if (autocli_cache(h, &cache, NULL) < 0)
        goto done;
    if ((ydomain = yang_parent_get(yspec)) == NULL){
        clixon_err(OE_YANG, 0, "No domain");
        goto done;
    }
    domain = yang_argument_get(ydomain);
    /* Traverse YANG, loop through all modules and generate CLI */
    inext = 0;
    while ((ymod = yn_iter(yspec, &inext)) != NULL){
        yrev = yang_find(ymod, Y_REVISION, NULL);
        /* Filter module name according to cli_autocli.yang setting
         * Default is pass and ordering is significant
         */
        revision = yrev?yang_argument_get(yrev):NULL;
        keyword = yang_key2str(yang_keyword_get(ymod));
        argument = yang_argument_get(ymod);
        if (autocli_module(h, argument, &enable) < 0)
            goto done;
        if (!enable)
            continue;
        cbuf_reset(cb);
        switch (cache){
        case AUTOCLI_CACHE_DISABLED: /* Generate locally */
            if (yang2cli_stmt(h, ymod, 0, cb) < 0)
                goto done;
            break;
        case AUTOCLI_CACHE_READ: /* Query backend */
            if (clixon_rpc_clixon_cache(h, "read", "autocli", domain, yang_argument_get(yspec), argument, revision, keyword, argument, cb) < 0)
                goto done;
            break;
        }
        if (cbuf_len(cb) == 0)
            continue;
        if (yang2cli_client(h, cbuf_get(cb), yang_filename_get(ymod), keyword, argument, &pt) < 0)
            goto done;
        if (clicon_data_int_get(h, "autocli-print-debug") == 1){
            clixon_log(h, LOG_NOTICE, "%s: Top-level cli-spec %s:\n%s",
                       __func__, treename, cbuf_get(cb));
        }
        else
            clixon_debug(CLIXON_DBG_CLI | CLIXON_DBG_DETAIL, "Top-level cli-spec %s:\n%s",
                         treename, cbuf_get(cb));
        if (cligen_parsetree_merge(pt0, NULL, pt) < 0){
            clixon_err(OE_YANG, errno, "cligen_parsetree_merge");
            goto done;
        }
        pt_free(pt, 1);
        pt = NULL;
    } /* while ymod */
    /* Resolve the expand callback functions in the generated syntax.
     * This "should" only be GENERATE_EXPAND_XMLDB
     * handle=NULL for global namespace, this means expand callbacks must be in
     * CLICON namespace, not in a cli frontend plugin.
     */
    if (cligen_expand_str2fn(pt0, (expand_str2fn_t*)clixon_str2fn, NULL) < 0)
        goto done;
    /* Append cligen tree and name it */
    clixon_debug(CLIXON_DBG_CLI, "Add autocli parse-tree: %s", treename);
    if (ph_add_set(cli_cligen(h), treename, pt0) < 0)
        goto done;
    pt0 = NULL;
    retval = 0;
 done:
    if (pt)
        pt_free(pt, 1);
    if (pt0)
        pt_free(pt0, 1);
    if (cb)
        cbuf_free(cb);
    return retval;
}

/*! Generate clispec for all modules given a yang modules-spec in XML
 *
 * @param[in]  h         Clixon handle
 * @param[in]  spec      Name of yang-spec (could be digest of xyanglib)
 * @param[in]  xyanglib  RFC8525 module-set yang-lib
 * @param[in]  treename  Name of tree
 * @retval     0         OK
 * @retval    -1         Error
 * @see yang2cli_yspec   Generate clispec from yang module instead
 */
int
yang2cli_yanglib(clixon_handle h,
                 const char   *spec,
                 cxobj        *xyanglib,
                 char         *treename)
{
    int             retval = -1;
    parse_tree     *pt0 = NULL;
    parse_tree     *pt = NULL;
    cbuf           *cb = NULL;
    autocli_cache_t cache = AUTOCLI_CACHE_DISABLED;
    cxobj          *xymodset = NULL;
    cxobj          *xy = NULL;
    char           *domain;
    char           *argument;
    char           *revision;
    char           *keyword;
    int             enable;
    //    char           *namespace;

    if (autocli_cache(h, &cache, NULL) < 0)
        goto done;
    if (cache != AUTOCLI_CACHE_READ){
        clixon_err(OE_CFG, 0, "Cache mode not READ");
        goto done;
    }
    if ((pt0 = pt_new()) == NULL){
        clixon_err(OE_UNIX, errno, "pt_new");
        goto done;
    }
    if ((cb = cbuf_new()) == NULL){
        clixon_err(OE_XML, errno, "cbuf_new");
        goto done;
    }
    xymodset = xml_find_type(xyanglib, NULL, "module-set", CX_ELMNT);
    domain = xml_find_body(xymodset, "name");
    while ((xy = xml_child_each(xymodset, xy, CX_ELMNT)) != NULL){
        keyword = xml_name(xy);
        if (strcmp(keyword, "submodule") == 0){ // XXX?
            clixon_err(OE_YANG, 0, "Submodules NYI"); // XXX This is actually an error in the RFC 8525 generation code, why no submodules?
            goto done;
        }
        if (strcmp(keyword, "module") != 0)
            continue;
        argument = xml_find_body(xy, "name");
        revision = xml_find_body(xy, "revision");
        if (autocli_module(h, argument, &enable) < 0)
            goto done;
        if (!enable)
            continue;
        //        namespace = xml_find_body(xy, "namespace");
        cbuf_reset(cb);
        if (clixon_rpc_clixon_cache(h, "read", "autocli", domain, spec, argument, revision, keyword, argument, cb) < 0)
            goto done;
        if (cbuf_len(cb) == 0)
            continue;
        if (yang2cli_client(h, cbuf_get(cb), argument, keyword, argument, &pt) < 0)
            goto done;
        if (clicon_data_int_get(h, "autocli-print-debug") == 1){
            clixon_log(h, LOG_NOTICE, "%s: Top-level cli-spec %s:\n%s",
                       __func__, treename, cbuf_get(cb));
        }
        else
            clixon_debug(CLIXON_DBG_CLI | CLIXON_DBG_DETAIL, "Top-level cli-spec %s:\n%s",
                         treename, cbuf_get(cb));
        if (cligen_parsetree_merge(pt0, NULL, pt) < 0){
            clixon_err(OE_YANG, errno, "cligen_parsetree_merge");
            goto done;
        }
        pt_free(pt, 1);
        pt = NULL;
    } /* while xymodset */
    /* Resolve the expand callback functions in the generated syntax.
     * This "should" only be GENERATE_EXPAND_XMLDB
     * handle=NULL for global namespace, this means expand callbacks must be in
     * CLICON namespace, not in a cli frontend plugin.
     */
    if (cligen_expand_str2fn(pt0, (expand_str2fn_t*)clixon_str2fn, NULL) < 0)
        goto done;
    /* Append cligen tree and name it */
    clixon_debug(CLIXON_DBG_CLI, "Add autocli parse-tree: %s", treename);
    if (ph_add_set(cli_cligen(h), treename, pt0) < 0)
        goto done;
    pt0 = NULL;
    retval = 0;
 done:
    if (pt)
        pt_free(pt, 1);
    if (pt0)
        pt_free(pt0, 1);
    if (cb)
        cbuf_free(cb);
    return retval;
}

/*! CLIgen wrap function for making treeref lookup: generate locally clispec tree from YANG
 *
 * This adds an indirection based on name and context
 * If a yang and specific tree is created, the name of that tree is returned in namep,
 * That tree is called something like mountpoint-<device-name>
 * otherwise the generic name "mountpoint" is used.
 * @param[in]  ch    CLIgen handle
 * @param[in]  treename Base tree name
 * @param[in]  cvt   Tokenized string: vector of tokens
 * @param[in]  arg   Argument given when registering wrap function (maybe not needed?)
 * @param[out] namep New (malloced) name, if changed
 * @retval     0     OK
 * @retval    -1     Error
 * @see yang2cli_container  where @mountpoint is added as a generic treeref causing this call
 * @see yang2cli_yspec      which is the other place where clispecs are generated
 */
static int
yang2cli_grouping_wrap_local(clixon_handle h,
                             const char   *domain,
                             const char   *spec,
                             const char   *module,
                             const char   *argument,
                             cbuf         *cb)
{
    int        retval = -1;
    int        inext;
    yang_stmt *yc;
    yang_stmt *ymnt;
    yang_stmt *ydomain;
    yang_stmt *yspec;
    yang_stmt *ymod;
    yang_stmt *ys;

    ymnt = clixon_yang_mounts_get(h);
    if ((ydomain = yang_find(ymnt, Y_DOMAIN, domain)) == NULL){
        clixon_err(OE_YANG, 0, "yang2cli cmd label no ydomain %s", domain);
        goto done;
    }
    if ((yspec = yang_find(ydomain, Y_SPEC, spec)) == NULL){
        clixon_err(OE_YANG, 0, "yang2cli cmd label no yspec %s", spec);
        goto done;
    }
    if ((ymod = yang_find(yspec, 0, module)) == NULL){
        clixon_err(OE_YANG, 0, "yang2cli cmd label no module %s", module);
        goto done;
    }
    if ((ys = yang_find(ymod, Y_GROUPING, argument)) == NULL)
        goto skip;
    inext = 0;
    while ((yc = yn_iter(ys, &inext)) != NULL)
        if (yang2cli_stmt(h, yc, 1, cb) < 0)
            goto done;
    retval = 1;
 done:
    return retval;
 skip:
    retval = 0;
    goto done;
}

/*! CLIgen wrap function for making treeref lookup: generate clispec tree from YANG
 *
 * This adds an indirection based on name and context
 * If a yang and specific tree is created, the name of that tree is returned in namep,
 * That tree is called something like mountpoint-<device-name>
 * otherwise the generic name "mountpoint" is used.
 * @param[in]  ch    CLIgen handle
 * @param[in]  treename Base tree name
 * @param[in]  cvt   Tokenized string: vector of tokens
 * @param[in]  arg   Argument given when registering wrap function (maybe not needed?)
 * @param[out] namep New (malloced) name, if changed
 * @retval     0     OK
 * @retval    -1     Error
 * @see yang2cli_container  where @mountpoint is added as a generic treeref causing this call
 * @see yang2cli_yspec      which is the other place where clispecs are generated
 */
int
yang2cli_grouping_wrap(cligen_handle ch,
                       const char   *treename,
                       cvec         *cvt,
                       void         *arg,
                       char        **namep)
{
    int             retval = -1;
    clixon_handle   h;
    char           *domain = NULL;
    char           *spec = NULL;
    char           *module = NULL;
    char           *revision = NULL;
    char           *keyword = NULL;
    char           *argument = NULL;
    cbuf           *cb = NULL;
    parse_tree     *pt = NULL;
    autocli_cache_t cache = AUTOCLI_CACHE_DISABLED;
    int             ret;

    clixon_debug(CLIXON_DBG_CLI, "%s", treename);
    if (namep == NULL){
        clixon_err(OE_UNIX, EINVAL, "Missing namep");
        goto done;
    }
    h = cligen_userhandle(ch);
    if (yang2cli_treeref_decode(treename, AUTOCLI_CMD_DELIM,
                                &domain,
                                &spec,
                                &module,
                                &revision,
                                &keyword,
                                &argument) < 0)
        goto done;
    if (keyword == NULL || strcmp(keyword, "grouping") != 0)
        goto ok;
    if (cligen_ph_find(ch, treename) != NULL){
        if ((*namep = strdup(treename)) == NULL){
            clixon_err(OE_UNIX, errno, "strdup");
            goto done;
        }
        goto ok;
    }
    if (autocli_cache(h, &cache, NULL) < 0)
        goto done;
    if ((cb = cbuf_new()) == NULL){
        clixon_err(OE_UNIX, errno, "cbuf_new");
        goto done;
    }
    switch (cache){
        case AUTOCLI_CACHE_DISABLED: /* Generate locally */
            if ((ret = yang2cli_grouping_wrap_local(h, domain, spec, module, argument, cb)) < 0)
                goto done;
            if (ret == 0)
                goto ok;
            break;
        case AUTOCLI_CACHE_READ: /* Query backend */
                if (clixon_rpc_clixon_cache(h, "read", "autocli", domain, spec, module, revision, keyword, argument, cb) < 0)
                    goto done;
            if (cbuf_len(cb) == 0){
                clixon_err(OE_UNIX, 0, "Tree empty %s 1", treename);
                goto done;
            }
            break;
    }
    if (yang2cli_client(h, cbuf_get(cb), module, keyword, argument, &pt) < 0)
        goto done;
    if (cligen_expand_str2fn(pt, (expand_str2fn_t*)clixon_str2fn, NULL) < 0)
        goto done;
    clixon_debug(CLIXON_DBG_CLI, "Add CLI tree: %s", treename);
    if (ph_add_set(cli_cligen(h), treename, pt) < 0)
        goto done;
    if ((*namep = strdup(treename)) == NULL){
        clixon_err(OE_UNIX, errno, "strdup");
        goto done;
    }
 ok:
#if 1 /* Backward compatible with cligen 7.6 tree-resolve() */
    if (namep && *namep)
        retval = 1;
    else
#endif
        retval = 0;
 done:
    if (domain)
        free(domain);
    if (spec)
        free(spec);
    if (module)
        free(module);
    if (revision)
        free(revision);
    if (keyword)
        free(keyword);
    if (argument)
        free(argument);
    if (cb)
        cbuf_free(cb);
    return retval;
}

/*! Init yang2cli
 *
 * Initialize CLIgen generation from YANG models.
 * Some logic around grouping-treeref: if enabled, then groupings are separate trees with lazy
 * evaluation.  Only expanded when referenced, but need a callback. If one is not already installed.
 * @param[in]  h      Clixon handle
 */
int
yang2cli_init(clixon_handle h)
{
    int                             retval = -1;
    int                             grouping_treeref = 0;
    cligen_tree_resolve_wrapper_fn *fn = NULL;

    if (autocli_grouping_treeref(h, &grouping_treeref) < 0)
        goto done;
    if (grouping_treeref) {
        cligen_tree_resolve_wrapper_get(cli_cligen(h), &fn, NULL);
        if (fn == NULL)
            cligen_tree_resolve_wrapper_set(cli_cligen(h), yang2cli_grouping_wrap, NULL);
    }
    retval = 0;
 done:
    return retval;
}