/*
 *
  ***** BEGIN LICENSE BLOCK *****

  Copyright (C) 2009-2019 Olof Hagsand
  Copyright (C) 2020-2022 Olof Hagsand and Rubicon Communications, LLC(Netgate)

  This file is part of CLIXON.

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.

  Alternatively, the contents of this file may be used under the terms of
  the GNU General Public License Version 3 or later (the "GPL"),
  in which case the provisions of the GPL are applicable instead
  of those above. If you wish to allow use of your version of this file only
  under the terms of the GPL, and not to allow others to
  use your version of this file under the terms of Apache License version 2,
  indicate your decision by deleting the provisions above and replace them with
  the  notice and other provisions required by the GPL. If you do not delete
  the provisions above, a recipient may use your version of this file under
  the terms of any one of the Apache License version 2 or the GPL.

  ***** END LICENSE BLOCK *****

 *
 * Translation between database specs
 *   yang_spec                   CLIgen parse_tree
 *  +-------------+   yang2cli    +-------------+
 *  |             | ------------> | cli         |
 *  | list{key A;}|               | syntax      |
 *  +-------------+               +-------------+

 * YANG generate CLI

 * A special tree called @datamodel is generated by the yang2cli function.
 * This tree contains generated CLIgen syntax for loaded YANG modules, according to the
 * include/exclude logic in clixon-autocli.yang defined by the following fields:
 *   module-default
 *   rule/module-name
 *   rule/operation=exclude|include
 * The @datamodel tree can be used using the CLIgen "tree reference" functionality as described in
 * the cligen tutorial Secion 2.7.
 * The tree can be modified by removing labels.
 * By default "ac-state" are removed.
 * This means that using @datamodel without modifiers is a "clean" config tree.

 This is an example yang module:
module m {
  container x {
    namespace "urn:example:m";
    prefix m;
    list m1 {
      key "a";
      leaf a {
        type string;
      }
      leaf b {
        type string;
      }
    }
  }
}

You can see which CLISPEC it generates via clixon_cli -D 2:
  x,cli_set("/example:x");{
      m1         a (<a:string>|<a:string expand_dbvar("candidate","/example:x/m1=%s/a")>),overwrite_me("/example:x/m1=%s/");
{
         b (<b:string>|<b:string expand_dbvar("candidate","/example:x/m1=%s/b")>),overwrite_me("/example:x/m1=%s/b");
      }
   }
 */
#ifdef HAVE_CONFIG_H
#include "clixon_config.h" /* generated by config & autoconf */
#endif

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <errno.h>
#include <fcntl.h>
#include <syslog.h>
#include <signal.h>
#include <sys/param.h>
#include <sys/stat.h>

#include <assert.h>

/* cligen */
#include <cligen/cligen.h>

/* libclixon */
#include <clixon/clixon.h>

#include "clixon_cli_api.h"
#include "cli_plugin.h"
#include "cli_generate.h"

/*! Add cv with name to cvec
 *
 * @param[in]  cvv   Either existing or NULL
 * @param[in]  name  Name of cv to add
 * @retval     cvv   Either same as in cvv parameter or new
 */
static cvec*
cvec_add_name(cvec *cvv,
              char *name)
{
    cg_var *cv= NULL;

    if (cvv == NULL &&
        (cvv = cvec_new(0)) == NULL){
        clixon_err(OE_UNIX, errno, "cvec_new");
        return NULL;
    }
    if ((cv = cvec_add(cvv, CGV_STRING)) == NULL){
        clixon_err(OE_UNIX, errno, "cvec_add");
        return NULL;
    }
    /* Filter out state data, use "nonconfig" as defined in RFC8040 4.8.1
     */
    cv_name_set(cv, name);
    return cvv;
}

/*! Recursive post processing of generated cligen parsetree: populate with co_cvec labels
 *
 * This function adds labels to the generated CLIgen tree using YANG as follows:
 * These labels can be filtered when applying them with the @treeref, @add:<label> syntax.
 * (terminal entry means eg "a ;" where ; is an "empty" child of "a" representing a terminal)
 * 1. Add "act-prekey" label on terminal entries of LIST keys, except last
 * 2. Add "act-lastkey" label on terminal entries of last LIST keys,
 * 3. Add "act-list" label on terminal entries of LIST
 * 4. Add "act-leafconst" label on terminal entries of non-empty LEAF/LEAF_LISTs
 * 5. Add "act-leafvar" label on nodes which are children of non-key LEAFs, eg "a <a>" -> "a <a>,leaf"
 * 6. Add "ac-state" label on nodes which has YANG "config false" as child
 * 7. Add "ac-config" label on nodes which have no config false children recursively
 *
 * @param[in]  h   Clixon handle
 * @param[in]  cop Parent cliegn object (if any)
 * @param[in]  pt  CLIgen parse-tree (generated syntax)
 * @param[in]  i0  Offset into pt
 * @param[in]  yp  YANG parent node of "pt"
 * @param[in]  ykey Special case, If y is list, yc can be a leaf key
 * @retval     0   OK
 * @retval    -1   Error
 * @note A labels set as : "A, label;" is set on "A" not on ";", there is no way to set the
 *       label on the empty terminal ";". Therefore this function moves them all from the
 *       parent to the ";" child.
 * XXX: the above kludge can be fixed by:
 *   (1) change cligen syntax
 *   (2) rewrite yang2cli code to create pt directly instead of via a cbuf.
 */
static int
yang2cli_post(clixon_handle h,
              cg_obj       *cop,
              parse_tree   *pt,
              int           i0,
              yang_stmt    *yp,
              yang_stmt    *ykey,
              int          *configp)
{
    int           retval = -1;
    cg_obj       *co;
    int           i;
    yang_stmt    *yc;
    int           yciskey;
    enum rfc_6020 ypkeyword;
    int           config;
    int           state = 0;

    ypkeyword = yang_keyword_get(yp);
    for (i = i0; i<pt_len_get(pt); i++){
        if ((co = pt_vec_i_get(pt, i)) == NULL){
            clixon_err(OE_YANG, 0, "Empty object in parsetreelist"); /* shouldnt happen */
            goto done;
        }
        if (co->co_type == CO_EMPTY){
            char   *name;
            cg_var *cv = NULL;
            int     j=0;

            cv = NULL;
            while ((cv = cvec_each(cop->co_cvec, cv)) != NULL){
                name = cv_name_get(cv);
                if (strncmp(name, "act-", 4) == 0){
                    if ((co->co_cvec = cvec_add_name(co->co_cvec, name)) == NULL)
                        goto done;
                    cv_reset(cv);
                    cvec_del_i(cop->co_cvec, j);
                    if (cvec_len(cop->co_cvec) == 0){
                        cvec_free(cop->co_cvec);
                        cop->co_cvec = NULL;
                    }
                    cv = NULL; // trigger rerun
                    j = 0;
                }
                j++;
            }
            continue;
        }
        /* Filters out eg "name <name>" second instance if kw-all / kw-nokey
         * But if only "<name>" it passes
         */
        if ((yc = yang_find_datanode(yp, co->co_command)) == NULL){
#if 1
            /* XXX In case of compress, look at next level */
            yang_stmt *y;
            int        inext = 0;

            while ((y = yn_iter(yp, &inext)) != NULL){
                if (yang_datanode(y)){
                    if ((yc = yang_find_datanode(y, co->co_command)) != NULL)
                        break;
                }
            }
            if (y == NULL)
                continue;
#endif
        }
        yciskey = ypkeyword == Y_LIST && yang_key_match(yp, co->co_command, NULL);
        /* If state: Add nonconfig label*/
        config = *configp;
        if (!yang_config(yc)){
            if ((co->co_cvec = cvec_add_name(co->co_cvec, "ac-state")) == NULL)
                goto done;
            config = 0;
        }
        /* If y is list and yc is key, then call with y */
        if (yciskey){
            if (yang2cli_post(h, co, co_pt_get(co), 0, yp, yc, &config) < 0) // note y not yc
                goto done;
        }
        else if (yang2cli_post(h, co, co_pt_get(co), 0, yc, NULL, &config) < 0)
            goto done;
        if (config){
            if ((co->co_cvec = cvec_add_name(co->co_cvec, "ac-config")) == NULL)
                goto done;
        }
        else
            state++;
    } /* for */
    if (state)
        *configp = 0;
    else { /* Clear all ac-config labels */
        for (i = i0; i<pt_len_get(pt); i++){
            cg_var *cv;
            int j=0;

            co = pt_vec_i_get(pt, i);
            cv = NULL;
            while ((cv = cvec_each(co->co_cvec, cv)) != NULL){
                if (strcmp(cv_name_get(cv), "ac-config") == 0){
                    cv_reset(cv);
                    cvec_del_i(co->co_cvec, j);
                    break;
                }
                j++;
            }
        }
    }
    retval = 0;
 done:
    return retval;
}

/*! Helper function: add parsetree header and add parsetree
 */
static int
ph_add_set(cligen_handle h,
           const char   *treename,
           parse_tree   *pt)
{
    int      retval = -1;
    pt_head *ph;

    if ((ph = cligen_ph_add(h, treename)) == NULL){
        clixon_err(OE_UNIX, 0, "cligen_ph_add");
        goto done;
    }
    if (cligen_ph_parsetree_set(ph, pt) < 0){
        clixon_err(OE_UNIX, 0, "cligen_ph_parsetree_set");
        goto done;
    }
    retval = 0;
 done:
    return retval;
}


#if 0 // Move to clixon_autocli_generate.c?
/*! Generate clispec for all modules in a grouping
 *
 * Called in cli main function for top-level yangs. But may also be called dynamically for
 * mountpoints.
 * @param[in]  h         Clixon handle
 * @param[in]  ys        Top-level Yang statement
 * @param[in]  ymod      Yang module
 * @param[in]  domain    Domain name
 * @param[in]  treename  Name of tree in the form <tag>-<domain>-<module>-<id>
 * @retval     1         OK
 * @retval     0         OK but empty clispec, no tree produced
 * @retval    -1         Error
 * @note Tie-break of same top-level symbol: prefix is NYI
 * @see yang2cli_yspec and yang2cli_stmt for original
 * XXX merge with yang2cli_yspec
 */
static int
yang2cli_grouping(clixon_handle h,
                  yang_stmt    *ys,
                  yang_stmt    *ymod,
                  const char   *domain,
                  const char   *treename)
{
    int             retval = -1;
    parse_tree     *pt0 = NULL;
    parse_tree     *pt = NULL;
    cbuf           *cb = NULL;
    int             treeref_state = 0;
    char           *prefix;
    cg_obj         *co;
    int             config;
    char           *module;
    char           *revision;
    char           *keyword;
    char           *name;
    int             i;

    if ((pt0 = pt_new()) == NULL){
        clixon_err(OE_UNIX, errno, "pt_new");
        goto done;
    }
    if ((cb = cbuf_new()) == NULL){
        clixon_err(OE_XML, errno, "cbuf_new");
        goto done;
    }
    if (yang_find(ys, Y_STATUS, "obsolete") != NULL){
        clixon_debug(CLIXON_DBG_CLI | CLIXON_DBG_DETAIL, "obsolete: %s %s, skipped", yang_argument_get(ys), yang_argument_get(ys_module(ys)));
        goto empty;
    }
    if (yang_find(ys, Y_STATUS, "deprecated") != NULL){
        clixon_debug(CLIXON_DBG_CLI | CLIXON_DBG_DETAIL, "deprecated: %s %s", yang_argument_get(ys), yang_argument_get(ys_module(ys)));
    }
    /* Only produce autocli for YANG non-config only if autocli-treeref-state is true */
    if (autocli_treeref_state(h, &treeref_state) < 0)
        goto done;
    if (treeref_state || yang_config(ys)){
        yang_stmt      *yrev;

        yrev = yang_find(ymod, Y_REVISION, NULL);
        module = yang_argument_get(ymod);
        revision = yrev?yang_argument_get(yrev):NULL;
        keyword = yang_key2str(yang_keyword_get(ys));
        name = yang_argument_get(ys);
        // XXX skiptop
        if (clixon_rpc_clixon_cache(h, "read", "autocli", domain, module, revision, keyword, name, cb) < 0)
            goto done;
    }
    if (cbuf_len(cb) == 0){
        /* Create empty tree */
        if (ph_add_set(cli_cligen(h), treename, pt0) < 0)
            goto done;
        pt0 = NULL;
        goto ok;
    }
    /* Note Tie-break of same top-level symbol: prefix is NYI
     * Needs to move cligen_parse_str() call here instead of later
     */
    if ((prefix = yang_find_myprefix(ys)) == NULL){
        clixon_err(OE_YANG, 0, "Module %s lacks prefix", yang_argument_get(ys)); /* shouldnt happen */
        goto done;
    }
    if ((pt = pt_new()) == NULL){
        clixon_err(OE_UNIX, errno, "pt_new");
        goto done;
    }
    /* Parse the buffer using cligen parser. load cli syntax */
    if (clispec_parse_str(cli_cligen(h), cbuf_get(cb), (char*)__func__, NULL, pt, NULL) < 0){
        clixon_err(OE_PLUGIN, 0, "%s", cbuf_get(cb));
        goto done;
    }
    clixon_debug(CLIXON_DBG_CLI, "Generated auto-cli for grouping:%s",
                 yang_argument_get(ys));
    /* Add prefix: assume new are appended */
    for (i=0; i<pt_len_get(pt); i++){
        if ((co = pt_vec_i_get(pt, i)) != NULL){
            clixon_debug(CLIXON_DBG_CLI, "command: %s",
                         co->co_command);
            co_prefix_set(co, prefix);
        }
    }
    /* Post-processing, iterate over the generated cligen parse-tree with corresponding yang
     * Note cannot do it inline in yang2cli above since:
     * 1. labels cannot be set on "empty"
     * 2. a; <a>, fn() cannot be set properly
     */
    config = 1;
    if (yang2cli_post(h, NULL, pt, 0, ys, NULL, &config) < 0){
        goto done;
    }
    if (clicon_data_int_get(h, "autocli-print-debug") == 1)
        clixon_log(h, LOG_NOTICE, "%s: Top-level cli-spec %s:\n%s",
                   __func__, treename, cbuf_get(cb));
    else
        clixon_debug(CLIXON_DBG_CLI | CLIXON_DBG_DETAIL, "Top-level cli-spec %s:\n%s",
                     treename, cbuf_get(cb));
    if (cligen_parsetree_merge(pt0, NULL, pt) < 0){
        clixon_err(OE_YANG, errno, "cligen_parsetree_merge");
        goto done;
    }
    pt_free(pt, 1);
    pt = NULL;

    /* Resolve the expand callback functions in the generated syntax.
     * This "should" only be GENERATE_EXPAND_XMLDB
     * handle=NULL for global namespace, this means expand callbacks must be in
     * CLICON namespace, not in a cli frontend plugin.
     */
    if (cligen_expand_str2fn(pt0, (expand_str2fn_t*)clixon_str2fn, NULL) < 0)
        goto done;
    /* Append cligen tree and name it */
    if (ph_add_set(cli_cligen(h), treename, pt0) < 0)
        goto done;
    pt0 = NULL;
 ok:
    retval = 1;
 done:
    if (pt)
        pt_free(pt, 1);
    if (pt0)
        pt_free(pt0, 1);
    if (cb)
        cbuf_free(cb);
    return retval;
 empty:
    retval = 0;
    goto done;
}
#endif

/*! Generate clispec for all modules in yspec (except excluded)
 *
 * Called in cli main function for top-level yangs. But may also be called dynamically for
 * mountpoints.
 * @param[in]  h         Clixon handle
 * @param[in]  yspec     Top-level Yang statement of type Y_SPEC
 * @param[in]  treename  Name of tree
 * @retval     0         OK
 * @retval    -1         Error
 * @note Tie-break of same top-level symbol: prefix is NYI
 * @see yang2cli_grouping_wrap      which is the other place where clispecs are generated
 */
int
yang2cli_yspec(clixon_handle h,
               yang_stmt    *yspec,
               char         *treename)
{
    int             retval = -1;
    parse_tree     *pt0 = NULL;
    parse_tree     *pt = NULL;
    yang_stmt      *ymod;
    yang_stmt      *yrev;
    yang_stmt      *ydomain;
    int             enable;
    cbuf           *cb = NULL;
    cbuf           *cbname = NULL;
    char           *prefix;
    cg_obj         *co;
    int             i;
    int             inext;
    char           *domain;
    char           *module;
    char           *revision;
    const char     *keyword;
    char           *name;
    autocli_cache_t cache = AUTOCLI_CACHE_DISABLED;

    if ((pt0 = pt_new()) == NULL){
        clixon_err(OE_UNIX, errno, "pt_new");
        goto done;
    }
    if ((cb = cbuf_new()) == NULL){
        clixon_err(OE_XML, errno, "cbuf_new");
        goto done;
    }
    if (autocli_cache(h, &cache, NULL) < 0)
        goto done;
    if ((ydomain = yang_parent_get(yspec)) == NULL){
        clixon_err(OE_YANG, 0, "No domain");
        goto done;
    }
    domain = yang_argument_get(ydomain);
    /* Traverse YANG, loop through all modules and generate CLI */
    inext = 0;
    while ((ymod = yn_iter(yspec, &inext)) != NULL){
        yrev = yang_find(ymod, Y_REVISION, NULL);
        /* Filter module name according to cli_autocli.yang setting
         * Default is pass and ordering is significant
         */
        module = yang_argument_get(ymod);
        revision = yrev?yang_argument_get(yrev):NULL;
        keyword = yang_key2str(yang_keyword_get(ymod));
        name = yang_argument_get(ymod);
        if (autocli_module(h, module, &enable) < 0)
            goto done;
        if (!enable)
            continue;
        cbuf_reset(cb);
        switch (cache){
        case AUTOCLI_CACHE_DISABLED: /* Generate locally */
            if (yang2cli_stmt(h, ymod, 0, cb) < 0)
                goto done;
            break;
        case AUTOCLI_CACHE_READ: /* Query backend */
            if (clixon_rpc_clixon_cache(h, "read", "autocli", domain, yang_argument_get(yspec), module, revision, keyword, name, cb) < 0)
                goto done;
            break;
        }
        if (cbuf_len(cb) == 0)
            continue;
        /* Note Tie-break of same top-level symbol: prefix is NYI
         * Needs to move cligen_parse_str() call here instead of later
         */
        if ((prefix = yang_find_myprefix(ymod)) == NULL){
            clixon_err(OE_YANG, 0, "Module %s lacks prefix", yang_argument_get(ymod)); /* shouldnt happen */
            goto done;
        }
        if ((pt = pt_new()) == NULL){
            clixon_err(OE_UNIX, errno, "pt_new");
            goto done;
        }
        /* Make a proper clispec name for debugging */
        if ((cbname = cbuf_new()) == NULL){
            clixon_err(OE_XML, errno, "cbuf_new");
            goto done;
        }
        cprintf(cbname, "Autocli for module: %s", yang_filename_get(ymod));
        /* Parse the buffer using cligen parser. load cli syntax */
        if (clispec_parse_str(cli_cligen(h), cbuf_get(cb), cbuf_get(cbname), NULL, pt, NULL) < 0){
            clixon_debug(CLIXON_DBG_CLI, "Failing clispec: %s", cbuf_get(cb));
            clixon_err(OE_YANG, errno, "Failing clispec: %s (use -D cli for failing clispec)", cbuf_get(cbname));
            goto done;
        }
        clixon_debug(CLIXON_DBG_CLI, "Generated auto-cli for module %s", module);
        if (cbname){
            cbuf_free(cbname);
            cbname = NULL;
        }
        /* Add prefix: assume new are appended */
        for (i=0; i<pt_len_get(pt); i++){
            if ((co = pt_vec_i_get(pt, i)) != NULL){
                clixon_debug(CLIXON_DBG_CLI|CLIXON_DBG_DETAIL, "Add prefix %s to command: %s", prefix, co->co_command);
                co_prefix_set(co, prefix);
            }
        }
#ifdef YANG2CLI_POST
        /* Post-processing, iterate over the generated cligen parse-tree with corresponding yang
         * Note cannot do it inline in yang2cli above since:
         * 1. labels cannot be set on "empty"
         * 2. a; <a>, fn() cannot be set properly
         */
        {
            int config = 1;

            if (yang2cli_post(h, NULL, pt, 0, ymod, NULL, &config) < 0)
                goto done;
        }
#endif
        if (clicon_data_int_get(h, "autocli-print-debug") == 1){
            clixon_log(h, LOG_NOTICE, "%s: Top-level cli-spec %s:\n%s",
                       __func__, treename, cbuf_get(cb));
        }
        else
            clixon_debug(CLIXON_DBG_CLI | CLIXON_DBG_DETAIL, "Top-level cli-spec %s:\n%s",
                         treename, cbuf_get(cb));
        if (cligen_parsetree_merge(pt0, NULL, pt) < 0){
            clixon_err(OE_YANG, errno, "cligen_parsetree_merge");
            goto done;
        }
        pt_free(pt, 1);
        pt = NULL;
    } /* while ymod */
    /* Resolve the expand callback functions in the generated syntax.
     * This "should" only be GENERATE_EXPAND_XMLDB
     * handle=NULL for global namespace, this means expand callbacks must be in
     * CLICON namespace, not in a cli frontend plugin.
     */
    if (cligen_expand_str2fn(pt0, (expand_str2fn_t*)clixon_str2fn, NULL) < 0)
        goto done;
    /* Append cligen tree and name it */
    clixon_debug(CLIXON_DBG_CLI, "Add autocli parse-tree: %s", treename);
    if (ph_add_set(cli_cligen(h), treename, pt0) < 0)
        goto done;
    pt0 = NULL;
#if 0
    if (clicon_data_int_get(h, "autocli-print-debug") == 1){
        clixon_log(h, LOG_NOTICE, "%s: Top-level cli-spec %s", __func__, treename);
        pt_print1(stderr, pt0, 0);
    }
#endif
    retval = 0;
 done:
    if (pt)
        pt_free(pt, 1);
    if (pt0)
        pt_free(pt0, 1);
    if (cb)
        cbuf_free(cb);
    if (cbname)
        cbuf_free(cbname);
    return retval;
}

/*! CLIgen wrap function for making treeref lookup: generate clispec tree from YANG
 *
 * This adds an indirection based on name and context
 * If a yang and specific tree is created, the name of that tree is returned in namep,
 * That tree is called something like mountpoint-<device-name>
 * otherwise the generic name "mountpoint" is used.
 * @param[in]  ch    CLIgen handle
 * @param[in]  treename Base tree name
 * @param[in]  cvt   Tokenized string: vector of tokens
 * @param[in]  arg   Argument given when registering wrap function (maybe not needed?)
 * @param[out] namep New (malloced) name, if changed
 * @retval     0     OK
 * @retval    -1     Error
 * @see yang2cli_container  where @mountpoint is added as a generic treeref causing this call
 * @see yang2cli_yspec      which is the other place where clispecs are generated
 */
int
yang2cli_grouping_wrap(cligen_handle ch,
                       const char   *treename,
                       cvec         *cvt,
                       void         *arg,
                       char        **namep)
{
    int             retval = -1;
    clixon_handle   h;
    char           *domain = NULL;
    char           *spec = NULL;
    char           *module = NULL;
    char           *revision = NULL;
    char           *keyword = NULL;
    char           *argument = NULL;
    cbuf           *cb = NULL;
    parse_tree     *pt = NULL;
    autocli_cache_t cache = AUTOCLI_CACHE_DISABLED;
    int             inext;
    yang_stmt      *yc;
    char           *prefix;
    cg_obj         *co;
    yang_stmt      *ymnt;
    yang_stmt      *ydomain;
    yang_stmt      *yspec;
    yang_stmt      *ymod;
    yang_stmt      *ys;
    int             i;

    clixon_debug(CLIXON_DBG_CLI, "%s", treename);
    if (namep == NULL){
        clixon_err(OE_UNIX, EINVAL, "Missing namep");
        goto done;
    }
    h = cligen_userhandle(ch);
    if (yang2cli_treeref_decode(treename, AUTOCLI_CMD_DELIM,
                                &domain,
                                &spec,
                                &module,
                                &revision,
                                &keyword,
                                &argument) < 0)
        goto done;
    if (keyword == NULL || strcmp(keyword, "grouping") != 0)
        goto ok;
    if (cligen_ph_find(ch, treename) != NULL){
        if ((*namep = strdup(treename)) == NULL){
            clixon_err(OE_UNIX, errno, "strdup");
            goto done;
        }
        goto ok;
    }
    if (autocli_cache(h, &cache, NULL) < 0)
        goto done;
    if ((cb = cbuf_new()) == NULL){
        clixon_err(OE_UNIX, errno, "cbuf_new");
        goto done;
    }
    ymnt = clixon_yang_mounts_get(h);
    if ((ydomain = yang_find(ymnt, Y_DOMAIN, domain)) == NULL){
        clixon_err(OE_YANG, 0, "yang2cli cmd label no ydomain %s", domain);
        goto done;
    }
    if ((yspec = yang_find(ydomain, Y_SPEC, spec)) == NULL
#ifdef YANG2CLI_UNDETERMINISTIC_SPEC
        && (yspec = yang_find(ydomain, Y_SPEC, NULL)) == NULL
#endif
        ){
        clixon_err(OE_YANG, 0, "yang2cli cmd label no yspec %s", spec);
        goto done;
    }
    if ((ymod = yang_find(yspec, 0, module)) == NULL){
        clixon_err(OE_YANG, 0, "yang2cli cmd label no module %s", module);
        goto done;
    }
    if ((prefix = yang_find_myprefix(ymod)) == NULL){
        clixon_err(OE_YANG, 0, "Module %s lacks prefix", yang_argument_get(ymod)); /* shouldnt happen */
        goto done;
    }
    if ((ys = yang_find(ymod, Y_GROUPING, argument)) == NULL)
        goto ok;
    switch (cache){
        case AUTOCLI_CACHE_DISABLED: /* Generate locally */
            inext = 0;
            while ((yc = yn_iter(ys, &inext)) != NULL)
                if (yang2cli_stmt(h, yc, 1, cb) < 0)
                    goto done;
            break;
        case AUTOCLI_CACHE_READ: /* Query backend */
                if (clixon_rpc_clixon_cache(h, "read", "autocli", domain, spec, module, revision, keyword, argument, cb) < 0)
                    goto done;
            if (cbuf_len(cb) == 0){
                clixon_err(OE_UNIX, 0, "Tree empty %s 1", treename);
                goto done;
            }
            break;
    }
    if ((pt = pt_new()) == NULL){
        clixon_err(OE_UNIX, errno, "pt_new");
        goto done;
    }
    /* Parse the buffer using cligen parser. load cli syntax */
    if (clispec_parse_str(cli_cligen(h), cbuf_get(cb), (char*)__func__, NULL, pt, NULL) < 0){
        clixon_err(OE_PLUGIN, 0, "%s", cbuf_get(cb));
        goto done;
    }
    clixon_debug(CLIXON_DBG_CLI, "Generated auto-cli for grouping:%s in module %s", argument, module);
    /* Add prefix: assume new are appended */
    for (i=0; i<pt_len_get(pt); i++){
        if ((co = pt_vec_i_get(pt, i)) != NULL){
            clixon_debug(CLIXON_DBG_CLI|CLIXON_DBG_DETAIL, "Add prefix %s to command: %s", prefix, co->co_command);
            co_prefix_set(co, prefix);
        }
    }
#ifdef YANG2CLI_POST
    /* Post-processing, iterate over the generated cligen parse-tree with corresponding yang
     * Note cannot do it inline in yang2cli above since:
     * 1. labels cannot be set on "empty"
     * 2. a; <a>, fn() cannot be set properly
     */
    {
        int config = 1;

        if (yang2cli_post(h, NULL, pt, 0, ys, NULL, &config) < 0)
            goto done;
    }
#endif
    if (cligen_expand_str2fn(pt, (expand_str2fn_t*)clixon_str2fn, NULL) < 0)
        goto done;
    clixon_debug(CLIXON_DBG_CLI, "Add CLI tree: %s", treename);
    if (ph_add_set(cli_cligen(h), treename, pt) < 0)
        goto done;
    if ((*namep = strdup(treename)) == NULL){
        clixon_err(OE_UNIX, errno, "strdup");
        goto done;
    }
 ok:
#if 1 /* Backward compatible with cligen 7.6 tree-resolve() */
    if (namep && *namep)
        retval = 1;
    else
#endif
        retval = 0;
 done:
    if (domain)
        free(domain);
    if (spec)
        free(spec);
    if (module)
        free(module);
    if (revision)
        free(revision);
    if (keyword)
        free(keyword);
    if (argument)
        free(argument);
    if (cb)
        cbuf_free(cb);
    return retval;
}

/*! Init yang2cli
 *
 * Initialize CLIgen generation from YANG models.
 * Some logic around grouping-treeref: if enabled, then groupings are separate trees with lazy
 * evaluation.  Only expanded when referenced, but need a callback. If one is not already installed.
 * @param[in]  h      Clixon handle
 */
int
yang2cli_init(clixon_handle h)
{
    int                             retval = -1;
    int                             grouping_treeref = 0;
    cligen_tree_resolve_wrapper_fn *fn = NULL;

    if (autocli_grouping_treeref(h, &grouping_treeref) < 0)
        goto done;
    if (grouping_treeref) {
        cligen_tree_resolve_wrapper_get(cli_cligen(h), &fn, NULL);
        if (fn == NULL)
            cligen_tree_resolve_wrapper_set(cli_cligen(h), yang2cli_grouping_wrap, NULL);
    }
    retval = 0;
 done:
    return retval;
}
