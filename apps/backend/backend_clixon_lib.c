/*
 *
  ***** BEGIN LICENSE BLOCK *****
 
  Copyright (C) 2009-2016 Olof Hagsand and Benny Holmgren
  Copyright (C) 2017-2019 Olof Hagsand
  Copyright (C) 2020-2022 Olof Hagsand and Rubicon Communications, LLC(Netgate)

  This file is part of CLIXON.

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.

  Alternatively, the contents of this file may be used under the terms of
  the GNU General Public License Version 3 or later (the "GPL"),
  in which case the provisions of the GPL are applicable instead
  of those above. If you wish to allow use of your version of this file only
  under the terms of the GPL, and not to allow others to
  use your version of this file under the terms of Apache License version 2, 
  indicate your decision by deleting the provisions above and replace them with
  the  notice and other provisions required by the GPL. If you do not delete
  the provisions above, a recipient may use your version of this file under
  the terms of any one of the Apache License version 2 or the GPL.

  ***** END LICENSE BLOCK *****
  Commit and validate
 */

#ifdef HAVE_CONFIG_H
#include "clixon_config.h" /* generated by config & autoconf */
#endif

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdarg.h>
#include <inttypes.h>
#include <errno.h>
#include <signal.h>
#include <fcntl.h>
#include <time.h>
#include <pwd.h>
#include <syslog.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <sys/param.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netinet/in.h>

/* cligen */
#include <cligen/cligen.h>

/* clixon */
#include <clixon/clixon.h>

#include "clixon_backend_transaction.h"
#include "clixon_backend_plugin.h"
#include "clixon_backend_client.h"
#include "backend_handle.h"
#include "clixon_backend_commit.h"
#include "backend_clixon_lib.h"

/*! Get clixon per datastore stats
 *
 * @param[in]     h       Clixon handle
 * @param[in]     dbname  Datastore name
 * @param[in,out] cb      Cligen buf
 * @retval        0       OK
 * @retval       -1       Error
 */
static int
clixon_stats_datastore_get(clixon_handle h,
                           char         *dbname,
                           cbuf         *cb)
{
    int       retval = -1;
    cxobj    *xt = NULL; /* should not be freed */
    uint64_t  nr = 0;
    size_t    sz = 0;
    cxobj    *xn = NULL;
    db_elmnt *de;
    int       ret;

    clixon_debug(CLIXON_DBG_BACKEND | CLIXON_DBG_DETAIL, "%s", dbname);
    /* This is the db cache */
    if ((de = xmldb_find(h, dbname)) != NULL &&
        (xt = xmldb_cache_get(de)) == NULL){
        /* Trigger cache if no exist (trick to ensure cache is present) */
        if ((ret = xmldb_get0(h, dbname, YB_MODULE, NULL, "/", 1, 0, &xn, NULL, NULL)) < 0)
            //goto done;
            goto ok;
        if (ret == 0)
            goto ok;
        xt = xmldb_cache_get(de);
    }
    if (xt != NULL){
        if (xml_stats(xt, &nr, &sz) < 0)
            goto done;
        cprintf(cb, "<datastore><name>%s</name><nr>%" PRIu64 "</nr>"
                "<size>%zu</size></datastore>",
                dbname, nr, sz);
    }
 ok:
    retval = 0;
 done:
    if (xn)
        xml_free(xn);
    return retval;
}

/*! Get clixon per yang-spec stats
 *
 * @param[in]     h       Clixon handle
 * @param[in]     dbname  Datastore name
 * @param[in,out] cb      Cligen buf
 * @retval        0       OK
 * @retval       -1       Error
 */
static int
clixon_stats_yang_get(clixon_handle h,
                      yang_stmt    *ys,
                      cbuf         *cb)
{
    int       retval = -1;
    uint64_t  nr = 0;
    size_t    sz = 0;
    cxobj    *xn = NULL;

    if (ys == NULL)
        return 0;
    if (yang_stats(ys, 0, &nr, &sz) < 0)
        goto done;
    cprintf(cb, "<nr>%" PRIu64 "</nr><size>%zu</size>", nr, sz);
    retval = 0;
 done:
    if (xn)
        xml_free(xn);
    return retval;
}

/*! Set debug level.
 *
 * @param[in]  h       Clixon handle
 * @param[in]  xe      Request: <rpc><xn></rpc>
 * @param[out] cbret   Return xml tree, eg <rpc-reply>..., <rpc-error..
 * @param[in]  arg     client-entry
 * @param[in]  regarg  User argument given at rpc_callback_register()
 * @retval     0       OK
 * @retval    -1       Error
 */
static int
from_client_debug(clixon_handle h,
                  cxobj        *xe,
                  cbuf         *cbret,
                  void         *arg,
                  void         *regarg)
{
    int      retval = -1;
    uint32_t level;
    char    *valstr;

    if ((valstr = xml_find_body(xe, "level")) == NULL){
        if (netconf_missing_element(cbret, "application", "level", NULL) < 0)
            goto done;
        goto ok;
    }
    level = atoi(valstr);

    clixon_debug_init(h, level); /* 0: dont debug, 1:debug */
    setlogmask(LOG_UPTO(level?LOG_DEBUG:LOG_INFO)); /* for syslog */
    clixon_log(h, LOG_NOTICE, "%s debug:%d", __func__, clixon_debug_get());
    cprintf(cbret, "<rpc-reply xmlns=\"%s\"><ok/></rpc-reply>", NETCONF_BASE_NAMESPACE);
 ok:
    retval = 0;
 done:
    return retval;
}

/*! Check liveness of backend daemon,  just send a reply
 *
 * @param[in]  h       Clixon handle
 * @param[in]  xe      Request: <rpc><xn></rpc>
 * @param[out] cbret   Return xml tree, eg <rpc-reply>..., <rpc-error..
 * @param[in]  arg     client-entry
 * @param[in]  regarg  User argument given at rpc_callback_register()
 * @retval     0       OK
 * @retval    -1       Error
 */
static int
from_client_ping(clixon_handle h,
                 cxobj        *xe,
                 cbuf         *cbret,
                 void         *arg,
                 void         *regarg)
{
    cprintf(cbret, "<rpc-reply xmlns=\"%s\"><ok/></rpc-reply>", NETCONF_BASE_NAMESPACE);
    return 0;
}

/*! Check liveness of backend daemon,  just send a reply
 *
 * @param[in]  h       Clixon handle
 * @param[in]  xe      Request: <rpc><xn></rpc>
 * @param[out] cbret   Return xml tree, eg <rpc-reply>..., <rpc-error..
 * @param[in]  arg     client-entry
 * @param[in]  regarg  User argument given at rpc_callback_register()
 * @retval     0       OK
 * @retval    -1       Error
 */
static int
from_client_stats(clixon_handle h,
                  cxobj        *xe,
                  cbuf         *cbret,
                  void         *arg,
                  void         *regarg)
{
    int        retval = -1;
    uint64_t   nr;
    char      *str;
    int        modules = 0;
    yang_stmt *ymounts;
    yang_stmt *ydomain;
    yang_stmt *yspec;
    yang_stmt *ymodule;
    cxobj     *xt = NULL;
    char      *domain;
    int        inext;
    int        inext2;
    int        inext3;

    if ((str = xml_find_body(xe, "modules")) != NULL)
        modules = strcmp(str, "true") == 0;
    cprintf(cbret, "<rpc-reply xmlns=\"%s\">", NETCONF_BASE_NAMESPACE);
    cprintf(cbret, "<global xmlns=\"%s\">", CLIXON_LIB_NS);
    nr=0;
    xml_stats_global(&nr);
    cprintf(cbret, "<xmlnr>%" PRIu64 "</xmlnr>", nr);
    nr=0;
    yang_stats_global(&nr);
    cprintf(cbret, "<yangnr>%" PRIu64 "</yangnr>", nr);
    cprintf(cbret, "</global>");
    cprintf(cbret, "<datastores xmlns=\"%s\">", CLIXON_LIB_NS);
    if (clixon_stats_datastore_get(h, "running", cbret) < 0)
        goto done;
    if (clixon_stats_datastore_get(h, "candidate", cbret) < 0)
        goto done;
    if (if_feature(h, "ietf-netconf", "startup"))
	if (clixon_stats_datastore_get(h, "startup", cbret) < 0)
	    goto done;
    cprintf(cbret, "</datastores>");
    if ((ymounts = clixon_yang_mounts_get(h)) == NULL){
        clixon_err(OE_YANG, ENOENT, "Top-level yang mounts not found");
        goto done;
    }
    cprintf(cbret, "<module-sets xmlns=\"%s\">", CLIXON_LIB_NS);
    inext = 0;
    while ((ydomain = yn_iter(ymounts, &inext)) != NULL) {
        domain = yang_argument_get(ydomain);
        /* per module-set, first configuration, then main dbspec, then mountpoints */
        inext2 = 0;
        while ((yspec = yn_iter(ydomain, &inext2)) != NULL) {
            cprintf(cbret, "<module-set>");
            cprintf(cbret, "<name>%s/%s</name>", domain, yang_argument_get(yspec));
            if (clixon_stats_yang_get(h, yspec, cbret) < 0)
                goto done;
            if (modules){
                inext3 = 0;
                while ((ymodule = yn_iter(yspec, &inext3)) != NULL) {
                    cprintf(cbret, "<module><name>%s</name>", yang_argument_get(ymodule));
                    if (clixon_stats_yang_get(h, ymodule, cbret) < 0)
                        goto done;
                    cprintf(cbret, "</module>");
                }
            }
            cprintf(cbret, "</module-set>");
        }
    }
    cprintf(cbret, "</module-sets>");
    cprintf(cbret, "</rpc-reply>");
    retval = 0;
 done:
    if (xt)
	xml_free(xt);
    return retval;
}


/*! Control a specific process or daemon: start/stop, etc
 *
 * @param[in]  h       Clixon handle
 * @param[in]  xe      Request: <rpc><xn></rpc>
 * @param[out] cbret   Return xml tree, eg <rpc-reply>..., <rpc-error..
 * @param[in]  arg     client-entry
 * @param[in]  regarg  User argument given at rpc_callback_register()
 * @retval     0       OK
 * @retval    -1       Error
 */
static int
from_client_process_control(clixon_handle h,
                            cxobj        *xe,
                            cbuf         *cbret,
                            void         *arg,
                            void         *regarg)
{
    int            retval = -1;
    cxobj         *x;
    char          *name = NULL;
    char          *opstr = NULL;
    proc_operation op = PROC_OP_NONE;

    if ((x = xml_find_type(xe, NULL, "name", CX_ELMNT)) != NULL)
        name = xml_body(x);
    if ((x = xml_find_type(xe, NULL, "operation", CX_ELMNT)) != NULL){
        opstr = xml_body(x);
        op = clixon_process_op_str2int(opstr);
    }
    /* Make the actual process operation (with wrap function enabled) */
    if (op == PROC_OP_STATUS){
        if (clixon_process_status(h, name, cbret) < 0)
            goto done;
    }
    else{
        if (clixon_process_operation(h, name, op, 1) < 0)
            goto done;
        cprintf(cbret, "<rpc-reply xmlns=\"%s\"><ok xmlns=\"%s\"/></rpc-reply>",
                NETCONF_BASE_NAMESPACE, CLIXON_LIB_NS);
    }
    retval = 0;
 done:
    return retval;
}

/*! Restart specific backend plugins without full backend restart
 *
 * @note, depending on plugin callbacks, there may be other dependencies which may make this
 * difficult in the general case.
 */
static int
from_client_restart_one(clixon_handle    h,
                        clixon_plugin_t *cp,
                        cbuf            *cbret)
{
    int                 retval = -1;
    char               *db = "tmp";
    transaction_data_t *td = NULL;
    plgreset_t         *resetfn;          /* Plugin auth */
    cxobj              *xerr = NULL;
    yang_stmt          *yspec;
    int                 i;
    cxobj              *xn;
    void               *wh = NULL;
    int                 ret;

    yspec = clicon_dbspec_yang(h);
    if (xmldb_db_reset(h, db) < 0)
        goto done;
    /* Application may define extra xml in its reset function*/
    if ((resetfn = clixon_plugin_api_get(cp)->ca_reset) != NULL){
        wh = NULL;
        if (clixon_resource_check(h, &wh, clixon_plugin_name_get(cp), __func__) < 0)
            goto done;
        if ((retval = resetfn(h, db)) < 0) {
            clixon_debug(CLIXON_DBG_BACKEND, "plugin_start() failed");
            goto done;
        }
        if (clixon_resource_check(h, &wh, clixon_plugin_name_get(cp), __func__) < 0)
            goto done;
    }
    /* 1. Start transaction */
    if ((td = transaction_new()) == NULL)
        goto done;
    /* This is the state we are going to */
    if ((ret = xmldb_get0(h, "running", YB_MODULE, NULL, "/", 0, 0, &td->td_target, NULL, &xerr)) < 0)
        goto done;
    if (ret == 1 && (ret = xml_yang_validate_all_top(h, td->td_target, 0, &xerr)) < 0)
        goto done;
    if (ret == 0){
        if (clixon_xml2cbuf1(cbret, xerr, 0, 0, NULL, -1, 0, 0, WITHDEFAULTS_REPORT_ALL) < 0)
            goto done;
        goto fail;
    }

    /* This is the state we are going from */
    if (xmldb_get0(h, db, YB_NONE, NULL, "/", 0, WITHDEFAULTS_EXPLICIT, &td->td_src, NULL, NULL) < 0)
        goto done;
    /* 3. Compute differences */
    if (xml_diff(td->td_src,
                 td->td_target,
                 &td->td_dvec,      /* removed: only in running */
                 &td->td_dlen,
                 &td->td_avec,      /* added: only in candidate */
                 &td->td_alen,
                 &td->td_scvec,     /* changed: original values */
                 &td->td_tcvec,     /* changed: wanted values */
                 &td->td_clen) < 0)
        goto done;

    /* Mark as changed in tree */
    for (i=0; i<td->td_dlen; i++){ /* Also down */
        xn = td->td_dvec[i];
        xml_flag_set(xn, XML_FLAG_DEL);
        xml_apply(xn, CX_ELMNT, (xml_applyfn_t*)xml_flag_set, (void*)XML_FLAG_DEL);
        xml_apply_ancestor(xn, (xml_applyfn_t*)xml_flag_set, (void*)XML_FLAG_CHANGE);
    }
    for (i=0; i<td->td_alen; i++){ /* Also down */
        xn = td->td_avec[i];
        xml_flag_set(xn, XML_FLAG_ADD);
        xml_apply(xn, CX_ELMNT, (xml_applyfn_t*)xml_flag_set, (void*)XML_FLAG_ADD);
        xml_apply_ancestor(xn, (xml_applyfn_t*)xml_flag_set, (void*)XML_FLAG_CHANGE);
    }
    for (i=0; i<td->td_clen; i++){ /* Also up */
        xn = td->td_scvec[i];
        xml_flag_set(xn, XML_FLAG_CHANGE);
        xml_apply_ancestor(xn, (xml_applyfn_t*)xml_flag_set, (void*)XML_FLAG_CHANGE);
        xn = td->td_tcvec[i];
        xml_flag_set(xn, XML_FLAG_CHANGE);
        xml_apply_ancestor(xn, (xml_applyfn_t*)xml_flag_set, (void*)XML_FLAG_CHANGE);
    }
    /* Call plugin transaction start callbacks */
    if (plugin_transaction_begin_one(cp, h, td) < 0)
        goto fail;
    /* Make generic validation on all new or changed data.
       Note this is only call that uses 3-values */
    if ((ret = generic_validate(h, yspec, td, &xerr)) < 0)
        goto done;
    if (ret == 0){
        if (clixon_xml2cbuf1(cbret, xerr, 0, 0, NULL, -1, 0, 0, WITHDEFAULTS_REPORT_ALL) < 0)
            goto done;
        goto fail;
    }
    /* Call validate callback in this plugin */
    if (plugin_transaction_validate_one(cp, h, td) < 0)
        goto fail;
    if (plugin_transaction_complete_one(cp, h, td) < 0)
        goto fail;
    /* Call commit callback in this plugin */
    if (plugin_transaction_commit_one(cp, h, td) < 0)
        goto fail;
    if (plugin_transaction_commit_done_one(cp, h, td) < 0)
        goto fail;
    /* Finalize */
    if (plugin_transaction_end_one(cp, h, td) < 0)
        goto fail;
    retval = 1;
 done:
    if (td)
        transaction_free1(td, 1);
    return retval;
 fail:
    retval = 0;
    goto done;
}

/*! Request restart of specific plugins
 *
 * @param[in]  h       Clixon handle
 * @param[in]  xe      Request: <rpc><xn></rpc>
 * @param[out] cbret   Return xml tree, eg <rpc-reply>..., <rpc-error..
 * @param[in]  arg     client-entry
 * @param[in]  regarg  User argument given at rpc_callback_register()
 * @retval     0       OK
 * @retval    -1       Error
 */
static int
from_client_restart_plugin(clixon_handle h,
                           cxobj        *xe,
                           cbuf         *cbret,
                           void         *arg,
                           void         *regarg)
{
    int            retval = -1;
    char          *name;
    cxobj        **vec = NULL;
    size_t         veclen;
    int            i;
    clixon_plugin_t *cp;
    int            ret;

    if (xpath_vec(xe, NULL, "plugin", &vec, &veclen) < 0)
        goto done;
    for (i=0; i<veclen; i++){
        name = xml_body(vec[i]);
        if ((cp = clixon_plugin_find(h, name)) == NULL){
            if (netconf_bad_element(cbret, "application", "plugin", "No such plugin") < 0)
                goto done;
            goto ok;
        }
        if ((ret = from_client_restart_one(h, cp, cbret)) < 0)
            goto done;
        if (ret == 0)
            goto ok; /* cbret set */
    }
    cprintf(cbret, "<rpc-reply xmlns=\"%s\"><ok/></rpc-reply>", NETCONF_BASE_NAMESPACE);
 ok:
    retval = 0;
 done:
    if (vec)
        free(vec);
    return retval;
}

/*! Given an xpath encoded in a cbuf, append a second xpath into the first (unless absolute path)
 *
 * The method reuses prefixes from xpath1 if they exist, otherwise the module prefix
 * from y is used. Unless the element is .., .
 * @param[in,out] cb0     Result XPath as cbuf
 * @param[in]     xpath1  Input XPath
 * @param[in]     y       Yang of xpath1
 * @param[in,out] nsc     Namespace
 * @retval        0       OK
 * @retval       -1       Error
 *
 * XXX: Predicates not handled
 * The algorithm is not fool-proof, there are many cases it may not work
 * To make it more complete, maybe parse the xpath to a tree and put it
 * back to an xpath after modifcations, something like:
   if (xpath_parse(yang_argument_get(ypath), &xpt) < 0)
     goto done;
   if (xpath_tree2cbuf(xpt, xcb) < 0)
     goto done;
 */
static int
xpath_append(cbuf      *cb0,
             char      *xpath1,
             yang_stmt *y,
             cvec      *nsc)
{
    int    retval = -1;
    char **vec = NULL;
    char  *v;
    int    nvec;
    int    i;
    char  *myprefix;
    char  *id = NULL;
    char  *prefix = NULL;
    int    initialups = 1; /* If starts with ../../.. */
    char  *xpath0;
    char  *ns;
    int    j;
    int    ret;

    if (cb0 == NULL){
        clixon_err(OE_XML, EINVAL, "cb0 is NULL");
        goto done;
    }
    if (xpath1 == NULL || strlen(xpath1)==0)
        goto ok;
    if ((myprefix = yang_find_myprefix(y)) == NULL)
        goto done;
    if ((vec = clixon_strsep1(xpath1, "/", &nvec)) == NULL)
        goto done;
    if (xpath1[0] == '/')
        cbuf_reset(cb0);
    xpath0 = cbuf_get(cb0);
    for (i=0; i<nvec; i++){
        v = vec[i];
        if (strlen(v) == 0)
            continue;
        if (nodeid_split(v, &prefix, &id) < 0)
            goto done;
        if (strcmp(id, ".") == 0)
            initialups = 0;
        else if (strcmp(id, "..") == 0){
            if (initialups){
                /* Subtract from xpath0 */
                for (j=cbuf_len(cb0); j >= 0; j--){
                    if (xpath0[j] != '/')
                        continue;
                    cbuf_trunc(cb0, j);
                    break;
                }
            }
            else{
                initialups = 0;
                cprintf(cb0, "/%s", id);
            }
        }
        else{
            initialups = 0;
            /* If prefix is not in nsc, it needs to be added */
            if (prefix && cvec_find(nsc, prefix) == NULL){
                ns = NULL;
                if ((ret = yang_find_namespace_by_prefix(y, prefix, &ns)) < 0)
                    goto done;
                if (ret == 0){
                    clixon_err(OE_DB, 0, "Prefix %s does not have an associated namespace", prefix);
                    goto done;
                }
                if (xml_nsctx_add(nsc, prefix, ns) < 0)
                    goto done;
            }
            cprintf(cb0, "/%s:%s", prefix?prefix:myprefix, id);
        }
        if (prefix){
            free(prefix);
            prefix = NULL;
        }
        if (id){
            free(id);
            id = NULL;
        }
    }
 ok:
    retval = 0;
 done:
    if (prefix)
        free(prefix);
    if (id)
        free(id);
    free(vec);
    return retval;
}

/*! If xpath and leafref-refer and innermost yang is leafref, then append path to xpath
 *
 * Extend xpath with leafref path: Append yang_argument_get(ypath) to xpath
 * @param[in]     yn      Yang node
 * @param[in]     nsc     Namespace context
 * @param[in,out] cbxpath XPath optionally extended with leafref path
 * @retval        0       OK
 * @retval       -1       Error
 */
static int
leafref_append_path(yang_stmt *yn,
                    cvec      *nsc,
                    cbuf      *cbxpath)
{
    int        retval = -1;
    yang_stmt *ytype;
    yang_stmt *ypath;

    if ((ytype = yang_find(yn, Y_TYPE, NULL)) != NULL &&
        strcmp(yang_argument_get(ytype), "leafref") == 0){
        if ((ypath = yang_find(ytype, Y_PATH, NULL)) == NULL){
            clixon_err(OE_DB, 0, "Leafref %s requires path statement", yang_argument_get(ytype));
            goto done;
        }
        if (xpath_append(cbxpath, yang_argument_get(ypath), yn, nsc) < 0)
            goto done;
    }
    retval = 0;
 done:
    return retval;
}

/*! Get detailed information of configuration path: XPath or RFC 8040 api-path
 *
 * @param[in]  h       Clixon handle
 * @param[in]  xe      Request: <rpc><xn></rpc>
 * @param[out] cbret   Return xml tree, eg <rpc-reply>..., <rpc-error..
 * @param[in]  arg     client-entry
 * @param[in]  regarg  User argument given at rpc_callback_register()
 * @retval     0       OK
 * @retval    -1       Error
 */
static int
from_client_config_path_info(clixon_handle h,
                             cxobj        *xe,
                             cbuf         *cbret,
                             void         *arg,
                             void         *regarg)
{
    int        retval = -1;
    char      *api_path0 = NULL;
    int        strict = 0;
    char      *xpath0 = NULL; /* Input */
    char      *api_path1 = NULL;
    char      *xpath1 = NULL; /* Output */
    cxobj     *xtop = NULL;
    cxobj     *xbot;
    char      *str;
    char      *body;
    int        leafref_refer = 0;
    yang_stmt *ybot = NULL; /* yang spec of xpath */
    cxobj     *xerr = NULL;
    cvec      *nsc0 = NULL;
    cvec      *nsc1 = NULL;
    cbuf      *cbxpath = NULL;
    cbuf      *cbapipath = NULL;
    yang_stmt *yspec0;
    yang_stmt *yspec;
    yang_stmt *ymod = NULL;
    cxobj     *x;
    cxobj     *xpt = NULL;
    cg_var    *cv;
    char      *prefix = NULL;
    char      *ns = NULL;
    int        create = 0;
    int        ret;

    if ((yspec0 = clicon_dbspec_yang(h)) == NULL){
        clixon_err(OE_FATAL, 0, "No DB_SPEC");
        goto done;
    }
    if ((str = xml_find_body(xe, "leafref-refer")) != NULL)
        leafref_refer = strcmp(str, "true") == 0;
    body = xml_find_body(xe, "body");
    if ((xtop = xml_new(DATASTORE_TOP_SYMBOL, NULL, CX_ELMNT)) == NULL)
        goto done;
    xbot = xtop;
    if ((x = xml_find_type(xe, NULL, "api-path", CX_ELMNT)) != NULL){
        if (xml_find_type(xe, NULL, "xpath", CX_ELMNT) != NULL){
            clixon_err(OE_NETCONF, 0, "Both xpath and api-path given, but are mutually exclusive");
            goto done;
        }
        api_path0 = xml_body(x);
        if ((str = xml_find_body(xe, "strict")) != NULL)
            strict = strcmp(str, "true") == 0;
        if ((ret = api_path2xml(api_path0, yspec0, xtop, YC_DATANODE, strict, &xbot, &ybot, &xerr)) < 0)
            goto done;
        if (ret == 0){
            if (clixon_xml2cbuf1(cbret, xerr, 0, 0, NULL, -1, 1, 0, WITHDEFAULTS_EXPLICIT) < 0)
                goto done;
            goto ok;
        }
        if ((ret = api_path2xpath(api_path0, yspec0, &xpath1, &nsc1, &xerr)) < 0) // XXX
            goto done;
        if (ret == 0){
            if (clixon_xml2cbuf1(cbret, xerr, 0, 0, NULL, -1, 1, 0, WITHDEFAULTS_EXPLICIT) < 0)
                goto done;
            goto ok;
        }
        if ((api_path1 = strdup(api_path0)) == NULL){
            clixon_err(OE_UNIX, errno, "strdup");
            goto done;
        }
    }
    else if ((x = xml_find_type(xe, NULL, "xpath", CX_ELMNT)) != NULL){
        if (xml_find_type(xe, NULL, "api-path", CX_ELMNT) != NULL){
            clixon_err(OE_NETCONF, 0, "Both xpath and api-path given, but are mutually exclusive");
            goto done;
        }
        xpath0 = xml_body(x);
        if (xml_find(xe, "namespace-context") != NULL){
            if (xml_nsctx_parse(xe, &nsc0) < 0)
                goto done;
        }
         if (nsc0 == NULL){
            create = 1;
            if ((nsc0 = cvec_new(0)) == NULL){
                clixon_err(OE_UNIX, errno, "cvec_new");
                goto done;
            }
        }
        if ((ret = xpath2xml(xpath0, nsc0, xtop, yspec0, create, &xbot, &ybot, &xerr)) < 0)
            goto done;
        if (ret == 0){
            if (clixon_xml2cbuf1(cbret, xerr, 0, 0, NULL, -1, 1, 0, WITHDEFAULTS_EXPLICIT) < 0)
                goto done;
            goto ok;
        }
        if ((ret = xpath2api_path(xpath0, nsc0, yspec0, &api_path1, &xerr)) < 0){
            ; /* OK to fail create api-path from some xpaths, but could be nicer with a ret=0 */
            // goto done;
        }
        if (ret == 0){
            if (clixon_xml2cbuf1(cbret, xerr, 0, 0, NULL, -1, 1, 0, WITHDEFAULTS_EXPLICIT) < 0)
                goto done;
            goto ok;
        }
        if ((ret = xpath2canonical(xpath0, nsc0, yspec0, &xpath1, &nsc1, NULL)) < 0)
            goto done;
    }
    else {
        clixon_err(OE_NETCONF, 0, "Mandatory xpath or api-path missing");
        goto done;
    }
    if (ybot && yang_keyword_get(ybot) && body){
        cxobj *xb;
        if ((xb = xml_new("body", xbot, CX_BODY)) == NULL)
            goto done;
        if (xml_value_set(xb, body) < 0)
            goto done;
    }
    if (ybot)
        yspec =  ys_spec(ybot);
    else
        yspec = yspec0;
    if (xml_apply0(xbot, CX_ELMNT, identityref_add_ns, yspec) < 0)
        goto done;
    if (ybot){
        ns = yang_find_mynamespace(ybot);
        prefix = yang_find_myprefix(ybot);
        ymod = ys_module(ybot);
    }
    if ((cbxpath = cbuf_new()) == NULL){
        clixon_err(OE_UNIX, errno, "cbuf_new");
        goto done;
    }
    cbuf_append_str(cbxpath, xpath1);
    /* Extend xpath if leafref, special case */
    if (ybot && cbuf_len(cbxpath) && leafref_refer){
        if (leafref_append_path(ybot, nsc1, cbxpath) < 0)
            goto done;
    }
    /* Fix namespaces in xpath */
    if ((xpt = xml_new_body("xpath", NULL, cbuf_get(cbxpath))) == NULL){
        clixon_err(OE_UNIX, errno, "xml_new");
        goto done;
    }
    if (xmlns_set(xpt, NULL, CLIXON_LIB_NS) < 0)
        goto done;
    if (xmlns_set_all(xpt, nsc1) < 0)
        goto done;
    cprintf(cbret, "<rpc-reply xmlns=\"%s\">", NETCONF_BASE_NAMESPACE);
    cprintf(cbret, "<xml xmlns=\"%s\">", CLIXON_LIB_NS);
    if (clixon_xml2cbuf1(cbret, xtop, 0, 0, NULL, -1, 1, 0, WITHDEFAULTS_REPORT_ALL) < 0)
        goto done;
    cprintf(cbret, "</xml>");
    if (api_path1 != NULL){
        cprintf(cbret, "<api-path xmlns=\"%s\">", CLIXON_LIB_NS);
        if (xml_chardata_cbuf_append(cbret, 0, api_path1) < 0)
            goto done;
        cprintf(cbret, "</api-path>");
    }
    if (clixon_xml2cbuf1(cbret, xpt, 0, 0, NULL, -1, 0, 0, WITHDEFAULTS_REPORT_ALL) < 0)
        goto done;
    if (nsc1){
        cprintf(cbret, "<namespace-context xmlns=\"%s\">", CLIXON_LIB_NS);
        cv = NULL;
        while ((cv = cvec_each(nsc1, cv)) != NULL) {
            cprintf(cbret, "<namespace>");
            cprintf(cbret, "<prefix>%s</prefix>", cv_name_get(cv)?cv_name_get(cv):"");
            cprintf(cbret, "<ns>%s</ns>", cv_string_get(cv));
            cprintf(cbret, "</namespace>");
        }
        cprintf(cbret, "</namespace-context>");
    }
    if (ybot)
        cprintf(cbret, "<symbol xmlns=\"%s\">%s</symbol>", CLIXON_LIB_NS, yang_argument_get(ybot));
    if (prefix)
        cprintf(cbret, "<prefix xmlns=\"%s\">%s</prefix>", CLIXON_LIB_NS, prefix);
    if (ns)
        cprintf(cbret, "<ns xmlns=\"%s\">%s</ns>", CLIXON_LIB_NS, ns);
    if (ymod){
        cprintf(cbret, "<module xmlns=\"%s\">%s</module>", CLIXON_LIB_NS, yang_argument_get(ymod));
        cprintf(cbret, "<filename xmlns=\"%s\">%s</filename>", CLIXON_LIB_NS, yang_filename_get(ymod));
    }
    cprintf(cbret, "</rpc-reply>");
 ok:
    retval = 0;
 done:
    if (cbxpath)
        cbuf_free(cbxpath);
    if (cbapipath)
        cbuf_free(cbapipath);
    if (api_path1)
        free(api_path1);
    if (nsc0)
        xml_nsctx_free(nsc0);
    if (nsc1)
        xml_nsctx_free(nsc1);
    if (xpath1)
        free(xpath1);
    if (xerr)
        xml_free(xerr);
    if (xtop)
        xml_free(xtop);
    if (xpt)
        xml_free(xpt);
    return retval;
}

/*! Translate data from XML to other datastore formats
 *
 * @param[in]  h       Clixon handle
 * @param[in]  xe      Request: <rpc><xn></rpc>
 * @param[out] cbret   Return xml tree, eg <rpc-reply>..., <rpc-error..
 * @param[in]  arg     client-entry
 * @param[in]  regarg  User argument given at rpc_callback_register()
 * @retval     0       OK
 * @retval    -1       Error
 */
static int
from_client_translate_format(clixon_handle h,
                             cxobj        *xe,
                             cbuf         *cbret,
                             void         *arg,
                             void         *regarg)
{
    int              retval = -1;
    enum format_enum format = FORMAT_XML;
    int              pretty = 0;
    int              skiptop = 0;
    int              cli_aware = 0;
    char            *b;
    char            *prepend = NULL;
    char            *xpath = NULL;
    cxobj           *xdata = NULL;
    cxobj           *xp;
    cxobj          **vec = NULL;
    size_t           veclen;
    cxobj           *xnsc;
    cxobj           *xerr = NULL;
    yang_stmt       *yspec0;
    int              i;
    cbuf            *cb = NULL;
    cvec            *nsc = NULL;
    int              ret;

    if ((yspec0 = clicon_dbspec_yang(h)) == NULL){
        clixon_err(OE_FATAL, 0, "No DB_SPEC");
        goto done;
    }
    if ((b = xml_find_body(xe, "format")) != NULL){
        if ((ret = format_str2int(b)) < 0){
            clixon_err(OE_XML, 0, "format not found %s", b);
            goto done;
        }
        format = ret;
    }
    if ((b = xml_find_body(xe, "pretty")) != NULL)
        pretty = strcmp(b, "true") == 0;
    if ((b = xml_find_body(xe, "skiptop")) != NULL)
        skiptop = strcmp(b, "true") == 0;
    if ((b = xml_find_body(xe, "cli-aware")) != NULL)
        cli_aware = strcmp(b, "true") == 0;
    prepend = xml_find_body(xe, "prepend");
    xpath = xml_find_body(xe, "xpath");
    if ((xnsc = xml_find(xe, "namespace-context")) != NULL){
        cxobj *xn;
        char *prefix;
        char *ns;

        if ((nsc = cvec_new(0)) == NULL){
            clixon_err(OE_UNIX, errno, "cvec_new");
            goto done;
        }
        xn = NULL;
        while ((xn = xml_child_each(xnsc, xn, CX_ELMNT)) != NULL){
            prefix = xml_find_body(xn, "prefix");
            ns = xml_find_body(xn, "ns");
            if (xml_nsctx_add(nsc, prefix, ns) < 0)
                goto done;
        }
    }
    if ((xdata = xml_find(xe, "xml")) != NULL){
        xml_rm(xdata);
        if ((ret = xml_bind_yang(h, xdata, YB_MODULE, yspec0, 0, &xerr)) < 0)
            goto done;
        if (ret == 0){
            if (clixon_xml2cbuf1(cbret, xerr, 0, 0, NULL, -1, 1, 0, WITHDEFAULTS_EXPLICIT) < 0)
                goto done;
            goto ok;
        }
        if (xpath_vec(xdata, nsc, "%s", &vec, &veclen, xpath) < 0)
            goto done;
        if ((cb = cbuf_new()) == NULL){
            clixon_err(OE_UNIX, errno, "cbuf_new");
            goto done;
        }
        if (format == FORMAT_JSON){
            if (xml2json_cbuf_vec(cb, vec, veclen, pretty, skiptop) < 0)
                goto done;
        }
        else{
            for (i=0; i<veclen; i++){
                xp = vec[i];
                if (xml_type(xp) != CX_ELMNT)
                    continue;
                /* Print configuration according to format */
                switch (format){
                case FORMAT_XML:
                    if (clixon_xml2cbuf1(cb, xp, 0, pretty, NULL, -1, skiptop, cli_aware, WITHDEFAULTS_REPORT_ALL) < 0)
                        goto done;
                    if (!pretty && i == veclen-1)
                        cprintf(cb, "\n");
                    break;
                case FORMAT_TEXT: /* XXX does not handle multiple leaf-list */
                    if (clixon_text2cbuf(cb, xp, 0, skiptop, cli_aware) < 0)
                        goto done;
                    break;
                case FORMAT_CLI:
                    /* If xp is not bound, cli prints are skipped */
                    if (clixon_cli2cbuf(h, cb, xp, prepend, skiptop) < 0) /* cli syntax */
                        goto done;
                    break;
                case FORMAT_NETCONF:
                    if (i==0){
                        cprintf(cb, "<rpc xmlns=\"%s\" %s",
                                      NETCONF_BASE_NAMESPACE, NETCONF_MESSAGE_ID_ATTR);
                        cprintf(cb, " xmlns:%s=\"%s\"", CLIXON_LIB_PREFIX, CLIXON_LIB_NS);
                        cprintf(cb, " %s:username=\"%s\"", CLIXON_LIB_PREFIX, clicon_username_get(h));
                        cprintf(cb, "><edit-config><target><candidate/></target><config>");
                        if (pretty)
                            cprintf(cb, "\n");
                    }
                    if (clixon_xml2cbuf1(cb, xp, 2, pretty, NULL, -1, skiptop, cli_aware, WITHDEFAULTS_REPORT_ALL) < 0)
                        goto done;
                    if (i == veclen-1)
                        cprintf(cb, "</config></edit-config></rpc>]]>]]>\n");
                    break;
                default:
                    break;
                }
            }
        }
    }
    cprintf(cbret, "<rpc-reply xmlns=\"%s\">", NETCONF_BASE_NAMESPACE);
    cprintf(cbret, "<data xmlns=\"%s\">", CLIXON_LIB_NS);
    cprintf(cbret, "<![CDATA[");
    cbuf_append_str(cbret, cbuf_get(cb)); // XXX double copy
    cprintf(cbret, "]]>");
    cprintf(cbret, "</data>");
    cprintf(cbret, "</rpc-reply>");
 ok:
    retval = 0;
 done:
    if (vec)
        free(vec);
    if (nsc)
        cvec_free(nsc);
    if (cb)
        cbuf_free(cb);
    if (xdata)
        xml_free(xdata);
    if (xerr)
        xml_free(xerr);
    return retval;
}

/*! Init clixon lib rpc:s
 *
 * @param[in]  h     Clixon handle
 * @retval     0     OK
 * @retval    -1     Error (fatal)
 */
int
backend_clixon_lib_init(clixon_handle h)
{
    int retval = -1;

    if (rpc_callback_register(h, from_client_debug, NULL,
                              CLIXON_LIB_NS, "debug") < 0)
        goto done;
    if (rpc_callback_register(h, from_client_ping, NULL,
                              CLIXON_LIB_NS, "ping") < 0)
        goto done;
    if (rpc_callback_register(h, from_client_stats, NULL,
                              CLIXON_LIB_NS, "stats") < 0)
        goto done;
    if (rpc_callback_register(h, from_client_process_control, NULL,
                              CLIXON_LIB_NS, "process-control") < 0)
        goto done;
    if (rpc_callback_register(h, from_client_restart_plugin, NULL,
                              CLIXON_LIB_NS, "restart-plugin") < 0)
        goto done;
    if (rpc_callback_register(h, from_client_config_path_info, NULL,
                              CLIXON_LIB_NS, "config-path-info") < 0)
        goto done;
    if (rpc_callback_register(h, from_client_translate_format, NULL,
                              CLIXON_LIB_NS, "translate-format") < 0)
        goto done;

    retval = 0;
 done:
    return retval;
}
