/*
 *
  ***** BEGIN LICENSE BLOCK *****

  Copyright (C) 2009-2016 Olof Hagsand and Benny Holmgren
  Copyright (C) 2017-2019 Olof Hagsand
  Copyright (C) 2020-2022 Olof Hagsand and Rubicon Communications, LLC(Netgate)

  This file is part of CLIXON.

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.

  Alternatively, the contents of this file may be used under the terms of
  the GNU General Public License Version 3 or later (the "GPL"),
  in which case the provisions of the GPL are applicable instead
  of those above. If you wish to allow use of your version of this file only
  under the terms of the GPL, and not to allow others to
  use your version of this file under the terms of Apache License version 2,
  indicate your decision by deleting the provisions above and replace them with
  the  notice and other provisions required by the GPL. If you do not delete
  the provisions above, a recipient may use your version of this file under
  the terms of any one of the Apache License version 2 or the GPL.

  ***** END LICENSE BLOCK *****

 */

#ifdef HAVE_CONFIG_H
#include "clixon_config.h" /* generated by config & autoconf */
#endif

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdarg.h>
#include <inttypes.h>
#include <errno.h>
#include <signal.h>
#include <fcntl.h>
#include <time.h>
#include <syslog.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <sys/param.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netinet/in.h>

/* cligen */
#include <cligen/cligen.h>

/* clixon */
#include <clixon/clixon.h>

#include "clixon_backend_client.h"
#include "clixon_backend_plugin.h"
#include "clixon_backend_commit.h"
#include "backend_client.h"
#include "backend_handle.h"
#include "backend_state.h"

/*! Restconf get capabilities
 *
 * Maybe should be in the restconf client instead of backend?
 * @param[in]     h       Clixon handle
 * @param[in]     yspec   Yang spec
 * @param[in]     xpath   Xpath selection, not used but may be to filter early
 * @param[out]    xrs     XML restconf-state node
 * @retval        0       OK
 * @retval       -1       Error
 * @see netconf_hello_server
 * @see rfc8040 Sections 9.1
 */
static int
restconf_client_get_capabilities(clixon_handle h,
                                 yang_stmt    *yspec,
                                 char         *xpath,
                                 cxobj       **xret)
{
    int     retval = -1;
    cxobj  *xrstate = NULL; /* xml restconf-state node */
    cbuf   *cb = NULL;

    if ((xrstate = xpath_first(*xret, NULL, "restconf-state")) == NULL){
        clixon_err(OE_YANG, ENOENT, "restconf-state not found in config node");
        goto done;
    }
    if ((cb = cbuf_new()) == NULL){
        clixon_err(OE_UNIX, errno, "cbuf_new");
        goto done;
    }
    cprintf(cb, "<capabilities>");
    cprintf(cb, "<capability>urn:ietf:params:restconf:capability:defaults:1.0?basic-mode=explicit</capability>");
    cprintf(cb, "<capability>urn:ietf:params:restconf:capability:depth:1.0</capability>");
    cprintf(cb, "<capability>urn:ietf:params:restconf:capability:with-defaults:1.0</capability>");
    cprintf(cb, "</capabilities>");
    if (clixon_xml_parse_string(cbuf_get(cb), YB_PARENT, NULL, &xrstate, NULL) < 0)
        goto done;
    retval = 0;
 done:
    if (cb)
        cbuf_free(cb);
    return retval;
}

/*! Get streams state according to RFC 8040 or RFC5277 common function
 *
 * @param[in]     h       Clixon handle
 * @param[in]     yspec   Yang spec
 * @param[in]     xpath   XPath selection, not used but may be to filter early
 * @param[in]     nsc     Namespace context
 * @param[in]     module  Name of yang module
 * @param[in]     top     Top symbol, ie netconf or restconf-state
 * @param[in,out] xret    Existing XML tree, merge x into this
 * @retval        1       OK
 * @retval        0       Statedata callback failed
 * @retval       -1       Error (fatal)
 */
static int
client_get_streams(clixon_handle h,
                   yang_stmt    *yspec,
                   char         *xpath,
                   cvec         *nsc,
                   yang_stmt    *ymod,
                   char         *top,
                   cxobj       **xret)
{
    int            retval = -1;
    yang_stmt     *yns = NULL;  /* yang namespace */
    cbuf          *cb = NULL;

    if ((yns = yang_find(ymod, Y_NAMESPACE, NULL)) == NULL){
        clixon_err(OE_YANG, 0, "%s yang namespace not found", yang_argument_get(ymod));
        goto done;
    }
    if ((cb = cbuf_new()) == NULL){
        clixon_err(OE_UNIX, errno, "cbuf_new");
        goto done;
    }
    cprintf(cb, "<%s xmlns=\"%s\">", top, yang_argument_get(yns));
    /* Second argument is a hack to have the same function for the
     * RFC5277 and 8040 stream cases
     */
    if (stream_get_xml(h, strcmp(top, "restconf-state")==0, cb) < 0)
        goto done;
    cprintf(cb,"</%s>", top);

    if (clixon_xml_parse_string(cbuf_get(cb), YB_MODULE, yspec, xret, NULL) < 0){
        if (xret && netconf_operation_failed_xml(xret, "protocol", clixon_err_reason())< 0)
            goto done;
        goto fail;
    }
    retval = 1;
 done:
    if (cb)
        cbuf_free(cb);
    return retval;
 fail:
    retval = 0;
    goto done;
}

/*! Get backend-specific client netconf monitoring state
 *
 * Backend-specific netconf monitoring state is:
 *   sessions
 * @param[in]     h       Clixon handle
 * @param[in]     yspec   Yang spec
 * @param[in]     xpath   XML Xpath
 * @param[in]     nsc     XML Namespace context for xpath
 * @param[in,out] xret    Existing XML tree, merge x into this
 * @param[out]    xerr    XML error tree, if retval = 0
 * @retval        1       OK
 * @retval        0       Statedata callback failed, error in xerr
 * @retval       -1       Error (fatal)
 * @see RFC 6022
 */
static int
backend_monitoring_state_get(clixon_handle h,
                             yang_stmt    *yspec,
                             char         *xpath,
                             cvec         *nsc,
                             cxobj       **xret,
                             cxobj       **xerr)
{
    int           retval = -1;
    cbuf         *cb = NULL;
    client_entry *ce;
    char          timestr[28];
    int           ret;

    if ((cb = cbuf_new()) ==NULL){
        clixon_err(OE_XML, errno, "cbuf_new");
        goto done;
    }
    cprintf(cb, "<netconf-state xmlns=\"%s\">", NETCONF_MONITORING_NAMESPACE);
    cprintf(cb, "<sessions>");
    for (ce = backend_client_list(h); ce; ce = ce->ce_next){
        cprintf(cb, "<session>");
        cprintf(cb, "<session-id>%u</session-id>", ce->ce_id);
        if (ce->ce_transport == NULL){
#ifdef NOTYET // XXX: too strict, race conditions in clixon_snmp
            clixon_err(OE_XML, 0, "Mandatory element transport missing");
            goto done;
#else
            cprintf(cb, "<transport xmlns:%s=\"%s\">cl:netconf</transport>",
                    CLIXON_LIB_PREFIX, CLIXON_LIB_NS);
#endif
        }
        else
            cprintf(cb, "<transport xmlns:%s=\"%s\">%s</transport>",
                    CLIXON_LIB_PREFIX, CLIXON_LIB_NS,
                    ce->ce_transport);
        cprintf(cb, "<username>%s</username>", ce->ce_username);
        if (ce->ce_source_host)
            cprintf(cb, "<source-host>%s</source-host>", ce->ce_source_host);
        if (ce->ce_time.tv_sec != 0){
            if (time2str(&ce->ce_time, timestr, sizeof(timestr)) < 0){
                clixon_err(OE_UNIX, errno, "time2str");
                goto done;
            }
            cprintf(cb, "<login-time>%s</login-time>", timestr);
        }
        cprintf(cb, "<in-rpcs>%u</in-rpcs>", ce->ce_in_rpcs);
        cprintf(cb, "<in-bad-rpcs>%u</in-bad-rpcs>", ce->ce_in_bad_rpcs);
        cprintf(cb, "<out-rpc-errors>%u</out-rpc-errors>", ce->ce_out_rpc_errors);
        cprintf(cb, "<out-notifications>%u</out-notifications>", ce->ce_out_notifications);
        cprintf(cb, "</session>");
    }
    cprintf(cb, "</sessions>");
    cprintf(cb, "</netconf-state>");
    if ((ret = clixon_xml_parse_string(cbuf_get(cb), YB_MODULE, yspec, xret, xerr)) < 0)
        goto done;
    if (ret == 0)
        goto fail;
    retval = 1;
 done:
    clixon_debug(CLIXON_DBG_BACKEND, "retval:%d", retval);
    if (cb)
        cbuf_free(cb);
    return retval;
 fail:
    retval = 0;
    goto done;
}

/*! Get system state-data, including streams and plugins
 *
 * @param[in]     h       Clixon handle
 * @param[in]     xpath   XPath selection, may be used to filter early
 * @param[in]     nsc     XML Namespace context for xpath
 * @param[in,out] xret    Existing XML tree, merge x into this, or rpc-error
 * @retval        1       OK
 * @retval        0       Statedata callback failed (error in xret)
 * @retval       -1       Error (fatal)
 * @note This code in general does not look at xpath, needs to be filtered in retrospect
 * @note Awkward error handling. Even if most of this is during development phase, except for plugin
 * state callbacks.
 * Present behavior:
 *   - Present behavior: should be returned in xret with retval 0(error) or 1(ok)
 *   - On error, previous content of xret is not freed
 *   - xret is in turn translated to cbuf in calling function
 * Instead, I think there should be a second out argument **xerr with the error message, see code
 * for CLICON_NETCONF_MONITORING which is transformed in calling function(?) to an internal error
 * message. But this needs to be explored in all sub-functions
 */
int
get_state_data(clixon_handle h,
               char         *xpath,
               cvec         *nsc,
               cxobj       **xret)
{
    int        retval = -1;
    yang_stmt *yspec;
    yang_stmt *ymod;
    cxobj     *x1 = NULL;
    cbuf      *cb = NULL;
    cxobj     *xerr = NULL;
    int        ret;

    clixon_debug(CLIXON_DBG_BACKEND, "");
    if ((yspec = clicon_dbspec_yang(h)) == NULL){
        clixon_err(OE_YANG, ENOENT, "No yang spec");
        goto done;
    }
    if ((cb = cbuf_new()) == NULL){
        clixon_err(OE_UNIX, errno, "cbuf_new");
        goto done;
    }
    if (clicon_option_bool(h, "CLICON_STREAM_DISCOVERY_RFC5277")){
        if ((ymod = yang_find_module_by_name(yspec, "clixon-rfc5277")) == NULL){
            clixon_err(OE_YANG, ENOENT, "yang module clixon-rfc5277 not found");
            goto done;
        }
        if ((ret = client_get_streams(h, yspec, xpath, nsc, ymod, "netconf", &x1)) < 0)
            goto done;
        if (ret == 0)
            goto fail;
        if (xpath_first(x1, nsc, "%s", xpath) != NULL){
            if ((ret = netconf_trymerge(x1, yspec, xret)) < 0)
                goto done;
            if (ret == 0)
                goto fail;
        }
    }
    if (clicon_option_bool(h, "CLICON_STREAM_DISCOVERY_RFC8040")){
        if ((ymod = yang_find_module_by_name(yspec, "ietf-restconf-monitoring")) == NULL){
            clixon_err(OE_YANG, ENOENT, "yang module ietf-restconf-monitoring not found");
            goto done;
        }
        if ((ret = client_get_streams(h, yspec, xpath, nsc, ymod, "restconf-state", &x1)) < 0)
            goto done;
        if (ret == 0)
            goto fail;
        if (restconf_client_get_capabilities(h, yspec, xpath, &x1) < 0)
            goto done;
        if (xpath_first(x1, nsc, "%s", xpath) != NULL){
            if ((ret = netconf_trymerge(x1, yspec, xret)) < 0)
                goto done;
            if (ret == 0)
                goto fail;
        }
    }
    if (clicon_option_bool(h, "CLICON_YANG_LIBRARY")){
        if ((ret = yang_modules_state_get(h, yspec, xpath, nsc, 0, xret)) < 0)
            goto done;
        if (ret == 0)
            goto fail;
    }
    if (clicon_option_bool(h, "CLICON_NETCONF_MONITORING"))
        if (xpath == NULL ||         /* Raw optimization of xpath filtering */
            strcmp(xpath, "/") == 0 ||
            strstr(xpath, "netconf-state") != 0){
            if ((ret = netconf_monitoring_state_get(h, yspec, xpath, nsc, xret, &xerr)) < 0)
                goto done;
            if (ret == 0){
                if (clixon_netconf_internal_error(xerr, " . Internal error, netconf_monitoring_state returned invalid XML", NULL) < 0)
                    goto done;
                if (*xret)
                    xml_free(*xret);
                *xret = xerr;
                xerr = NULL;
                goto fail;
            }
            /* Some state, client state, is avaliable in backend only, not in lib
             * Needs merge since same subtree as previous lib state
             */
            if ((ret = backend_monitoring_state_get(h, yspec, xpath, nsc, &x1, &xerr)) < 0)
                goto done;
            if (ret == 0){
                if (clixon_netconf_internal_error(xerr, " . Internal error, backend_monitoring_state_get returned invalid XML", NULL) < 0)
                    goto done;
                if (*xret)
                    xml_free(*xret);
                *xret = xerr;
                xerr = NULL;
                goto fail;
            }
            if (xpath_first(x1, nsc, "%s", xpath) != NULL){
                if ((ret = netconf_trymerge(x1, yspec, xret)) < 0)
                    goto done;
                if (ret == 0)
                    goto fail;
            }
        }
    if (clicon_option_bool(h, "CLICON_YANG_SCHEMA_MOUNT")){
        if ((ret = yang_schema_mount_statedata(h, yspec, xpath, nsc, xret, &xerr)) < 0)
            goto done;
        if (ret == 0){
            if (clixon_netconf_internal_error(xerr, " . Internal error, schema_mounts_state_get returned invalid XML", NULL) < 0)
                goto done;
            if (*xret)
                xml_free(*xret);
            *xret = xerr;
            xerr = NULL;
            goto fail;
        }
    }
    /* Use plugin state callbacks */
    if ((ret = clixon_plugin_statedata_all(h, yspec, nsc, xpath, xret)) < 0)
        goto done;
    if (ret == 0)
        goto fail;
    retval = 1; /* OK */
 done:
    clixon_debug(CLIXON_DBG_BACKEND, "retval:%d", retval);
    if (xerr)
        xml_free(xerr);
    if (x1)
        xml_free(x1);
    if (cb)
        cbuf_free(cb);
    return retval;
 fail:
    retval = 0;
    goto done;
}


/*! Merge state data into XML config tree
 *
 * @param[in]  h        Clixon handle
 * @param[in,out] xtop  Error XML tree, if retval is 0. Free with xml_free after use
 * @param[out] xret     Error XML tree, if retval is 0. Free with xml_free after use
 * @retval        1     Validation OK
 * @retval        0     Validation failed (with xret set)
 * @retval       -1     Error - or validation failed (but cbret not set)
 */
int
merge_state_data(clixon_handle h,
                 cxobj        *xtop,
                 yang_stmt    *yspec,
                 cxobj       **xret)
{
    int    retval = -1;
    cxobj *xstate = NULL;
    char  *reason = NULL;
    int    ret;

    if ((ret = get_state_data(h, "/", NULL, &xstate)) < 0)
        goto done;
    if (ret == 0){ /* Error from callback (error in xret) */
        *xret = xstate;
        xstate = NULL;
        goto fail;
    }
    if (xstate){
        /* Add defaults to state data. This consumes some cycles */
        /* Ensure all state-data is report-all */
        if (xml_global_defaults(h, xstate, NULL, "/", yspec, 1) < 0)
            goto done;
        /* Apply default values */
        if (xml_default_recurse(xstate, 1, 0) < 0)
            goto done;
        if ((ret = xml_merge(xtop, xstate, yspec, &reason)) < 0)
            goto done;
        xstate = NULL;
        if (ret == 0){
            if (netconf_operation_failed_xml(xret, "rpc", reason)< 0)
                goto done;
            goto fail;
        }
    }
    retval = 1;
 done:
    if (reason)
        free(reason);
    if (xstate)
        xml_free(xstate);
    return retval;
 fail:
    retval = 0;
    goto done;
}
