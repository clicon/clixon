/*
 *
  ***** BEGIN LICENSE BLOCK *****

  Copyright (C) 2009-2016 Olof Hagsand and Benny Holmgren
  Copyright (C) 2017-2019 Olof Hagsand
  Copyright (C) 2020-2022 Olof Hagsand and Rubicon Communications, LLC(Netgate)

  This file is part of CLIXON.

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.

  Alternatively, the contents of this file may be used under the terms of
  the GNU General Public License Version 3 or later (the "GPL"),
  in which case the provisions of the GPL are applicable instead
  of those above. If you wish to allow use of your version of this file only
  under the terms of the GPL, and not to allow others to
  use your version of this file under the terms of Apache License version 2,
  indicate your decision by deleting the provisions above and replace them with
  the  notice and other provisions required by the GPL. If you do not delete
  the provisions above, a recipient may use your version of this file under
  the terms of any one of the Apache License version 2 or the GPL.

  ***** END LICENSE BLOCK *****

 */

#ifdef HAVE_CONFIG_H
#include "clixon_config.h" /* generated by config & autoconf */
#endif

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdarg.h>
#include <inttypes.h>
#include <errno.h>
#include <signal.h>
#include <fcntl.h>
#include <time.h>
#include <syslog.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <sys/param.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netinet/in.h>

/* cligen */
#include <cligen/cligen.h>

/* clixon */
#include <clixon/clixon.h>

#include "clixon_backend_client.h"
#include "clixon_backend_plugin.h"
#include "clixon_backend_commit.h"
#include "backend_client.h"
#include "backend_handle.h"
#include "backend_state.h"
#include "backend_get.h"

/*! Help function to filter out anything that is outside of xpath
 *
 * Code complex to filter out anything that is outside of xpath
 * Actually this is a safety catch, should really be done in plugins
 * and modules_state functions.
 * But it is problematic, because defaults, at least of config data, is in place
 * and we need to re-add it.
 * Note original xpath
 *
 * @param[in]  h       Clixon handle
 * @param[in]  yspec   Yang spec
 * @param[in]  xret    Result XML tree
 * @param[in]  xvec    xpath lookup result on xret
 * @param[in]  xlen    length of xvec
 * @param[in]  xpath   XPath point to object to get
 * @param[in]  nsc     Namespace context of xpath
 * @retval     0       OK
 * @retval    -1       Error
 */
static int
filter_xpath_again(clixon_handle h,
                   yang_stmt    *yspec,
                   cxobj        *xret,
                   cxobj       **xvec,
                   size_t        xlen,
                   char         *xpath,
                   cvec         *nsc)
{
    int     retval = -1;
    int     i;

    if (xret == NULL){
        clixon_err(OE_PLUGIN, EINVAL, "xret is NULL");
        goto done;
    }
    /* If vectors are specified then mark the nodes found and
     * then filter out everything else,
     * otherwise return complete tree.
     */
    if (xvec != NULL){
        for (i=0; i<xlen; i++)
            xml_flag_set(xvec[i], XML_FLAG_MARK);
    }
    /* Remove everything that is not marked */
    if (!xml_flag(xret, XML_FLAG_MARK))
        if (xml_tree_prune_flagged_sub(xret, XML_FLAG_MARK, 1, NULL) < 0)
            goto done;
    /* reset flag */
    if (xml_apply(xret, CX_ELMNT, (xml_applyfn_t*)xml_flag_reset, (void*)XML_FLAG_MARK) < 0)
        goto done;
    retval = 0;
 done:
    return retval;
}

/*! Help function for NACM access and return message
 *
 * @param[in]  h        Clixon handle
 * @param[in]  xret     Result XML tree
 * @param[in]  xpath    XPath point to object to get
 * @param[in]  nsc      Namespace context of xpath
 * @param[in]  username User name for NACM access
 * @param[in]  depth    Nr of levels to print, -1 is all, 0 is none
 * @param[in]  wdef     With-defaults parameter
 * @param[out] cbret    Return xml tree, eg <rpc-reply>..., <rpc-error..
 * @retval     0        OK
 * @retval    -1        Error
 */
static int
get_nacm_and_reply(clixon_handle     h,
                   cxobj            *xret,
                   char             *xpath,
                   cvec             *nsc,
                   char             *username,
                   int32_t           depth,
                   withdefaults_type wdef,
                   cbuf             *cbret)
{
    int     retval = -1;
    cxobj  *xnacm = NULL;

    /* Pre-NACM access step */
    xnacm = clicon_nacm_cache(h);
    if (xnacm != NULL){ /* Do NACM validation */
        /* NACM datanode/module read validation */
        if (nacm_datanode_read1(h, xret, username, xnacm) < 0)
            goto done;
        if (nacm_datanode_read_prune(h, xret) < 0)
            goto done;
    }
    cprintf(cbret, "<rpc-reply xmlns=\"%s\">", NETCONF_BASE_NAMESPACE);     /* OK */
    if (xret==NULL)
        cprintf(cbret, "<data/>");
    else{
        if (xml_name_set(xret, NETCONF_OUTPUT_DATA) < 0)
            goto done;
        /* Top level is data, so add 1 to depth if significant */
        if (clixon_xml2cbuf1(cbret, xret, 0, 0, NULL, depth>0?depth+1:depth, 0, 0, wdef) < 0)
            goto done;
    }
    cprintf(cbret, "</rpc-reply>");
    retval = 0;
 done:
    return retval;
}

/*! Help function for parsing restconf query parameter and setting netconf attribute
 *
 * Parse and set a uint32 numeric value,
 * Accept also a default string (such as none/unbounded) which sets value to 0
 * @param[in]     h          Clixon handle
 * @param[in]     name       Name of attribute
 * @param[in]     defaultstr Default string which is accepted and sets value to 0
 * @param[in,out] cbret      Output buffer for internal bad-element RPC message if invalid
 * @param[out]    value      Value
 * @retval        1          OK (or not found)
 * @retval        0          Invalid, netconf bad-element error cbret set
 * @retval       -1          Error
 */
static int
element2value(clixon_handle h,
              cxobj        *xe,
              char         *name,
              char         *defaultstr,
              cbuf         *cbret,
              uint32_t     *value)
{
    char  *valstr;
    cxobj *x;

    *value = 0;
    if ((x = xml_find_type(xe, NULL, name, CX_ELMNT)) != NULL &&
        (valstr = xml_body(x)) != NULL){
        return netconf_parse_uint32(name, valstr, defaultstr, 0, cbret, value);
    }
    return 1;
}

/*! Extract offset and limit from get/list-pagination
 *
 * @param[in]  h      Clixon handle
 * @param[in]  xe     Request: <rpc><xn></rpc>
 * @param[out] offset Number of entries in the working result-set that should be skipped
 * @param[out] limit  Limits the number of entries returned from the working result-set
 * @param[out] cbret  Return xml tree, eg <rpc-reply>..., <rpc-error..
 * @retval     1      OK
 * @retval     0      Invalid, netconf bad-element error cbret set
 * @retval    -1      Error
 */
static int
list_pagination_hdr(clixon_handle h,
                    cxobj        *xe,
                    uint32_t     *offset,
                    uint32_t     *limit,
                    cbuf         *cbret)
{
    int retval = -1;

    /* offset */
    if ((retval = element2value(h, xe, "offset", "none", cbret, offset)) < 0)
        goto done;
    /* limit */
    if (retval && (retval = element2value(h, xe, "limit", "unbounded", cbret, limit)) < 0)
        goto done;
 done:
    return retval;
}

/*! Special handling of state data for partial reading
 *
 * @param[in]  h       Clixon handle
 * @param[in]  ce        Client entry, for locking
 * @param[in]  yspec     (Top-level) yang spec
 * @param[in]  xpath     XPath point to object to get
 * @param[in]  where
 * @param[in]  sort_by
 * @param[in]  direction NULL means forward
 * @param[in]  offset    Start of pagination interval
 * @param[in]  limit     Number of elements (limit)
 * @param[out] xret      Returned xml state tree
 * @param[out] cbret     Return xml tree, eg <rpc-reply>..., <rpc-error..
 * @retval     1         OK
 * @retval     0         Fail, cbret contains error message
 * @retval    -1         Error
 */
static int
get_pagination_state_partial(clixon_handle h,
                             client_entry *ce,
                             yang_stmt    *yspec,
                             char         *xpath,
                             char         *where,
                             char         *sort_by,
                             char         *direction,
                             uint32_t      offset,
                             uint32_t      limit,
                             cxobj        *xret,
                             cbuf         *cbret)
{
    int                 retval = -1;
    int                 locked;
    cbuf               *cberr = NULL;
    uint32_t            iddb; /* DBs lock, if any */
    cxobj              *xerr = NULL;
    pagination_data_t   pd = {0,};
    dispatcher_entry_t *htable = NULL;
    int                 ret;

    clixon_debug(CLIXON_DBG_BACKEND | CLIXON_DBG_DETAIL, "");
    if ((iddb = xmldb_islocked(h, "running")) != 0 &&
        iddb == ce->ce_id)
        locked = 1;
    else
        locked = 0;
    pd.pd_where = where;
    pd.pd_sort_by = sort_by;
    pd.pd_direction = direction;
    pd.pd_offset = offset;
    pd.pd_limit = limit;
    pd.pd_locked = locked;
    pd.pd_xstate = xret;
    clicon_ptr_get(h, "pagination-entries", (void**)&htable);
    if (htable){
        if (dispatcher_call_handlers(htable, h, xpath, &pd) < 0){
            if ((cberr = cbuf_new()) == NULL){
                clixon_err(OE_UNIX, errno, "cbuf_new");
                goto done;
            }
            /* error reason should be in clixon_err_reason */
            cprintf(cberr, "Internal error, pagination state callback invalid return : %s",
                    clixon_err_reason());
            if (netconf_operation_failed_xml(&xerr, "application", cbuf_get(cberr)) < 0)
                goto done;
            if (clixon_xml2cbuf1(cbret, xerr, 0, 0, NULL, -1, 0, 0, WITHDEFAULTS_REPORT_ALL) < 0)
                goto done;
            goto fail;
        }
    }

    /* System makes the binding */
    if ((ret = xml_bind_yang(h, xret, YB_MODULE, yspec, 0, &xerr)) < 0)
        goto done;
    if (ret == 0){
        clixon_debug_xml(CLIXON_DBG_BACKEND, xret, "Yang bind pagination state");
        if (clixon_netconf_internal_error(xerr,
                                          ". Internal error, state callback returned invalid XML",
                                          NULL) < 0)
            goto done;
        if (clixon_xml2cbuf1(cbret, xerr, 0, 0, NULL, -1, 0, 0, WITHDEFAULTS_REPORT_ALL) < 0)
            goto done;
        goto fail;
    }
    retval = 1;
 done:
    if (cberr)
        cbuf_free(cberr);
    if (xerr)
        xml_free(xerr);
    return retval;
 fail:
    retval = 0;
    goto done;
}

/*! Specialized get for list-pagination
 *
 * It is specialized enough to have its own function. Specifically, extra attributes as well
 * as the list-paginaiton API
 * @param[in]  h       Clixon handle
 * @param[in]  ce      Client entry, for locking
 * @param[in]  xe      Request: <rpc><xn></rpc>
 * @param[in]  content Get config/state/both
 * @param[in]  db      Database name
 * @param[in]  depth   Depth attribute
 * @param[in]  yspec   (Top-level) yang spec
 * @param[in]  xpath   XPath point to object to get
 * @param[in]  nsc     Namespace context of xpath
 * @param[in]  username
 * @param[in]  wdef    With-defaults parameter, see RFC 6243
 * @param[out] cbret   Return xml tree, eg <rpc-reply>..., <rpc-error..
 * @retval     0       OK
 * @retval    -1       Error
 * @note pagination uses appending xpath with predicate, eg [position()<limit], this may not work
 *       if there is an existing predicate
 * XXX Reuse code with get_common
 * From draft-ietf-netconf-list-pagination-04.txt 3.1:
   The order is as follows: a server first processes the "where"
   parameter (see Section 3.1.1), then the "sort-by" parameter (see
   Section 3.1.2), then the "direction" parameter (see Section 3.1.4),
   and either a combination of the "offset" parameter (see
   Section 3.1.5) or the "cursor" parameter (see Section 3.1.6), and
   lastly "the "limit" parameter (see Section 3.1.7).
 */
static int
get_list_pagination(clixon_handle     h,
                    client_entry     *ce,
                    cxobj            *xe,
                    netconf_content   content,
                    char             *db,
                    int32_t           depth,
                    yang_stmt        *yspec,
                    char             *xpath,
                    cvec             *nsc,
                    char             *username,
                    withdefaults_type wdef,
                    cbuf             *cbret
                    )
{
    int        retval = -1;
    uint32_t   offset = 0;
    uint32_t   limit = 0;
    uint32_t   upper;
    int        partial_pagination_cb = 0; /* use state partial reads callback */
    yang_stmt *ylist;
    cxobj     *xerr = NULL;
    cbuf      *cbmsg = NULL; /* For error msg */
    cxobj     *xret = NULL;
    cxobj    **xvec = NULL;
    cxobj    **xvec2;
    size_t     xlen;
    cxobj     *x;
    cxobj     *xj;
    cxobj     *xp;
    char      *sort_by = NULL;
    char      *direction = NULL;
    char      *where = NULL;
    int        i;
    int        j;
    dispatcher_entry_t *htable = NULL;
    cvec      *wherens = NULL;
    //    int        extflag = 0;
#ifdef LIST_PAGINATION_REMAINING
    cxobj     *xcache;
    uint32_t   total;
    uint32_t   remaining = 0;
#endif
    int        ret;

    clixon_debug(CLIXON_DBG_BACKEND | CLIXON_DBG_DETAIL, "");
    if (cbret == NULL){
        clixon_err(OE_PLUGIN, EINVAL, "cbret is NULL");
        goto done;
    }
    /* Check if list/leaf-list */
    if (yang_path_arg(yspec, xpath?xpath:"/", &ylist) < 0)
        goto done;
    if (ylist == NULL){
        if ((cbmsg = cbuf_new()) == NULL){
            clixon_err(OE_UNIX, errno, "cbuf_new");
            goto done;
        }
        /* error reason should be in clixon_err_reason() */
        cprintf(cbmsg, "Netconf get list-pagination: \"%s\" not found", xpath);
        if (netconf_invalid_value(cbret, "application", cbuf_get(cbmsg)) < 0)
            goto done;
        goto ok;
    }
    if (yang_keyword_get(ylist) != Y_LIST &&
        yang_keyword_get(ylist) != Y_LEAF_LIST){
        if (netconf_invalid_value(cbret, "application", "list-pagination is enabled but target is not list or leaf-list") < 0)
            goto done;
        goto ok;
    }
    /* Sanity checks on state/config */
    if (yang_config_ancestor(ylist) != 0){ /* config list */
        if (content == CONTENT_NONCONFIG){
            if (netconf_invalid_value(cbret, "application", "list-pagination targets a config list but content request is nonconfig") < 0)
                goto done;
            goto ok;
        }
    }
    else { /* state list */
        if (content == CONTENT_CONFIG){
            if (netconf_invalid_value(cbret, "application", "list-pagination targets a state list but content request is config") < 0)
                goto done;
            goto ok;
        }
        clicon_ptr_get(h, "pagination-entries", (void**)&htable);
        if (htable) {
            if ((ret = dispatcher_match_exact(htable, xpath)) < 0)
                goto done;
            if (ret > 0)
                partial_pagination_cb = 1;
        }
    }
    /* first processes the "where" parameter (see Section 3.1.1) */
    if ((x = xml_find_type(xe, NULL, "where", CX_ELMNT)) != NULL &&
        (where = xml_body(x)) != NULL){
        if (strcmp(where, "unfiltered") == 0)
            where = NULL;
        else if (xml_nsctx_node(x, &wherens) < 0)
            goto done;
    }
    /* then the "sort-by" parameter (see Section 3.1.2) */
    if ((x = xml_find_type(xe, NULL, "sort-by", CX_ELMNT)) != NULL){
        sort_by = xml_body(x);
        if (strcmp(sort_by, "none") == 0)
            sort_by = NULL;
    }
    /* then the "direction" parameter (see Section 3.1.4) */
    if ((x = xml_find_type(xe, NULL, "direction", CX_ELMNT)) != NULL &&
        (direction = xml_body(x)) != NULL) {
        if (strcmp(direction, "forwards") != 0 && strcmp(direction, "backwards") != 0){
            if (netconf_bad_attribute(cbret, "application",
                                      "direction", "Unrecognized value of direction attribute") < 0)
                goto done;
            goto ok;
        }
        if (strcmp(direction, "forwards") == 0)
            direction = NULL;
    }
    /* the "offset" parameter (see Section 3.1.5) or
       NYI: the "cursor" parameter (see Section 3.1.6)
       lastly "the "limit" parameter (see Section 3.1.7) */
    if ((ret = list_pagination_hdr(h, xe, &offset, &limit, cbret)) < 0)
        goto done;
    if (ret == 0)
        goto ok;
    /* Read config */
    switch (content){
    case CONTENT_CONFIG:    /* config data only */
    case CONTENT_ALL:       /* both config and state */
        /* Build a "predicate" cbuf */
        if ((ret = xmldb_get0(h, db, YB_MODULE, nsc, xpath?xpath:"/", 1, wdef, &xret, NULL, &xerr)) < 0) {
            if ((cbmsg = cbuf_new()) == NULL){
                clixon_err(OE_UNIX, errno, "cbuf_new");
                goto done;
            }
            cprintf(cbmsg, "Get %s datastore: %s", db, clixon_err_reason());
            if (netconf_operation_failed(cbret, "application", "%s", cbuf_get(cbmsg)) < 0)
                goto done;
            goto ok;
        }
        if (ret == 0){
            if (clixon_xml2cbuf1(cbret, xerr, 0, 0, NULL, -1, 0, 0, WITHDEFAULTS_REPORT_ALL) < 0)
                goto done;
            goto ok;
        }
        break;
    case CONTENT_NONCONFIG: /* state data only */
        if ((xret = xml_new(DATASTORE_TOP_SYMBOL, NULL, CX_ELMNT)) == NULL)/* Only top tree */
            goto done;
        break;
    }/* switch content */
    if (partial_pagination_cb) {
        if ((ret = get_pagination_state_partial(h, ce, yspec, xpath,
                                                where, sort_by, direction,
                                                offset, limit,
                                                xret, cbret)) < 0)
            goto done;
        if (ret == 0)
            goto ok;
    }
    else {
        if (content != CONTENT_CONFIG){
            if ((ret = get_state_data(h, xpath?xpath:"/", nsc, &xret)) < 0)
                goto done;
            if (ret == 0){ /* Error from callback (error in xret) */
                if (clixon_xml2cbuf1(cbret, xret, 0, 0, NULL, -1, 0, 0, WITHDEFAULTS_REPORT_ALL) < 0)
                    goto done;
                goto ok;
            }
            /* Add defaults to state data. This consumes some cycles */
            /* Ensure all state-data is report-all */
            if (xml_global_defaults(h, xret, nsc, xpath, yspec, 1) < 0)
                goto done;
            /* Apply default values */
            if (xml_default_recurse(xret, 1, 0) < 0)
                goto done;
        }
        /* first processes the "where" parameter (see Section 3.1.1) */
        if (where){
            if (xpath_vec(xret, nsc, "%s[%s]", &xvec, &xlen, xpath?xpath:"/", where) < 0)
                goto done;
            for (i=0; i<xlen; i++){
                if ((x = xvec[i]) == NULL)
                    break;
                xml_flag_set(x, XML_FLAG_MARK);
            }
            /* Remove everything that is not marked */
            if (xml_tree_prune_flagged_sub(xret, XML_FLAG_MARK, 1, NULL) < 0)
                goto done;
            if (xml_apply(xret, CX_ELMNT, (xml_applyfn_t*)xml_flag_reset,
                          (void*)XML_FLAG_MARK) < 0)
                goto done;
            if (xvec){
                free(xvec);
                xvec = NULL;
            }
        }
        /* then the "sort-by" parameter (see Section 3.1.2) */
        if (sort_by){
            if ((x = xpath_first(xret, nsc, "%s", xpath?xpath:"/")) != NULL &&
                (xp = xml_parent(x)) != NULL)
                xml_sort_by(xp, sort_by); // XXX sort_by
        }
        /* then the "direction" parameter (see Section 3.1.4), != NULL means backwards */
        if (direction &&
            (x = xpath_first(xret, nsc, "%s", xpath?xpath:"/")) != NULL &&
            (xp = xml_parent(x)) != NULL &&
            (xvec2 = xml_childvec_get(xp)) != NULL){
            j = xml_child_nr(xp);
            for (i=0; i<j; i++){
                x = xvec2[i];
                if (xml_type(x) != CX_ELMNT)
                    continue;
                j--;
                for (; j>i; j--){
                    xj = xvec2[j];
                    if (xml_type(xj) == CX_ELMNT){
                        xvec2[j] = x;
                        xvec2[i] = xj;
                    }
                    break;
                }
            }
        }
        /* the "offset" parameter (see Section 3.1.5)
           lastly "the "limit" parameter (see Section 3.1.7) */
        if (xpath_vec(xret, nsc, "%s", &xvec, &xlen, xpath?xpath:"/") < 0)
            goto done;
        if (limit == 0)
            upper = xlen;
        else{
            if ((upper = offset+limit) > xlen)
                upper = xlen;
        }
        for (i=offset; i<upper; i++){
            if ((x = xvec[i]) == NULL)
                break;
            xml_flag_set(x, XML_FLAG_MARK);
        }
        /* Remove everything that is not marked */
        if (xml_tree_prune_flagged_sub(xret, XML_FLAG_MARK, 1, NULL) < 0)
            goto done;
        /* Clear flags */
        if (xml_apply(xret, CX_ELMNT, (xml_applyfn_t*)xml_flag_reset,
                      (void*)XML_FLAG_MARK) < 0)
            goto done;
        if (xvec){
            free(xvec);
            xvec = NULL;
        }
#ifdef LIST_PAGINATION_REMAINING
        /* Get total/remaining
         */
        if ((xcache = xmldb_cache_get(h, db)) != NULL){
            if (xpath_count(xcache, nsc, xpath, &total) < 0)
                goto done;
            if (total >= (offset + limit))
                remaining = total - (offset + limit);
        }
#endif
    }
    if (xpath_vec(xret, nsc, "%s", &xvec, &xlen, xpath?xpath:"/") < 0)
        goto done;
    /* Help function to filter out anything that is outside of xpath */
    if (filter_xpath_again(h, yspec, xret, xvec, xlen, xpath, nsc) < 0)
        goto done;
#ifdef LIST_PAGINATION_REMAINING
    /* Add remaining attribute Sec 3.1.5:
       Any list or leaf-list that is limited includes, on the first element in the result set,
       a metadata value [RFC7952] called "remaining"*/
    if (limit && x1){
        cxobj *xa;
        cbuf  *cba = NULL;

        /* Add remaining attribute */
        if ((cba = cbuf_new()) == NULL){
            clixon_err(OE_UNIX, errno, "cbuf_new");
            goto done;
        }
        cprintf(cba, "%u", remaining);
        if (xml_add_attr(x1, "remaining", cbuf_get(cba), "cp", "http://clicon.org/clixon-netconf-list-pagination") == NULL)
        goto done;
        if (cba)
            cbuf_free(cba);
    }
#endif /* LIST_PAGINATION_REMAINING */
    if (get_nacm_and_reply(h, xret, xpath, nsc, username, depth, wdef, cbret) < 0)
        goto done;
 ok:
    retval = 0;
 done:
    if (wherens)
        cvec_free(wherens);
    if (xvec)
        free(xvec);
    if (cbmsg)
        cbuf_free(cbmsg);
    if (xerr)
        xml_free(xerr);
    if (xret)
        xml_free(xret);
    return retval;
}

/*! Common get/get-config code for retrieving  configuration and state information.
 *
 * @param[in]  h       Clixon handle
 * @param[in]  ce      Client entry, for locking
 * @param[in]  xe      Request: <rpc><xn></rpc>
 * @param[in]  content Get config/state/both
 * @param[in]  db      Database name
 * @param[out] cbret   Return xml tree, eg <rpc-reply>..., <rpc-error..
 * @retval     0       OK
 * @retval    -1       Error
 * @see from_client_get
 * @see from_client_get_config
 */
static int
get_common(clixon_handle   h,
           client_entry   *ce,
           cxobj          *xe,
           netconf_content content,
           char           *db,
           cbuf           *cbret
           )
{
    int               retval = -1;
    cxobj            *xfilter;
    char             *xpath = NULL;
    cxobj            *xret = NULL;
    char             *username;
    cvec             *nsc0 = NULL; /* Create a netconf namespace context from filter */
    cvec             *nsc = NULL;
    char             *attr;
    int32_t           depth = -1; /* Nr of levels to print, -1 is all, 0 is none */
    yang_stmt        *yspec;
    cxobj            *xerr = NULL;
    char             *reason = NULL;
    cbuf             *cbmsg = NULL; /* For error msg */
    char             *xpath0;
    char             *xpath01 = NULL;
    cbuf             *cbreason = NULL;
    cxobj           **xvec = NULL;
    size_t            xlen;
    cxobj            *xlpg;
    cxobj            *xlpg2 = NULL;
    withdefaults_type wdef;
    char             *wdefstr;
    int               ret;

    clixon_debug(CLIXON_DBG_BACKEND | CLIXON_DBG_DETAIL, "");
    if (db == NULL){
        clixon_err(OE_DB, EINVAL, "db is NULL");
        goto done;
    }
    wdef = WITHDEFAULTS_EXPLICIT;
    username = clicon_username_get(h);
    if ((yspec =  clicon_dbspec_yang(h)) == NULL){
        clixon_err(OE_YANG, ENOENT, "No yang spec9");
        goto done;
    }
    /* filter assumes xpath, if type=subtree is requested, all i retrieved
     * and then the netconf client filters it in netconf_get_config_subtree */
    if ((xfilter = xml_find(xe, "filter")) != NULL){
        if ((xpath0 = xml_find_value(xfilter, "select"))==NULL)
            xpath0 = "/";
        if (xml_chardata_decode(&xpath01, "%s", xpath0) < 0)
            goto done;
        /* Create namespace context for xpath from <filter>
         *  The set of namespace declarations are those in scope on the
         * <filter> element.
         */
        if (xml_nsctx_node(xfilter, &nsc0) < 0)
            goto done;
        if ((ret = xpath2canonical(xpath01, nsc0, yspec, &xpath, &nsc, &cbreason)) < 0)
            goto done;
        if (ret == 0){
            if (netconf_bad_attribute(cbret, "application",
                                      "select", cbuf_get(cbreason)) < 0)
                goto done;
            goto ok;
        }
    }
    /* Clixon extensions: depth */
    if ((attr = xml_find_value(xe, "depth")) != NULL){
        if ((ret = parse_int32(attr, &depth, &reason)) < 0){
            clixon_err(OE_XML, errno, "parse_int32");
            goto done;
        }
        if (ret == 0){
            if (netconf_bad_attribute(cbret, "application",
                                      "depth", "Unrecognized value of depth attribute") < 0)
                goto done;
            goto ok;
        }
    }
    if ((wdefstr = xml_find_body(xe, "with-defaults")) != NULL)
        wdef = withdefaults_str2int(wdefstr);
    /* How to check if list-pagination?
     * Problem is clixon expands messages on entry and pagination default values + non-presence cont
     * Therefore reverse expands by removing  defaults/nopresence and see if it is empty
     * If it is empty, all are default values and is regular get
     */
    if ((xlpg = xml_find_type(xe, NULL, "list-pagination", CX_ELMNT)) != NULL){
        if ((xlpg2 = xml_dup(xlpg)) == NULL)
            goto done;
        if (xml_default_nopresence(xlpg2, 2, 0) < 0)
            goto done;
        if (xml_child_nr_type(xlpg2, CX_ELMNT) != 0) {
            if (get_list_pagination(h, ce,
                                    xlpg,
                                    content, db,
                                    depth, yspec, xpath, nsc, username, wdef,
                                    cbret) < 0)
                goto done;
            goto ok;
        }
    }
    /* Read configuration */
    switch (content){
    case CONTENT_CONFIG:    /* config data only */
        /* specific xpath. with-default gets masked in get_nacm_and_reply */
        if ((ret = xmldb_get0(h, db, YB_MODULE, nsc, xpath?xpath:"/", 1, WITHDEFAULTS_REPORT_ALL, &xret, NULL, &xerr)) < 0) {
            if ((cbmsg = cbuf_new()) == NULL){
                clixon_err(OE_UNIX, errno, "cbuf_new");
                goto done;
            }
            cprintf(cbmsg, "Get %s datastore: %s", db, clixon_err_reason());
            if (netconf_operation_failed(cbret, "application", "%s", cbuf_get(cbmsg)) < 0)
                goto done;
            goto ok;
        }
        if (ret == 0){
            if (clixon_xml2cbuf1(cbret, xerr, 0, 0, NULL, -1, 0, 0, WITHDEFAULTS_REPORT_ALL) < 0)
                goto done;
            goto ok;
        }
        break;
    case CONTENT_ALL:       /* both config and state */
    case CONTENT_NONCONFIG: /* state data only */
        if (clicon_option_bool(h, "CLICON_VALIDATE_STATE_XML")){
            /* Whole config tree, for validate debug */
            if ((ret = xmldb_get0(h, "running", YB_MODULE, nsc, NULL, 1, WITHDEFAULTS_REPORT_ALL, &xret, NULL, &xerr)) < 0) {
                if ((cbmsg = cbuf_new()) == NULL){
                    clixon_err(OE_UNIX, errno, "cbuf_new");
                    goto done;
                }
                cprintf(cbmsg, "Get %s datastore: %s", db, clixon_err_reason());
                if (netconf_operation_failed(cbret, "application", "%s", cbuf_get(cbmsg)) < 0)
                    goto done;
                goto ok;
            }
            if (ret == 0){
                if (clixon_xml2cbuf1(cbret, xerr, 0, 0, NULL, -1, 0, 0, WITHDEFAULTS_REPORT_ALL) < 0)
                    goto done;
                goto ok;
            }
        }
        else if (content == CONTENT_ALL){
            /* specific xpath */
            if ((ret = xmldb_get0(h, db, YB_MODULE, nsc, xpath?xpath:"/", 1, WITHDEFAULTS_REPORT_ALL, &xret, NULL, &xerr)) < 0) {
                if ((cbmsg = cbuf_new()) == NULL){
                    clixon_err(OE_UNIX, errno, "cbuf_new");
                    goto done;
                }
                cprintf(cbmsg, "Get %s datastore: %s", db, clixon_err_reason());
                if (netconf_operation_failed(cbret, "application", "%s", cbuf_get(cbmsg)) < 0)
                    goto done;
                goto ok;
            }
            if (ret == 0){
                if (clixon_xml2cbuf1(cbret, xerr, 0, 0, NULL, -1, 0, 0, WITHDEFAULTS_REPORT_ALL) < 0)
                    goto done;
                goto ok;
            }
        }
        /* CONTENT_NONCONFIG */
        else if ((xret = xml_new(DATASTORE_TOP_SYMBOL, NULL, CX_ELMNT)) == NULL)/* Only top tree */
            goto done;
        break;
    }/* switch content */
    /* If not only config,
     * get state data from plugins as defined by plugin_statedata(), if any
     */
    /* Read state */
    switch (content){
    case CONTENT_CONFIG:    /* config data only */
        break;
    case CONTENT_ALL:       /* both config and state */
    case CONTENT_NONCONFIG: /* state data only */
#if 0 // test_augment_state.sh fails
        if ((ret = merge_state_data(h, xret, yspec, &xerr)) < 0)
            goto done;
        if (ret == 0){ /* Error from callback (error in xret) */
            if (clixon_xml2cbuf1(cbret, xerr, 0, 0, NULL, -1, 0, 0, WITHDEFAULTS_REPORT_ALL) < 0)
                goto done;
            goto ok;
        }
#else
        if ((ret = get_state_data(h, xpath?xpath:"/", nsc, &xret)) < 0)
            goto done;
        if (ret == 0){ /* Error from callback (error in xret) */
            if (clixon_xml2cbuf1(cbret, xret, 0, 0, NULL, -1, 0, 0, WITHDEFAULTS_REPORT_ALL) < 0)
                goto done;
            goto ok;
        }
        /* Add defaults to state data. This consumes some cycles */
        /* Ensure all state-data is report-all */
        if (xml_global_defaults(h, xret, nsc, xpath, yspec, 1) < 0)
            goto done;
        /* Apply default values */
        if (xml_default_recurse(xret, 1, 0) < 0)
            goto done;
#endif
        break;
    }
    if (content != CONTENT_CONFIG &&
        clicon_option_bool(h, "CLICON_VALIDATE_STATE_XML")){
        /* Check XML  by validating it. return internal error with error cause
         * Primarily intended for user-supplied state-data.
         * The whole config tree must be present in case the state data references config data
         */
        if ((ret = xml_yang_validate_all_top(h, xret,
                                             1, /* Validate also state data */
                                             &xerr)) < 0)
            goto done;
        if (ret > 0 &&
            (ret = xml_yang_validate_add(h, xret, &xerr)) < 0)
            goto done;
        if (ret == 0){
            clixon_debug_xml(CLIXON_DBG_BACKEND, xret, "VALIDATE_STATE");
            if (clixon_netconf_internal_error(xerr,
                                              ". Internal error, state callback returned invalid XML",
                                              NULL) < 0)
                goto done;
            if (clixon_xml2cbuf1(cbret, xerr, 0, 0, NULL, -1, 0, 0, WITHDEFAULTS_REPORT_ALL) < 0)
                goto done;
            goto ok;
        }
    } /* CLICON_VALIDATE_STATE_XML */
    if (clicon_option_bool(h, "CLICON_VALIDATE_STATE_XML"))
        if (content == CONTENT_NONCONFIG){ /* state only, all config should be removed now */
            /* Keep state data only, remove everything that is config. Note that state data
             * may be a sub-part in a config tree, we need to traverse to find all
             */
            if (xml_non_config_data(xret, NULL) < 0)
                goto done;
            if (xml_tree_prune_flagged_sub(xret, XML_FLAG_MARK, 1, NULL) < 0)
                goto done;
            if (xml_apply(xret, CX_ELMNT, (xml_applyfn_t*)xml_flag_reset, (void*)XML_FLAG_MARK) < 0)
                goto done;
        }
    if (xpath_vec(xret, nsc, "%s", &xvec, &xlen, xpath?xpath:"/") < 0)
        goto done;
    if (filter_xpath_again(h, yspec, xret, xvec, xlen, xpath, nsc) < 0)
        goto done;
    if (get_nacm_and_reply(h, xret, xpath, nsc, username, depth, wdef, cbret) < 0)
        goto done;
 ok:
    retval = 0;
 done:
    clixon_debug(CLIXON_DBG_BACKEND | CLIXON_DBG_DETAIL, "retval:%d", retval);
    if (xlpg2)
        xml_free(xlpg2);
    if (xvec)
        free(xvec);
    if (xret)
        xml_free(xret);
    if (cbreason)
        cbuf_free(cbreason);
    if (nsc0)
        xml_nsctx_free(nsc0);
    if (nsc)
        xml_nsctx_free(nsc);
    if (cbmsg)
        cbuf_free(cbmsg);
    if (reason)
        free(reason);
    if (xerr)
        xml_free(xerr);
    if (xpath)
        free(xpath);
    if (xpath01)
        free(xpath01);
    return retval;
}

/*! Retrieve all or part of a specified configuration.
 *
 * @param[in]  h       Clixon handle
 * @param[in]  xe      Request: <rpc><xn></rpc>
 * @param[out] cbret   Return xml tree, eg <rpc-reply>..., <rpc-error..
 * @param[in]  arg     client-entry
 * @param[in]  regarg  User argument given at rpc_callback_register()
 * @retval     0       OK
 * @retval    -1       Error
 * @see from_client_get
 */
int
from_client_get_config(clixon_handle h,
                       cxobj        *xe,
                       cbuf         *cbret,
                       void         *arg,
                       void         *regarg)
{
    int           retval = -1;
    client_entry *ce = (client_entry *)arg;
    db_elmnt     *de;
    char         *db;
    int           ret;

    if ((ret = xmldb_netconf_name_find(h, xe, "source", ce, 0, &de, cbret)) < 0)
        goto done;
    if (ret == 0)
        goto ok;
    db = xmldb_name_get(de);
    if (get_common(h, ce, xe, CONTENT_CONFIG, db, cbret) < 0)
        goto done;
 ok:
    retval = 0;
 done:
    return retval;
}

/*! Retrieve running configuration and device state
 *
 * @param[in]  h       Clixon handle
 * @param[in]  xe      Request: <rpc><xn></rpc>
 * @param[out] cbret   Return xml tree, eg <rpc-reply>..., <rpc-error..
 * @param[in]  arg     client-entry
 * @param[in]  regarg  User argument given at rpc_callback_register()
 * @retval     0       OK
 * @retval    -1       Error
 *
 * @see from_client_get_config
 */
int
from_client_get(clixon_handle h,
                cxobj        *xe,
                cbuf         *cbret,
                void         *arg,
                void         *regarg)
{
    netconf_content content = CONTENT_ALL;
    client_entry   *ce = (client_entry *)arg;
    char           *attr;

    /* Clixon extensions: content */
    if ((attr = xml_find_value(xe, "content")) != NULL)
        content = netconf_content_str2int(attr);
    return get_common(h, ce, xe, content, "running", cbret);
}
