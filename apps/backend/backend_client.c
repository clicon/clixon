/*
 *
  ***** BEGIN LICENSE BLOCK *****
 
  Copyright (C) 2009-2016 Olof Hagsand and Benny Holmgren
  Copyright (C) 2017-2019 Olof Hagsand
  Copyright (C) 2020-2021 Olof Hagsand and Rubicon Communications, LLC(Netgate)

  This file is part of CLIXON.

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.

  Alternatively, the contents of this file may be used under the terms of
  the GNU General Public License Version 3 or later (the "GPL"),
  in which case the provisions of the GPL are applicable instead
  of those above. If you wish to allow use of your version of this file only
  under the terms of the GPL, and not to allow others to
  use your version of this file under the terms of Apache License version 2, 
  indicate your decision by deleting the provisions above and replace them with
  the  notice and other provisions required by the GPL. If you do not delete
  the provisions above, a recipient may use your version of this file under
  the terms of any one of the Apache License version 2 or the GPL.

  ***** END LICENSE BLOCK *****

 */

#ifdef HAVE_CONFIG_H
#include "clixon_config.h" /* generated by config & autoconf */
#endif

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdarg.h>
#include <inttypes.h>
#include <errno.h>
#include <signal.h>
#include <fcntl.h>
#include <time.h>
#include <syslog.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <sys/param.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <assert.h>
#include <netinet/in.h>

/* cligen */
#include <cligen/cligen.h>

/* clicon */
#include <clixon/clixon.h>

#include "clixon_backend_handle.h"
#include "clixon_backend_plugin.h"
#include "clixon_backend_commit.h"
#include "backend_client.h"
#include "backend_handle.h"

/*! Find client by session-id 
 * @param[in] ce_list   List of clients
 * @param[in] id        Session id
 */
static struct client_entry *
ce_find_byid(struct client_entry *ce_list,
	     uint32_t            id)
{
    struct client_entry *ce;

    for (ce = ce_list; ce; ce = ce->ce_next)
	if (ce->ce_id == id)
	    return ce;
    return NULL;
}

/*! Stream callback for netconf stream notification (RFC 5277)
 * @param[in]  h     Clicon handle
 * @param[in]  op    0:event, 1:rm
 * @param[in]  event Event as XML
 * @param[in]  arg   Extra argument provided in stream_ss_add
 * @see stream_ss_add
 */
int
ce_event_cb(clicon_handle h,
	    int           op,
	    cxobj        *event,
	    void         *arg)
{
    struct client_entry *ce = (struct client_entry *)arg;
    
    clicon_debug(1, "%s op:%d", __FUNCTION__, op);
    switch (op){
    case 1:
	/* Risk of recursion here */
	if (ce->ce_s)
	    backend_client_rm(h, ce);
	break;
    default:
	if (send_msg_notify_xml(h, ce->ce_s, event) < 0){
	    if (errno == ECONNRESET || errno == EPIPE){
		clicon_log(LOG_WARNING, "client %d reset", ce->ce_nr);
	    }
	    break;
	}
    }
    return 0;
}

/*! Remove client entry state
 * Close down everything wrt clients (eg sockets, subscriptions)
 * Finally actually remove client struct in handle
 * @param[in]  h   Clicon handle
 * @param[in]  ce  Client handle
 * @see backend_client_delete for actual deallocation of client entry struct
 */
int
backend_client_rm(clicon_handle        h, 
		  struct client_entry *ce)
{
    struct client_entry  *c;
    struct client_entry  *c0;
    struct client_entry **ce_prev;

    clicon_debug(1, "%s", __FUNCTION__);
    /* for all streams: XXX better to do it top-level? */
    stream_ss_delete_all(h, ce_event_cb, (void*)ce);
    c0 = backend_client_list(h);
    ce_prev = &c0; /* this points to stack and is not real backpointer */
    for (c = *ce_prev; c; c = c->ce_next){
	if (c == ce){
	    if (ce->ce_s){
		clixon_event_unreg_fd(ce->ce_s, from_client);
		close(ce->ce_s);
		ce->ce_s = 0;
		xmldb_unlock_all(h, ce->ce_id);
	    }
	    break;
	}
	ce_prev = &c->ce_next;
    }
    return backend_client_delete(h, ce); /* actually purge it */
}

/*!
 * Maybe should be in the restconf client instead of backend?
 * @param[in]     h       Clicon handle
 * @param[in]     yspec   Yang spec
 * @param[in]     xpath   Xpath selection, not used but may be to filter early
 * @param[out]    xrs     XML restconf-state node
 * @see netconf_hello_server
 * @see rfc8040 Sections 9.1
 */
static int
client_get_capabilities(clicon_handle h,
			yang_stmt    *yspec,
			char         *xpath,
			cxobj       **xret)
{
    int     retval = -1;
    cxobj  *xrstate = NULL; /* xml restconf-state node */
    cbuf   *cb = NULL;
    
    if ((xrstate = xpath_first(*xret, NULL, "restconf-state")) == NULL){
	clicon_err(OE_YANG, ENOENT, "restconf-state not found in config node");
	goto done;
    }
    if ((cb = cbuf_new()) == NULL){
	clicon_err(OE_UNIX, errno, "cbuf_new");
	goto done;
    }
    cprintf(cb, "<capabilities>");
    cprintf(cb, "<capability>urn:ietf:params:restconf:capability:defaults:1.0?basic-mode=explicit</capability>");
    cprintf(cb, "<capability>urn:ietf:params:restconf:capability:depth:1.0</capability>");
    cprintf(cb, "</capabilities>");
    if (clixon_xml_parse_string(cbuf_get(cb), YB_PARENT, NULL, &xrstate, NULL) < 0)
	goto done;
    retval = 0;
 done:
    if (cb)
	cbuf_free(cb);
    return retval;
}

/*! Get streams state according to RFC 8040 or RFC5277 common function
 * @param[in]     h       Clicon handle
 * @param[in]     yspec   Yang spec
 * @param[in]     xpath   Xpath selection, not used but may be to filter early
 * @param[in]     module  Name of yang module
 * @param[in]     top     Top symbol, ie netconf or restconf-state
 * @param[in,out] xret    Existing XML tree, merge x into this
 * @retval       -1       Error (fatal)
 * @retval        0       Statedata callback failed
 * @retval        1       OK
 */
static int
client_get_streams(clicon_handle   h,
		   yang_stmt      *yspec,
		   char           *xpath,
		   yang_stmt      *ymod,
		   char           *top,
		   cxobj         **xret)
{
    int            retval = -1;
    yang_stmt     *yns = NULL;  /* yang namespace */
    cxobj         *x = NULL;
    cbuf          *cb = NULL;
    int            ret;

    if ((yns = yang_find(ymod, Y_NAMESPACE, NULL)) == NULL){
	clicon_err(OE_YANG, 0, "%s yang namespace not found", yang_argument_get(ymod));
	goto done;
    }
    if ((cb = cbuf_new()) == NULL){
	clicon_err(OE_UNIX, errno, "cbuf_new");
	goto done;
    }
    cprintf(cb, "<%s xmlns=\"%s\">", top, yang_argument_get(yns));
    /* Second argument is a hack to have the same function for the
     * RFC5277 and 8040 stream cases
     */
    if (stream_get_xml(h, strcmp(top,"restconf-state")==0, cb) < 0)
	goto done;
    cprintf(cb,"</%s>", top);

    if (clixon_xml_parse_string(cbuf_get(cb), YB_MODULE, yspec, &x, NULL) < 0){
	if (xret && netconf_operation_failed_xml(xret, "protocol", clicon_err_reason)< 0)
	    goto done;
	goto fail;
    }
    if ((ret = netconf_trymerge(x, yspec, xret)) < 0)
	goto done;
    if (ret == 0)
	goto fail;
    retval = 1;
 done:
    if (cb)
	cbuf_free(cb);
    if (x)
	xml_free(x);
    return retval;
 fail:
    retval = 0;
    goto done;
}

/*! Get clixon per datastore stats
 * @param[in]     h       Clicon handle
 * @param[in]     dbname  Datastore name
 * @param[in,out] cb      Cligen buf
 * @retval        0       OK
 * @retval       -1       Error
 */
static int
clixon_stats_get_db(clicon_handle h,
		    char         *dbname,
		    cbuf         *cb)
{
    int       retval = -1;
    cxobj    *xt = NULL;
    uint64_t  nr = 0;
    size_t    sz = 0;
    
    /* This is the db cache */
    if ((xt = xmldb_cache_get(h, dbname)) == NULL){

	cprintf(cb, "<datastore><name>%s</name><nr>0</nr><size>0</size></datastore>", dbname);
    }
    else{
	if (xml_stats(xt, &nr, &sz) < 0)
	    goto done;
	cprintf(cb, "<datastore><name>%s</name><nr>%" PRIu64 "</nr>"
		"<size>%zu</size></datastore>",
		dbname, nr, sz);
    }
    retval = 0;
 done:
    return retval;
}

/*! Get system state-data, including streams and plugins
 * @param[in]     h       Clicon handle
 * @param[in]     xpath   XPath selection, may be used to filter early
 * @param[in]     nsc     XML Namespace context for xpath
 * @param[in]     content config/state or both
 * @param[in,out] xret    Existing XML tree, merge x into this
 * @retval       -1       Error (fatal)
 * @retval        0       Statedata callback failed (clicon_err called)
 * @retval        1       OK
 */
static int
client_statedata(clicon_handle h,
		 char         *xpath,
		 cvec         *nsc,
		 netconf_content content,
		 cxobj       **xret)
{
    int        retval = -1;
    yang_stmt *yspec;
    yang_stmt *ymod;
    int        ret;
    char      *namespace;
    cbuf      *cb = NULL;
    
    clicon_debug(1, "%s", __FUNCTION__);
    if ((yspec = clicon_dbspec_yang(h)) == NULL){
	clicon_err(OE_YANG, ENOENT, "No yang spec");
	goto done;
    }
    if ((cb = cbuf_new()) == NULL){
	clicon_err(OE_UNIX, errno, "cbuf_new");
	goto done;
    }
    /* Add default state to config if present */
    if (xml_default_recurse(*xret, 1) < 0)
	goto done;
    /* Add default global state */
    if (xml_global_defaults(h, *xret, nsc, xpath, yspec, 1) < 0)
	goto done;

    if (clicon_option_bool(h, "CLICON_STREAM_DISCOVERY_RFC5277")){
	if ((ymod = yang_find_module_by_name(yspec, "clixon-rfc5277")) == NULL){
	    clicon_err(OE_YANG, ENOENT, "yang module clixon-rfc5277 not found");
	    goto done;
	}
	if ((namespace = yang_find_mynamespace(ymod)) == NULL){
	    clicon_err(OE_YANG, ENOENT, "clixon-rfc5277 namespace not found");
	    goto done;
	}
	cprintf(cb, "<netconf xmlns=\"%s\"/>", namespace);
	if (clixon_xml_parse_string(cbuf_get(cb), YB_MODULE, yspec, xret, NULL) < 0)
	    goto done;
	if ((ret = client_get_streams(h, yspec, xpath, ymod, "netconf", xret)) < 0)
	    goto done;
	if (ret == 0)
	    goto fail;
    }
    if (clicon_option_bool(h, "CLICON_STREAM_DISCOVERY_RFC8040")){
	if ((ymod = yang_find_module_by_name(yspec, "ietf-restconf-monitoring")) == NULL){
	    clicon_err(OE_YANG, ENOENT, "yang module ietf-restconf-monitoring not found");
	    goto done;
	}
	if ((namespace = yang_find_mynamespace(ymod)) == NULL){
	    clicon_err(OE_YANG, ENOENT, "ietf-restconf-monitoring namespace not found");
	    goto done;
	}
	cbuf_reset(cb);
	cprintf(cb, "<restconf-state xmlns=\"%s\"/>", namespace);
	if (clixon_xml_parse_string(cbuf_get(cb), YB_MODULE, yspec, xret, NULL) < 0)
	    goto done;
	if ((ret = client_get_streams(h, yspec, xpath, ymod, "restconf-state", xret)) < 0)
	    goto done;
	if (ret == 0)
	    goto fail;
	if ((ret = client_get_capabilities(h, yspec, xpath, xret)) < 0)
	    goto done;
    }
    if (clicon_option_bool(h, "CLICON_MODULE_LIBRARY_RFC7895")){
	if ((ret = yang_modules_state_get(h, yspec, xpath, nsc, 0, xret)) < 0)
	    goto done;
	if (ret == 0)
	    goto fail;
    }
    /* Use plugin state callbacks */
    if ((ret = clixon_plugin_statedata_all(h, yspec, nsc, xpath, xret)) < 0)
	goto done;
    if (ret == 0)
	goto fail;
    retval = 1; /* OK */
 done:
    clicon_debug(1, "%s %d", __FUNCTION__, retval);
    if (cb)
	cbuf_free(cb);
    return retval;
 fail:
    retval = 0;
    goto done;
}

/*! Retrieve all or part of a specified configuration.
 * 
 * Function reused from both from_client_get() and from_client_get_config
 * @param[in]  yspec
 * @param[in]  db
 * @param[in]  xpath
 * @param[in]  username
 * @param[in]  content
 * @param[in]  depth
 * @param[out] cbret   Return xml tree, eg <rpc-reply>..., <rpc-error.. 
 * @retval     0       OK
 * @retval    -1       Error
 * @see from_client_get
 */
static int
client_get_config_only(clicon_handle h,
		       cvec         *nsc,
		       yang_stmt    *yspec,
		       char         *db,
		       char         *xpath,
		       char         *username,
		       int32_t       depth,
		       cbuf         *cbret)
{
    int     retval = -1;
    cxobj  *xret = NULL;
    cxobj  *xnacm = NULL;
    cxobj **xvec = NULL;
    cxobj  *xerr = NULL;
    size_t  xlen;    
    int     ret;

    /* Note xret can be pruned by nacm below (and change name),
     * so zero-copy cant be used
     * Also, must use external namespace context here due to <filter stmt
     */
    if ((ret = xmldb_get0(h, db, YB_MODULE, nsc, xpath, 1, &xret, NULL, &xerr)) < 0) {
	if (netconf_operation_failed(cbret, "application", "read registry")< 0)
	    goto done;
	goto ok;
    }
    if (ret == 0){
	if (clicon_xml2cbuf(cbret, xerr, 0, 0, -1) < 0)
	    goto done;
	goto ok;
    }
    /* Pre-NACM access step */
    xnacm = clicon_nacm_cache(h);
    if (xnacm != NULL){ /* Do NACM validation */
	if (xpath_vec(xret, nsc, "%s", &xvec, &xlen, xpath?xpath:"/") < 0)
	    goto done;
	/* NACM datanode/module read validation */
	if (nacm_datanode_read(h, xret, xvec, xlen, username, xnacm) < 0) 
	    goto done;
    }
    cprintf(cbret, "<rpc-reply xmlns=\"%s\">", NETCONF_BASE_NAMESPACE);
    if (xret==NULL)
	cprintf(cbret, "<data/>");
    else{
	if (xml_name_set(xret, NETCONF_OUTPUT_DATA) < 0)
	    goto done;
	if (clicon_xml2cbuf(cbret, xret, 0, 0, depth>0?depth+1:depth) < 0)
	    goto done;
    }
    cprintf(cbret, "</rpc-reply>");
 ok:
    retval = 0;
 done:
    if (xerr)
	xml_free(xerr);
    if (xvec)
	free(xvec);
    if (xret)
	xml_free(xret);
    return retval;
}

/*! Retrieve all or part of a specified configuration.
 * 
 * @param[in]  h       Clicon handle 
 * @param[in]  xe      Request: <rpc><xn></rpc> 
 * @param[out] cbret   Return xml tree, eg <rpc-reply>..., <rpc-error.. 
 * @param[in]  arg     client-entry
 * @param[in]  regarg  User argument given at rpc_callback_register() 
 * @retval     0       OK
 * @retval    -1       Error
 * @see from_client_get
 */
static int
from_client_get_config(clicon_handle h,
		       cxobj        *xe,
		       cbuf         *cbret,
		       void         *arg,
		       void         *regarg)
{
    int        retval = -1;
    char      *db;
    cxobj     *xfilter;
    char      *xpath = NULL;
    cbuf      *cbx = NULL; /* Assist cbuf */
    int        ret;
    char      *username;
    cvec      *nsc = NULL; /* Create a netconf namespace context from filter */
    yang_stmt *yspec;
    int32_t    depth = -1; /* Nr of levels to print, -1 is all, 0 is none */
    char      *attr;
    char      *xpath0;
    cvec      *nsc1 = NULL;
    
    username = clicon_username_get(h);
    if ((yspec =  clicon_dbspec_yang(h)) == NULL){
	clicon_err(OE_YANG, ENOENT, "No yang spec9");
	goto done;
    }
    if ((db = netconf_db_find(xe, "source")) == NULL){
	clicon_err(OE_XML, 0, "db not found");
	goto done;
    }
    if (xmldb_validate_db(db) < 0){
	if ((cbx = cbuf_new()) == NULL){
	    clicon_err(OE_XML, errno, "cbuf_new");
	    goto done;
	}	
	cprintf(cbx, "No such database: %s", db);
	if (netconf_invalid_value(cbret, "protocol", cbuf_get(cbx))< 0)
	    goto done;
	goto ok;
    }
    /* XXX should use prefix cf edit_config */
    if ((xfilter = xml_find(xe, "filter")) != NULL){
	if ((xpath0 = xml_find_value(xfilter, "select"))==NULL)
	    xpath0="/";
	/* Create namespace context for xpath from <filter>
	 *  The set of namespace declarations are those in scope on the
	 * <filter> element.
	 */
	else
	    if (xml_nsctx_node(xfilter, &nsc) < 0)
		goto done;
	if (xpath2canonical(xpath0, nsc, yspec, &xpath, &nsc1) < 0)
	    goto done;
	if (nsc)
	    xml_nsctx_free(nsc);
	nsc = nsc1;
    }
    /* Clixon extensions: depth */
    if ((attr = xml_find_value(xe, "depth")) != NULL){
	    char *reason = NULL;
	if ((ret = parse_int32(attr, &depth, &reason)) < 0){
	    clicon_err(OE_XML, errno, "parse_int32");
	    goto done;
	}
	if (ret == 0){
	    if (netconf_bad_attribute(cbret, "application",
				      "depth", "Unrecognized value of depth attribute") < 0)
		goto done;
	    goto ok;
	}
    }
    if ((ret = client_get_config_only(h, nsc, yspec, db, xpath, username, -1, cbret)) < 0)
	goto done;
 ok:
    retval = 0;
 done:
    if (xpath)
	free(xpath);
    if (nsc)
	xml_nsctx_free(nsc);
    if (cbx)
	cbuf_free(cbx);
    return retval;
}

/*! Loads all or part of a specified configuration to target configuration
 * 
 * @param[in]  h       Clicon handle 
 * @param[in]  xe      Request: <rpc><xn></rpc> 
 * @param[out] cbret   Return xml tree, eg <rpc-reply>..., <rpc-error.. 
 * @param[in]  arg     client-entry
 * @param[in]  regarg  User argument given at rpc_callback_register() 
 * @retval     0       OK
 * @retval    -1       Error
 */
static int
from_client_edit_config(clicon_handle h,
			cxobj        *xn,
			cbuf         *cbret,
			void         *arg,
			void         *regarg)
{
    int                 retval = -1;
    struct client_entry *ce = (struct client_entry *)arg;
    uint32_t            myid = ce->ce_id;
    uint32_t            iddb;
    char               *target;
    cxobj              *xc;
    cxobj              *x;
    enum operation_type operation = OP_MERGE;
    int                 non_config = 0;
    yang_stmt          *yspec;
    cbuf               *cbx = NULL; /* Assist cbuf */
    int                 ret;
    char               *username;
    cxobj              *xret = NULL;
    char               *attr;
    int                 autocommit = 0;
    char               *val = NULL;
    cvec               *nsc = NULL;
    char               *prefix = NULL;

    username = clicon_username_get(h);
    if ((yspec =  clicon_dbspec_yang(h)) == NULL){
	clicon_err(OE_YANG, ENOENT, "No yang spec9");
	goto done;
    }
    if ((target = netconf_db_find(xn, "target")) == NULL){
	if (netconf_missing_element(cbret, "protocol", "target", NULL) < 0)
	    goto done;
	goto ok;
    }
    if ((cbx = cbuf_new()) == NULL){
	clicon_err(OE_XML, errno, "cbuf_new");
	goto done;
    }	
    if (xmldb_validate_db(target) < 0){
	cprintf(cbx, "No such database: %s", target);
	if (netconf_invalid_value(cbret, "protocol", cbuf_get(cbx))< 0)
	    goto done;
	goto ok;
    }
    /* Check if target locked by other client */
    iddb = xmldb_islocked(h, target);
    if (iddb && myid != iddb){
	cprintf(cbx, "<session-id>%u</session-id>", iddb);
	if (netconf_lock_denied(cbret, cbuf_get(cbx), "Operation failed, lock is already held") < 0)
	    goto done;
	goto ok;
    }
    if (xml_nsctx_node(xn, &nsc) < 0)
	goto done;
    /* Get prefix of netconf base namespace in the incoming message */
    if (xml_nsctx_get_prefix(nsc, NETCONF_BASE_NAMESPACE, &prefix) == 0){
	cprintf(cbx, "No appropriate prefix exists for: %s", NETCONF_BASE_NAMESPACE);
	if (netconf_unknown_namespace(cbret, "protocol", xml_name(xn), cbuf_get(cbx)) < 0)
	    goto done;
	goto ok;
    }
    /* Get default-operation element */
    if ((x = xpath_first(xn, nsc, "%s%sdefault-operation", prefix?prefix:"", prefix?":":"")) != NULL){
	if (xml_operation(xml_body(x), &operation) < 0){
	    if (netconf_invalid_value(cbret, "protocol", "Wrong operation")< 0)
		goto done;
	    goto ok;
	}
    }
    /* Get config element */
    if ((xc = xpath_first(xn, nsc, "%s%s%s",
			  prefix?prefix:"",
			  prefix?":":"",
			  NETCONF_INPUT_CONFIG)) == NULL){
	cprintf(cbx, "Element not found, or mismatching prefix %s for namespace %s",
		prefix?prefix:"null", NETCONF_BASE_NAMESPACE);
	if (netconf_missing_element(cbret, "protocol", NETCONF_INPUT_CONFIG, cbuf_get(cbx)) < 0)
	    goto done;
	goto ok;
    }
    /* <config> yang spec may be set to anyxml by ingress yang check,...*/
    if (xml_spec(xc) != NULL)
	xml_spec_set(xc, NULL);
    /* Populate XML with Yang spec (why not do this in parser?) 
     */
    if ((ret = xml_bind_yang(xc, YB_MODULE, yspec, &xret)) < 0)
	goto done;
    if (ret == 0){
	if (clicon_xml2cbuf(cbret, xret, 0, 0, -1) < 0)
	    goto done;
	goto ok;
    }
    /* (Mark all nodes that are not configure data and) set return */
    if ((ret = xml_non_config_data(xc, &xret)) < 0)
	goto done;
    if (ret == 0){
	if (clicon_xml2cbuf(cbret, xret, 0, 0, -1) < 0)
	    goto done;
	goto ok;
    }
    if (non_config){
	if (netconf_invalid_value(cbret, "protocol", "State data not allowed")< 0)
	    goto done;
	goto ok;
    }
    /* xmldb_put (difflist handling) requires list keys */
    if ((ret = xml_yang_validate_list_key_only(xc, &xret)) < 0)
	goto done;
    if (ret == 0){
	if (clicon_xml2cbuf(cbret, xret, 0, 0, -1) < 0)
	    goto done;
	goto ok;
    }
    /* Cant do this earlier since we dont have a yang spec to
     * the upper part of the tree, until we get the "config" tree.
     */
    if (xml_sort_recurse(xc) < 0)
	goto done;
    if ((ret = xmldb_put(h, target, operation, xc, username, cbret)) < 0){
	clicon_debug(1, "%s ERROR PUT", __FUNCTION__);	
	if (netconf_operation_failed(cbret, "protocol", clicon_err_reason)< 0)
	    goto done;
	goto ok;
    }
    if (ret == 0)
	goto ok;
    xmldb_modified_set(h, target, 1); /* mark as dirty */
    /* Clixon extension: autocommit */
    if ((attr = xml_find_value(xn, "autocommit")) != NULL &&
	strcmp(attr,"true")==0)
	autocommit = 1;
    /* If autocommit option is set or requested by client */
    if (clicon_autocommit(h) || autocommit) {
	if ((ret = candidate_commit(h, "candidate", cbret)) < 0){ /* Assume validation fail, nofatal */
	    if (netconf_operation_failed(cbret, "application", clicon_err_reason)< 0)
		goto done;
	    xmldb_copy(h, "running", "candidate");
	    goto ok;
	}
	if (ret == 0){ /* discard */
	    if (xmldb_copy(h, "running", "candidate") < 0){
		if (netconf_operation_failed(cbret, "application", clicon_err_reason)< 0)
		    goto done;
		goto ok;
	    }
	    goto ok;
	}
    }
    /* Clixon extension: copy */
    if ((attr = xml_find_value(xn, "copystartup")) != NULL &&
	strcmp(attr,"true") == 0){
	if (xmldb_copy(h, "running", "startup") < 0){
	    if (netconf_operation_failed(cbret, "application", clicon_err_reason)< 0)
		goto done;
	    goto ok;
	}
    }
    assert(cbuf_len(cbret) == 0);
    cprintf(cbret, "<rpc-reply xmlns=\"%s\"><ok", NETCONF_BASE_NAMESPACE);
    if (clicon_data_get(h, "objectexisted", &val) == 0)
	cprintf(cbret, " objectexisted=\"%s\"", val);
    cprintf(cbret, "/></rpc-reply>");
 ok:
    retval = 0;
 done:
    if (nsc)
	cvec_free(nsc);
    if (xret)
	xml_free(xret);
    if (cbx)
	cbuf_free(cbx);
    clicon_debug(1, "%s done cbret:%s", __FUNCTION__, cbuf_get(cbret));	
    return retval;
    
} /* from_client_edit_config */

/*! Create or replace an entire config with another complete config db
 * @param[in]  h       Clicon handle 
 * @param[in]  xe      Request: <rpc><xn></rpc> 
 * @param[out] cbret   Return xml tree, eg <rpc-reply>..., <rpc-error.. 
 * @param[in]  arg     client-entry
 * @param[in]  regarg  User argument given at rpc_callback_register() 
 * @retval     0       OK
 * @retval    -1       Error
 * NACM: If source running and target startup --> only exec permission
 * else: 
 * - omit data nodes to which the client does not have read access
 * - access denied if user lacks create/delete/update
 */
static int
from_client_copy_config(clicon_handle h,
			cxobj        *xe,
			cbuf         *cbret,
			void         *arg,
			void         *regarg)
{
    int      retval = -1;
    struct client_entry *ce = (struct client_entry *)arg;
    char    *source;
    char    *target;
    uint32_t iddb;
    uint32_t myid = ce->ce_id;
    cbuf    *cbx = NULL; /* Assist cbuf */
    
    if ((source = netconf_db_find(xe, "source")) == NULL){
	if (netconf_missing_element(cbret, "protocol", "source", NULL) < 0)
	    goto done;
	goto ok;
    }
    if ((cbx = cbuf_new()) == NULL){
	clicon_err(OE_XML, errno, "cbuf_new");
	goto done;
    }	
    if (xmldb_validate_db(source) < 0){
	cprintf(cbx, "No such database: %s", source);
	if (netconf_invalid_value(cbret, "protocol", cbuf_get(cbx))< 0)
	    goto done;
	goto ok;
    }
    if ((target = netconf_db_find(xe, "target")) == NULL){
	if (netconf_missing_element(cbret, "protocol", "target", NULL) < 0)
	    goto done;
	goto ok;
    }
    if (xmldb_validate_db(target) < 0){
	cprintf(cbx, "No such database: %s", target);
	if (netconf_invalid_value(cbret, "protocol", cbuf_get(cbx))< 0)
	    goto done;
	goto ok;
    }
    /* Check if target locked by other client */
    iddb = xmldb_islocked(h, target);
    if (iddb && myid != iddb){
	cprintf(cbx, "<session-id>%u</session-id>", iddb);
	if (netconf_lock_denied(cbret, cbuf_get(cbx), "Copy failed, lock is already held") < 0)
	    goto done;
	goto ok;
    }
    if (xmldb_copy(h, source, target) < 0){
	if (netconf_operation_failed(cbret, "application", clicon_err_reason)< 0)
	    goto done;
	goto ok;
    }
    xmldb_modified_set(h, target, 1); /* mark as dirty */
    cprintf(cbret, "<rpc-reply xmlns=\"%s\"><ok/></rpc-reply>", NETCONF_BASE_NAMESPACE);
 ok:
    retval = 0;
 done:
    if (cbx)
	cbuf_free(cbx);
    return retval;
}

/*! Delete a configuration datastore.
 * @param[in]  h       Clicon handle 
 * @param[in]  xe      Request: <rpc><xn></rpc> 
 * @param[out] cbret   Return xml tree, eg <rpc-reply>..., <rpc-error.. 
 * @param[in]  arg     client-entry
 * @param[in]  regarg  User argument given at rpc_callback_register() 
 * @retval     0       OK
 * @retval    -1       Error
 */
static int
from_client_delete_config(clicon_handle h,
			  cxobj        *xe,
			  cbuf         *cbret,
			  void         *arg, 
			  void         *regarg)
{
    int                  retval = -1;
    struct client_entry *ce = (struct client_entry *)arg;
    char                *target;
    uint32_t             iddb;
    uint32_t             myid = ce->ce_id;
    cbuf                *cbx = NULL; /* Assist cbuf */

    /* XXX should use prefix cf edit_config */
    if ((target = netconf_db_find(xe, "target")) == NULL ||
	strcmp(target, "running")==0){
	if (netconf_missing_element(cbret, "protocol", "target", NULL) < 0)
	    goto done;
	goto ok;
    }
    if ((cbx = cbuf_new()) == NULL){
	clicon_err(OE_XML, errno, "cbuf_new");
	goto done;
    }	
    if (xmldb_validate_db(target) < 0){
	cprintf(cbx, "No such database: %s", target);
	if (netconf_invalid_value(cbret, "protocol", cbuf_get(cbx))< 0)
	    goto done;
	goto ok;
    }
    /* Check if target locked by other client */
    iddb = xmldb_islocked(h, target);
    if (iddb && myid != iddb){
	cprintf(cbx, "<session-id>%u</session-id>", iddb);
	if (netconf_lock_denied(cbret, cbuf_get(cbx), "Operation failed, lock is already held") < 0)
	    goto done;
	goto ok;
    }
    if (xmldb_delete(h, target) < 0){
	if (netconf_operation_failed(cbret, "protocol", clicon_err_reason)< 0)
	    goto done;
	goto ok;
    }
    if (xmldb_create(h, target) < 0){
	if (netconf_operation_failed(cbret, "protocol", clicon_err_reason)< 0)
	    goto done;
	goto ok;
    }
    xmldb_modified_set(h, target, 1); /* mark as dirty */
    cprintf(cbret, "<rpc-reply xmlns=\"%s\"><ok/></rpc-reply>", NETCONF_BASE_NAMESPACE);
 ok:
    retval = 0;
  done:
    if (cbx)
	cbuf_free(cbx);
    return retval;
}

/*! Lock the configuration system of a device
 * 
 * @param[in]  h       Clicon handle 
 * @param[in]  xe      Request: <rpc><xn></rpc> 
 * @param[out] cbret   Return xml tree, eg <rpc-reply>..., <rpc-error.. 
 * @param[in]  arg     client-entry
 * @param[in]  regarg  User argument given at rpc_callback_register() 
 * @retval     0       OK
 * @retval    -1       Error
 */
static int
from_client_lock(clicon_handle h,
		 cxobj        *xe,
		 cbuf         *cbret,
		 void         *arg, 
		 void         *regarg)
{
    int                  retval = -1;
    struct client_entry *ce = (struct client_entry *)arg;
    uint32_t             id = ce->ce_id;
    uint32_t             iddb;
    char                *db;
    cbuf                *cbx = NULL; /* Assist cbuf */
    
    if ((db = netconf_db_find(xe, "target")) == NULL){
	if (netconf_missing_element(cbret, "protocol", "target", NULL) < 0)
	    goto done;
	goto ok;
    }
    if ((cbx = cbuf_new()) == NULL){
	clicon_err(OE_XML, errno, "cbuf_new");
	goto done;
    }	
    if (xmldb_validate_db(db) < 0){
	cprintf(cbx, "No such database: %s", db);
	if (netconf_invalid_value(cbret, "protocol", cbuf_get(cbx))< 0)
	    goto done;
	goto ok;
    }
    /*
     * A lock MUST not be granted if either of the following conditions is true:
     * 1) A lock is already held by any NETCONF session or another entity.
     */
    if ((iddb = xmldb_islocked(h, db)) != 0){
	cprintf(cbx, "<session-id>%u</session-id>", iddb);
	if (netconf_lock_denied(cbret, cbuf_get(cbx), "Operation failed, lock is already held") < 0)
	    goto done;
	goto ok;
    }
    /* 2) The target configuration is <candidate>, it has already been modified, and 
     *    these changes have not been committed or rolled back.
     */
    if (strcmp(db, "candidate") == 0 &&
	xmldb_modified_get(h, db)){
	if (netconf_lock_denied(cbret, "<session-id>0</session-id>",
				"Operation failed, candidate has already been modified and the changes have not been committed or rolled back (RFC 6241 7.5)") < 0)
	    goto done;
	goto ok;
    }
    if (xmldb_lock(h, db, id) < 0)
	goto done;
    cprintf(cbret, "<rpc-reply xmlns=\"%s\"><ok/></rpc-reply>", NETCONF_BASE_NAMESPACE);
 ok:
    retval = 0;
 done:
    if (cbx)
	cbuf_free(cbx);
    return retval;
}

/*! Release a configuration lock previously obtained with the 'lock' operation
 * 
 * @param[in]  h       Clicon handle 
 * @param[in]  xe      Request: <rpc><xn></rpc> 
 * @param[out] cbret   Return xml tree, eg <rpc-reply>..., <rpc-error.. 
 * @param[in]  arg     client-entry
 * @param[in]  regarg  User argument given at rpc_callback_register() 
 * @retval     0       OK
 * @retval    -1       Error
 */
static int
from_client_unlock(clicon_handle h,
		   cxobj        *xe,
		   cbuf         *cbret,
		   void         *arg,
		   void         *regarg)
{
    int                  retval = -1;
    struct client_entry *ce = (struct client_entry *)arg;
    uint32_t             id = ce->ce_id;
    uint32_t             iddb; /* DBs lock, if any */
    char                *db;
    cbuf                *cbx = NULL; /* Assist cbuf */

    if ((db = netconf_db_find(xe, "target")) == NULL){
	if (netconf_missing_element(cbret, "protocol", "target", NULL) < 0)
	    goto done;
	goto ok;
    }
    if ((cbx = cbuf_new()) == NULL){
	clicon_err(OE_XML, errno, "cbuf_new");
	goto done;
    }	
    if (xmldb_validate_db(db) < 0){
	cprintf(cbx, "No such database: %s", db);
	if (netconf_invalid_value(cbret, "protocol", cbuf_get(cbx))< 0)
	    goto done;
	goto ok;
    }
    iddb = xmldb_islocked(h, db);
    /* 
     * An unlock operation will not succeed if any of the following
     * conditions are true:
     * 1) the specified lock is not currently active
     */
    if (iddb == 0){
	cprintf(cbx, "<session-id>0</session-id>");
	if (netconf_lock_denied(cbret, cbuf_get(cbx), "Unlock failed, lock is not currently active") < 0)
	    goto done;
	goto ok;
    }
    /* 2) the session issuing the <unlock> operation is not the same
     *    session that obtained the lock
     */
    else if (iddb != id){
	cprintf(cbx, "<session-id>%u</session-id>", iddb);
	if (netconf_lock_denied(cbret, cbuf_get(cbx), "Unlock failed, lock held by other session") < 0)
	    goto done;
	goto ok;
    }
    else{
	xmldb_unlock(h, db);
	if (cprintf(cbret, "<rpc-reply xmlns=\"%s\"><ok/></rpc-reply>", NETCONF_BASE_NAMESPACE) < 0)
	    goto done;
    }
 ok:
    retval = 0;
 done:
    if (cbx)
	cbuf_free(cbx);
    return retval;
}

/*! Retrieve running configuration and device state information.
 * 
 * @param[in]  h       Clicon handle 
 * @param[in]  xe      Request: <rpc><xn></rpc> 
 * @param[out] cbret   Return xml tree, eg <rpc-reply>..., <rpc-error.. 
 * @param[in]  arg     client-entry
 * @param[in]  regarg  User argument given at rpc_callback_register() 
 * @retval     0       OK
 * @retval    -1       Error
 *
 * @see from_client_get_config 
 */
static int
from_client_get(clicon_handle h,
		cxobj        *xe,
		cbuf         *cbret,
		void         *arg, 
		void         *regarg)
{
    int             retval = -1;
    cxobj          *xfilter;
    char           *xpath = NULL;
    cxobj          *xret = NULL;
    cxobj         **xvec = NULL;
    size_t          xlen;    
    cxobj          *xnacm = NULL;
    char           *username;
    cvec           *nsc = NULL; /* Create a netconf namespace context from filter */
    char           *attr;
    netconf_content content = CONTENT_ALL;
    int32_t         depth = -1; /* Nr of levels to print, -1 is all, 0 is none */
    yang_stmt      *yspec;
    int             i;
    cxobj          *xerr = NULL;
    int             ret;
    char           *reason = NULL;
    
    clicon_debug(1, "%s", __FUNCTION__);
    username = clicon_username_get(h);
    if ((yspec =  clicon_dbspec_yang(h)) == NULL){
	clicon_err(OE_YANG, ENOENT, "No yang spec9");
	goto done;
    }
    if ((xfilter = xml_find(xe, "filter")) != NULL){
	char *xpath0;
	cvec *nsc1 = NULL;
	if ((xpath0 = xml_find_value(xfilter, "select"))==NULL)
	    xpath0 = "/";
	/* Create namespace context for xpath from <filter>
	 *  The set of namespace declarations are those in scope on the
	 * <filter> element.
	 */
	else
	    if (xml_nsctx_node(xfilter, &nsc) < 0)
		goto done;
	if (xpath2canonical(xpath0, nsc, yspec, &xpath, &nsc1) < 0)
	    goto done;
	if (nsc)
	    xml_nsctx_free(nsc);
	nsc = nsc1;
    }
    /* Clixon extensions: content */
    if ((attr = xml_find_value(xe, "content")) != NULL)
	content = netconf_content_str2int(attr);
    /* Clixon extensions: depth */
    if ((attr = xml_find_value(xe, "depth")) != NULL){
	if ((ret = parse_int32(attr, &depth, &reason)) < 0){
	    clicon_err(OE_XML, errno, "parse_int32");
	    goto done;
	}
	if (ret == 0){
	    if (netconf_bad_attribute(cbret, "application",
				      "depth", "Unrecognized value of depth attribute") < 0)
		goto done;
	    goto ok;
	}
    }
    if (content == CONTENT_CONFIG){ /* config only, no state */
	if (client_get_config_only(h, nsc, yspec, "running", xpath, username, depth, cbret) < 0)
	    goto done;
	goto ok;
    }
    /* If not only-state, then read running config 
     * Note xret can be pruned by nacm below and change name and
     * merged with state data, so zero-copy cant be used
     * Also, must use external namespace context here due to <filter> stmt
     */
    if (clicon_option_bool(h, "CLICON_VALIDATE_STATE_XML")){
	if (xmldb_get0(h, "running", YB_MODULE, nsc, NULL, 1, &xret, NULL, NULL) < 0) {
	    if (netconf_operation_failed(cbret, "application", "read registry")< 0)
		goto done;
	    goto ok;
	}
    }
    else{
	if (xmldb_get0(h, "running", YB_MODULE, nsc, xpath, 1, &xret, NULL, NULL) < 0) {
	    if (netconf_operation_failed(cbret, "application", "read registry")< 0)
		goto done;
	    goto ok;
	}
    }
    /* If not only config,
     * get state data from plugins as defined by plugin_statedata(), if any 
     */
    clicon_err_reset();
    if ((ret = client_statedata(h, xpath?xpath:"/", nsc, content, &xret)) < 0)
	goto done;
    if (ret == 0){ /* Error from callback (error in xret) */
	if (clicon_xml2cbuf(cbret, xret, 0, 0, -1) < 0)
	    goto done;
	goto ok;
    }
    if (clicon_option_bool(h, "CLICON_VALIDATE_STATE_XML")){
	/* Check XML  by validating it. return internal error with error cause 
	 * Primarily intended for user-supplied state-data.
	 * The whole config tree must be present in case the state data references config data
	 */
	if ((ret = xml_yang_validate_all_top(h, xret, &xerr)) < 0) 
	    goto done;
	if (ret > 0 &&
	    (ret = xml_yang_validate_add(h, xret, &xerr)) < 0)
	    goto done;
	if (ret == 0){
	    if (clicon_debug_get())
		clicon_log_xml(LOG_DEBUG, xret, "VALIDATE_STATE");
	    if (clixon_netconf_internal_error(xerr,
					      ". Internal error, state callback returned invalid XML",
					      NULL) < 0)
		goto done;
	    if (clicon_xml2cbuf(cbret, xerr, 0, 0, -1) < 0)
		goto done;
	    goto ok;
	}
    } /* CLICON_VALIDATE_STATE_XML */

    if (content == CONTENT_NONCONFIG){ /* state only, all config should be removed now */
	/* Keep state data only, remove everything that is not config. Note that state data
	 * may be a sub-part in a config tree, we need to traverse to find all
	 */
	if (xml_non_config_data(xret, NULL) < 0)
	    goto done;
	if (xml_tree_prune_flagged_sub(xret, XML_FLAG_MARK, 1, NULL) < 0)
	    goto done;
	if (xml_apply(xret, CX_ELMNT, (xml_applyfn_t*)xml_flag_reset, (void*)XML_FLAG_MARK) < 0)
	    goto done;
    }
    /* Code complex to filter out anything that is outside of xpath 
     * Actually this is a safety catch, should really be done in plugins
     * and modules_state functions.
     */
    if (xpath_vec(xret, nsc, "%s", &xvec, &xlen, xpath?xpath:"/") < 0)
	goto done;
    /* If vectors are specified then mark the nodes found and
     * then filter out everything else,
     * otherwise return complete tree.
     */
    if (xvec != NULL){
	for (i=0; i<xlen; i++)
	    xml_flag_set(xvec[i], XML_FLAG_MARK);
    }
    if (xvec){
	free(xvec);
	xvec = NULL;
    }

    /* Remove everything that is not marked */
    if (!xml_flag(xret, XML_FLAG_MARK))
	if (xml_tree_prune_flagged_sub(xret, XML_FLAG_MARK, 1, NULL) < 0)
	    goto done;
    /* reset flag */
    if (xml_apply(xret, CX_ELMNT, (xml_applyfn_t*)xml_flag_reset, (void*)XML_FLAG_MARK) < 0)
	goto done;

    /* Pre-NACM access step */
    xnacm = clicon_nacm_cache(h);
    if (xnacm != NULL){ /* Do NACM validation */
	if (xpath_vec(xret, nsc, "%s", &xvec, &xlen, xpath?xpath:"/") < 0)
	    goto done;
	/* NACM datanode/module read validation */
	if (nacm_datanode_read(h, xret, xvec, xlen, username, xnacm) < 0) 
	    goto done;
    }
    cprintf(cbret, "<rpc-reply xmlns=\"%s\">", NETCONF_BASE_NAMESPACE);     /* OK */
    if (xret==NULL)
	cprintf(cbret, "<data/>");
    else{
	if (xml_name_set(xret, NETCONF_OUTPUT_DATA) < 0)
	    goto done;
	/* Top level is data, so add 1 to depth if significant */
	if (clicon_xml2cbuf(cbret, xret, 0, 0, depth>0?depth+1:depth) < 0)
	    goto done;
    }
    cprintf(cbret, "</rpc-reply>");
 ok:
    retval = 0;
 done:
    clicon_debug(1, "%s retval:%d", __FUNCTION__, retval);
    if (reason)
	free(reason);
    if (xerr)
	xml_free(xerr);
    if (xpath)
	free(xpath);
    if (xvec)
	free(xvec);
    if (nsc)
	xml_nsctx_free(nsc);
    if (xret)
	xml_free(xret);
    return retval;
}

/*! Request graceful termination of a NETCONF session.
 * @param[in]  h       Clicon handle 
 * @param[in]  xe      Request: <rpc><xn></rpc> 
 * @param[out] cbret   Return xml tree, eg <rpc-reply>..., <rpc-error.. 
 * @param[in]  arg     client-entry
 * @param[in]  regarg  User argument given at rpc_callback_register() 
 * @retval     0       OK
 * @retval    -1       Error
 */
static int
from_client_close_session(clicon_handle h,
			 cxobj        *xe,
			 cbuf         *cbret,
			 void         *arg, 
			 void         *regarg)
{
    struct client_entry *ce = (struct client_entry *)arg;
    uint32_t             id = ce->ce_id;

    xmldb_unlock_all(h, id);
    stream_ss_delete_all(h, ce_event_cb, (void*)ce);
    cprintf(cbret, "<rpc-reply xmlns=\"%s\"><ok/></rpc-reply>", NETCONF_BASE_NAMESPACE);
    return 0;
}

/*! Internal message:  Force the termination of a NETCONF session.
 *
 * @param[in]  h       Clicon handle 
 * @param[in]  xe      Request: <rpc><xn></rpc> 
 * @param[out] cbret   Return xml tree, eg <rpc-reply>..., <rpc-error.. 
 * @param[in]  arg     client-entry
 * @param[in]  regarg  User argument given at rpc_callback_register() 
 * @retval     0       OK
 * @retval    -1       Error
 */
static int
from_client_kill_session(clicon_handle h,
			 cxobj        *xe,
			 cbuf         *cbret,
			 void         *arg,
			 void         *regarg)
{
    int                  retval = -1;
    uint32_t             id; /* session id */
    char                *str;
    struct client_entry *ce;
    char                *db = "running"; /* XXX */
    cxobj               *x;
    int                  ret;
    char                *reason = NULL;
    
    if ((x = xml_find(xe, "session-id")) == NULL ||
	(str = xml_find_value(x, "body")) == NULL){
	if (netconf_missing_element(cbret, "protocol", "session-id", NULL) < 0)
	    goto done;
	goto ok;
    }
    if ((ret = parse_uint32(str, &id, &reason)) < 0){
	clicon_err(OE_XML, errno, "parse_uint32"); 
	goto done;
    }
    if (ret == 0){
	if (netconf_bad_element(cbret, "protocol", "session-id", reason) < 0)
	    goto done;
	goto done;
    }
    /* may or may not be in active client list, probably not */
    if ((ce = ce_find_byid(backend_client_list(h), id)) != NULL){
	xmldb_unlock_all(h, id);  /* Removes locks on all databases */
	backend_client_rm(h, ce); /* Removes client struct */
    }
    if (xmldb_islocked(h, db) == id)
	xmldb_unlock(h, db);
    cprintf(cbret, "<rpc-reply xmlns=\"%s\"><ok/></rpc-reply>", NETCONF_BASE_NAMESPACE);
 ok:
    retval = 0;
 done:
    if (reason)
	free(reason);
    return retval;
}

/*! Create a notification subscription
 * @param[in]  h       Clicon handle 
 * @param[in]  xe      Request: <rpc><xn></rpc> 
 * @param[out] cbret   Return xml tree, eg <rpc-reply>..., <rpc-error.. 
 * @param[in]  arg     client-entry
 * @param[in]  regarg  User argument given at rpc_callback_register() 
 * @retval     0       OK
 * @retval    -1       Error
 * @see RFC5277 2.1
 * @example:
 *    <create-subscription> 
 *       <stream>RESULT</stream> # If not present, events in the default NETCONF stream will be sent.
 *       <filter type="xpath" select="XPATH-EXPR"/>
 *       <startTime></startTime>
 *       <stopTime></stopTime>
 *    </create-subscription> 
 */
static int
from_client_create_subscription(clicon_handle h,
				cxobj        *xe,
				cbuf         *cbret,
				void         *arg, 
				void         *regarg)
{
    int                  retval = -1;
    struct client_entry *ce = (struct client_entry *)arg;
    char                *stream = "NETCONF";
    cxobj               *x; /* Generic xml tree */
    cxobj               *xfilter; /* Filter xml tree */
    char                *ftype;
    char                *starttime = NULL;
    char                *stoptime = NULL;
    char                *selector = NULL;
    struct timeval       start;
    struct timeval       stop;
    cvec                *nsc = NULL;
    
    /* XXX should use prefix cf edit_config */
    if ((nsc = xml_nsctx_init(NULL, EVENT_RFC5277_NAMESPACE)) == NULL)
	goto done;
    if ((x = xpath_first(xe, nsc, "//stream")) != NULL)
	stream = xml_find_value(x, "body");
    if ((x = xpath_first(xe, nsc, "//stopTime")) != NULL){
	if ((stoptime = xml_find_value(x, "body")) != NULL &&
	    str2time(stoptime, &stop) < 0){
	    if (netconf_bad_element(cbret, "application", "stopTime", "Expected timestamp") < 0)
		goto done;
	    goto ok;	
	}
    }
    if ((x = xpath_first(xe, nsc, "//startTime")) != NULL){
	if ((starttime = xml_find_value(x, "body")) != NULL &&
	    str2time(starttime, &start) < 0){
	    if (netconf_bad_element(cbret, "application", "startTime", "Expected timestamp") < 0)
		goto done;
	    goto ok;	
	}	
    }
    if ((xfilter = xpath_first(xe, nsc, "//filter")) != NULL){
	if ((ftype = xml_find_value(xfilter, "type")) != NULL){
	    /* Only accept xpath as filter type */
	    if (strcmp(ftype, "xpath") != 0){
		if (netconf_operation_failed(cbret, "application", "Only xpath filter type supported")< 0)
		    goto done;
		goto ok;
	    }
	    if ((selector = xml_find_value(xfilter, "select")) == NULL)
		goto done;
	}
    }
    if ((stream_find(h, stream)) == NULL){
	if (netconf_invalid_value(cbret, "application", "No such stream") < 0)
	    goto done;
	goto ok;
    }
    /* Add subscriber to stream - to make notifications for this client */
    if (stream_ss_add(h, stream, selector,
		      starttime?&start:NULL, stoptime?&stop:NULL,
		      ce_event_cb, (void*)ce) < 0)
	goto done;
    /* Replay of this stream to specific subscription according to start and 
     * stop (if present). 
     * RFC 5277: If <startTime> is not present, this is not a replay
     * subscription.
     * Schedule the replay to occur right after this RPC completes, eg "now"
     */
    if (starttime){ 
	if (stream_replay_trigger(h, stream, ce_event_cb, (void*)ce) < 0)
	    goto done;
    }
    cprintf(cbret, "<rpc-reply xmlns=\"%s\"><ok/></rpc-reply>", NETCONF_BASE_NAMESPACE);
 ok:
    retval = 0;
  done:
    if (nsc)
	xml_nsctx_free(nsc);
    return retval;
}

/*! Set debug level. 
 * @param[in]  h       Clicon handle 
 * @param[in]  xe      Request: <rpc><xn></rpc> 
 * @param[out] cbret   Return xml tree, eg <rpc-reply>..., <rpc-error.. 
 * @param[in]  arg     client-entry
 * @param[in]  regarg  User argument given at rpc_callback_register() 
 * @retval     0       OK
 * @retval    -1       Error
 */
static int
from_client_debug(clicon_handle h,
		  cxobj        *xe,
		  cbuf         *cbret,
		  void         *arg,
		  void         *regarg)
{
    int      retval = -1;
    uint32_t level;
    char    *valstr;
    
    if ((valstr = xml_find_body(xe, "level")) == NULL){
	if (netconf_missing_element(cbret, "application", "level", NULL) < 0)
	    goto done;
	goto ok;
    }
    level = atoi(valstr);

    clicon_debug_init(level, NULL); /* 0: dont debug, 1:debug */
    setlogmask(LOG_UPTO(level?LOG_DEBUG:LOG_INFO)); /* for syslog */
    clicon_log(LOG_NOTICE, "%s debug:%d", __FUNCTION__, clicon_debug_get());
    cprintf(cbret, "<rpc-reply xmlns=\"%s\"><ok/></rpc-reply>", NETCONF_BASE_NAMESPACE);
 ok:
    retval = 0;
 done:
    return retval;
}

/*! Check liveness of backend daemon,  just send a reply
 * @param[in]  h       Clicon handle 
 * @param[in]  xe      Request: <rpc><xn></rpc> 
 * @param[out] cbret   Return xml tree, eg <rpc-reply>..., <rpc-error.. 
 * @param[in]  arg     client-entry
 * @param[in]  regarg  User argument given at rpc_callback_register() 
 * @retval     0       OK
 * @retval    -1       Error
 */
static int
from_client_ping(clicon_handle h,
		 cxobj        *xe,
		 cbuf         *cbret,
		 void         *arg,
		 void         *regarg)
{
    cprintf(cbret, "<rpc-reply xmlns=\"%s\"><ok/></rpc-reply>", NETCONF_BASE_NAMESPACE);
    return 0;
}

/*! Check liveness of backend daemon,  just send a reply
 * @param[in]  h       Clicon handle 
 * @param[in]  xe      Request: <rpc><xn></rpc> 
 * @param[out] cbret   Return xml tree, eg <rpc-reply>..., <rpc-error.. 
 * @param[in]  arg     client-entry
 * @param[in]  regarg  User argument given at rpc_callback_register() 
 * @retval     0       OK
 * @retval    -1       Error
 */
static int
from_client_stats(clicon_handle h,
		  cxobj        *xe,
		  cbuf         *cbret,
		  void         *arg,
		  void         *regarg)
{
    int      retval = -1;
    uint64_t nr;
    
    cprintf(cbret, "<rpc-reply xmlns=\"%s\">", NETCONF_BASE_NAMESPACE);
    nr=0;
    xml_stats_global(&nr);
    cprintf(cbret, "<global><xmlnr>%" PRIu64 "</xmlnr></global>", nr);
    if (clixon_stats_get_db(h, "running", cbret) < 0)
	goto done;
    if (clixon_stats_get_db(h, "candidate", cbret) < 0)
	goto done;
    if (clixon_stats_get_db(h, "startup", cbret) < 0)
	goto done;
    cprintf(cbret, "</rpc-reply>");
    retval = 0;
 done:
    return retval;
}

/*! Request restart of specific plugins
 * @param[in]  h       Clicon handle 
 * @param[in]  xe      Request: <rpc><xn></rpc> 
 * @param[out] cbret   Return xml tree, eg <rpc-reply>..., <rpc-error.. 
 * @param[in]  arg     client-entry
 * @param[in]  regarg  User argument given at rpc_callback_register() 
 * @retval     0       OK
 * @retval    -1       Error
 */
static int
from_client_restart_plugin(clicon_handle h,
			   cxobj        *xe,
			   cbuf         *cbret,
			   void         *arg,
			   void         *regarg)
{
    int            retval = -1;
    char          *name;
    cxobj        **vec = NULL;
    size_t         veclen;
    int            i;
    clixon_plugin_t *cp;
    int            ret;
    
    if (xpath_vec(xe, NULL, "plugin", &vec, &veclen) < 0) 
	goto done;
    for (i=0; i<veclen; i++){
	name = xml_body(vec[i]);
	if ((cp = clixon_plugin_find(h, name)) == NULL){
	    if (netconf_bad_element(cbret, "application", "plugin", "No such plugin") < 0)
		goto done;
	    goto ok;
	}
	if ((ret = from_client_restart_one(h, cp, cbret)) < 0)
	    goto done;
	if (ret == 0)
	    goto ok; /* cbret set */
   }
    cprintf(cbret, "<rpc-reply xmlns=\"%s\"><ok/></rpc-reply>", NETCONF_BASE_NAMESPACE);
 ok:
    retval = 0;
 done:
    if (vec)
	free(vec);
    return retval;
}

/*! Control a specific process or daemon: start/stop, etc
 * @param[in]  h       Clicon handle 
 * @param[in]  xe      Request: <rpc><xn></rpc> 
 * @param[out] cbret   Return xml tree, eg <rpc-reply>..., <rpc-error.. 
 * @param[in]  arg     client-entry
 * @param[in]  regarg  User argument given at rpc_callback_register() 
 * @retval     0       OK
 * @retval    -1       Error
 */
static int
from_client_process_control(clicon_handle  h,
			    cxobj         *xe,
			    cbuf          *cbret,
			    void          *arg,
			    void          *regarg)
{
    int      retval = -1;
    cxobj   *x;
    char    *name = NULL;
    char    *opstr = NULL;
    proc_operation op = PROC_OP_NONE;
    
    if ((x = xml_find_type(xe, NULL, "name", CX_ELMNT)) != NULL)
	name = xml_body(x);
    if ((x = xml_find_type(xe, NULL, "operation", CX_ELMNT)) != NULL){
	opstr = xml_body(x);
	op = clixon_process_op_str2int(opstr);
    }
    /* Make the actual process operation (with wrap function enabled) */
    if (op == PROC_OP_STATUS){
	if (clixon_process_status(h, name, cbret) < 0)
	    goto done;
    }
    else{
	if (clixon_process_operation(h, name, op, 1) < 0)
	    goto done;
	cprintf(cbret, "<rpc-reply xmlns=\"%s\"><ok xmlns=\"%s\"/></rpc-reply>",
		NETCONF_BASE_NAMESPACE, CLIXON_LIB_NS);
    }
    retval = 0;
 done:
    return retval;
}

/*! Clixon hello to check liveness
 * @retval     0       OK
 * @retval    -1       Error
 */
static int
from_client_hello(clicon_handle       h,
		  cxobj               *x,
		  struct client_entry *ce,
		  cbuf                *cbret)
{
    int      retval = -1;
    uint32_t id;
    char    *msgid;

    if (clicon_session_id_get(h, &id) < 0){
	clicon_err(OE_NETCONF, ENOENT, "session_id not set");
	goto done;
    }
    id++;
    clicon_session_id_set(h, id);
    if ((msgid = xml_find_value(x, "message-id")) != NULL)
	cprintf(cbret, "<hello xmlns=\"%s\" message-id=\"%s\"><session-id>%u</session-id></hello>",
		NETCONF_BASE_NAMESPACE, msgid, id);
    else
	cprintf(cbret, "<hello xmlns=\"%s\"><session-id>%u</session-id></hello>",
		NETCONF_BASE_NAMESPACE, id);
    retval = 0;
 done:
    return retval;
}

/*! An internal clicon message has arrived from a client. Receive and dispatch.
 * @param[in]   h    Clicon handle
 * @param[in]   s    Socket where message arrived. read from this.
 * @param[in]   arg  Client entry (from).
 * @retval      0    OK
 * @retval      -1   Error Terminates backend and is never called). Instead errors are
 *                   propagated back to client.
 */
static int
from_client_msg(clicon_handle        h,
		struct client_entry *ce, 
		struct clicon_msg   *msg)
{
    int                  retval = -1;
    cxobj               *xt = NULL;
    cxobj               *x;
    cxobj               *xe;
    char                *rpc = NULL;
    char                *module = NULL;
    cbuf                *cbret = NULL; /* return message */
    int                  ret;
    char                *username;
    yang_stmt           *yspec;
    yang_stmt           *ye;
    yang_stmt           *ymod;
    cxobj               *xnacm = NULL;
    cxobj               *xret = NULL;
    uint32_t             id;
    enum nacm_credentials_t creds;
    char                *rpcname;
    char                *rpcprefix;
    char                *namespace = NULL;
    
    clicon_debug(1, "%s", __FUNCTION__);
    yspec = clicon_dbspec_yang(h); 
    /* Return netconf message. Should be filled in by the dispatch(sub) functions 
     * as wither rpc-error or by positive response.
     */
    if ((cbret = cbuf_new()) == NULL){
	clicon_err(OE_XML, errno, "cbuf_new");
	goto done;
    }
    /* Decode msg from client -> xml top (ct) and session id */
    if ((ret = clicon_msg_decode(msg, yspec, &id, &xt, &xret)) < 0){
	if (netconf_malformed_message(cbret, "XML parse error") < 0)
	    goto done;
	goto reply;
    }
    if (ret == 0){
	if (clicon_xml2cbuf(cbret, xret, 0, 0, -1) < 0)
	    goto done;
	goto reply;
    }
    /* Check for empty frame (no mesaages), return empty message, not clear from RFC what to do */
    if (xml_child_nr_type(xt, CX_ELMNT) == 0){
	if (netconf_malformed_message(cbret, "Empty message in netconf rpc frame")< 0)
	    goto done;
	goto reply;
    }
    /* Check for multi-messages in frame */
    if (xml_child_nr_type(xt, CX_ELMNT) != 1){
	if (netconf_malformed_message(cbret, "More than one message in netconf rpc frame")< 0)
	    goto done;
	goto reply;
    }
    if ((x = xml_child_i_type(xt, 0, CX_ELMNT)) == NULL){ /* Shouldnt happen */
	clicon_err(OE_XML, EFAULT, "No xml req (shouldnt happen)");
	goto done;
    }
    rpcname = xml_name(x);
    rpcprefix = xml_prefix(x);
    /* Note that this validation is also made in xml_yang_validate_rpc, but not for hello
     */
    if (xml2ns(x, rpcprefix, &namespace) < 0)
	goto done;
    /* Only accept resolved NETCONF base namespace */
    if (namespace == NULL){
	if (netconf_bad_element(cbret, "protocol", rpcname, "No namespace associated with prefix") < 0)
	    goto done;
	goto reply;
    }
    else if (strcmp(namespace, NETCONF_BASE_NAMESPACE) != 0){
	cbuf *cbmsg = NULL;
	if ((cbmsg = cbuf_new()) == NULL){
	    clicon_err(OE_UNIX, errno, "cbuf_new");
	    goto done;
	}
	cprintf(cbmsg, "No appropriate namespace found for: %s %s", rpcprefix, rpcname);
	if (netconf_unknown_namespace(cbret, "protocol", namespace, cbuf_get(cbmsg)) < 0)
	    goto done;
	cbuf_free(cbmsg);
	goto reply;
    }

    if (strcmp(rpcname, "rpc") == 0){
	; /* continue  below */
    }
    else if (strcmp(rpcname, "hello") == 0){
	if ((ret = from_client_hello(h, x, ce, cbret)) <0)
	    goto done;
	goto reply;
    }
    else{
	if (netconf_unknown_element(cbret, "protocol", rpcname, "Unrecognized netconf operation")< 0)
	    goto done;
	goto reply;
    }
    ce->ce_id = id;
    if ((ret = xml_yang_validate_rpc(h, x, &xret)) < 0)
	goto done;
    if (ret == 0){
	if (clicon_xml2cbuf(cbret, xret, 0, 0, -1) < 0)
	    goto done;
	goto reply;
    }
    xe = NULL;
    username = xml_find_value(x, "username");
    /* May be used by callbacks, etc */
    clicon_username_set(h, username);
    while ((xe = xml_child_each(x, xe, CX_ELMNT)) != NULL) {
	rpc = xml_name(xe);
	if ((ye = xml_spec(xe)) == NULL){
	    if (netconf_operation_not_supported(cbret, "protocol", rpc) < 0)
		goto done;
	    goto reply;
	}
	if ((ymod = ys_module(ye)) == NULL){
	    clicon_err(OE_XML, ENOENT, "rpc yang does not have module");
	    goto done;
	}
	module = yang_argument_get(ymod);
	clicon_debug(1, "%s module:%s rpc:%s", __FUNCTION__, module, rpc);
	/* Pre-NACM access step */
	xnacm = NULL;

	/* NACM intial pre- access control enforcements. Retval:
	 * 0: Use NACM validation and xnacm is set.
	 * 1: Permit, skip NACM
	 * Therefore, xnacm=NULL means no NACM checks needed.
	 */
	if ((ret = nacm_access_pre(h, ce->ce_username, username, &xnacm)) < 0)
	    goto done;
	/* Cache XML NACM tree here. Use with caution, only valid on from_client_msg stack 
	 */
	if (clicon_nacm_cache_set(h, xnacm) < 0)
	    goto done;
	if (ret == 0){ /* Do NACM RPC validation */
	    creds = clicon_nacm_credentials(h);
	    if ((ret = verify_nacm_user(h, creds, ce->ce_username, username, cbret)) < 0)
		goto done;
	    if (ret == 0) /* credentials fail */
		goto reply;
	    /* NACM rpc operation exec validation */
	    if ((ret = nacm_rpc(rpc, module, username, xnacm, cbret)) < 0)
		goto done;
	    if (ret == 0) /* Not permitted and cbret set */
		goto reply;
	}
	clicon_err_reset();
	if ((ret = rpc_callback_call(h, xe, cbret, ce)) < 0){
	    if (netconf_operation_failed(cbret, "application", clicon_err_reason)< 0)
		goto done;
	    clicon_log(LOG_NOTICE, "%s Error in rpc_callback_call:%s", __FUNCTION__, xml_name(xe));
	    goto reply; /* Dont quit here on user callbacks */
	}
	if (ret == 0){ /* not handled by callback */
	    if (netconf_operation_not_supported(cbret, "application", "RPC operation not supported")< 0)
		goto done;
	    goto reply;
	}
	if (xnacm){
	    xml_free(xnacm);
	    xnacm = NULL;
	    if (clicon_nacm_cache_set(h, NULL) < 0)
		goto done;
	}
    } /* while */
 reply:
    if (cbuf_len(cbret) == 0)
	if (netconf_operation_failed(cbret, "application", clicon_errno?clicon_err_reason:"unknown")< 0)
	    goto done;
    clicon_debug(1, "%s cbret:%s", __FUNCTION__, cbuf_get(cbret));
    /* XXX problem here is that cbret has not been parsed so may contain 
       parse errors */
    if (send_msg_reply(ce->ce_s, cbuf_get(cbret), cbuf_len(cbret)+1) < 0){
	switch (errno){
	case EPIPE:
	    /* man (2) write: 
	     * EPIPE  fd is connected to a pipe or socket whose reading end is 
	     * closed.  When this happens the writing process will also receive 
	     * a SIGPIPE signal. 
	     * In Clixon this means a client, eg restconf, netconf or cli closes
	     * the (UNIX domain) socket.
	     */
	case ECONNRESET:
	    clicon_log(LOG_WARNING, "client rpc reset");
	    break;
	default:
	    goto done;
	}
    }
    // ok:
    retval = 0;
  done:  
    clicon_debug(1, "%s retval:%d", __FUNCTION__, retval);
    if (xnacm){
	xml_free(xnacm);
	if (clicon_nacm_cache_set(h, NULL) < 0)
	    goto done;
    }
    if (xret)
	xml_free(xret);
    if (xt)
	xml_free(xt);
    if (cbret)
	cbuf_free(cbret);
    /* Sanity: log if clicon_err() is not called ! */
    if (retval < 0 && clicon_errno < 0) 
	clicon_log(LOG_NOTICE, "%s: Internal error: No clicon_err call on RPC error (message: %s)",
		   __FUNCTION__, rpc?rpc:"");
    //    clicon_debug(1, "%s retval:%d", __FUNCTION__, retval);
    return retval;// -1 here terminates backend
}

/*! An internal clicon message has arrived from a client. Receive and dispatch.
 * @param[in]   s    Socket where message arrived. read from this.
 * @param[in]   arg  Client entry (from).
 * @retval      0    OK
 * @retval      -1   Error Terminates backend and is never called). Instead errors are
 *                   propagated back to client.
 */
int
from_client(int   s, 
	    void* arg)
{
    int                  retval = -1;
    struct clicon_msg   *msg = NULL;
    struct client_entry *ce = (struct client_entry *)arg;
    clicon_handle        h = ce->ce_handle;
    int                  eof = 0;

    clicon_debug(1, "%s", __FUNCTION__);
    // assert(s == ce->ce_s);
    if (clicon_msg_rcv(ce->ce_s, &msg, &eof) < 0)
	goto done;
    if (eof)
	backend_client_rm(h, ce); 
    else
	if (from_client_msg(h, ce, msg) < 0)
	    goto done;
    retval = 0;
  done:
    clicon_debug(1, "%s retval=%d", __FUNCTION__, retval);
    if (msg)
	free(msg);
    return retval; /* -1 here terminates backend */
}

/*! Init backend rpc: Set up standard netconf rpc callbacks
 * @param[in]  h     Clicon handle
 * @retval       -1       Error (fatal)
 * @retval        0       OK
 * @see ietf-netconf@2011-06-01.yang 
 */
int
backend_rpc_init(clicon_handle h)
{
    int retval = -1;

    /* In backend_client.? RFC 6241 */
    if (rpc_callback_register(h, from_client_get_config, NULL,
		      NETCONF_BASE_NAMESPACE, "get-config") < 0)
	goto done;
    if (rpc_callback_register(h, from_client_edit_config, NULL,
		      NETCONF_BASE_NAMESPACE, "edit-config") < 0)
	goto done;
    if (rpc_callback_register(h, from_client_copy_config, NULL,
		      NETCONF_BASE_NAMESPACE, "copy-config") < 0)
	goto done;
    if (rpc_callback_register(h, from_client_delete_config, NULL,
		      NETCONF_BASE_NAMESPACE, "delete-config") < 0)
	goto done;
    if (rpc_callback_register(h, from_client_lock, NULL,
		      NETCONF_BASE_NAMESPACE, "lock") < 0)
	goto done;
    if (rpc_callback_register(h, from_client_unlock, NULL,
		      NETCONF_BASE_NAMESPACE, "unlock") < 0)
	goto done;
    if (rpc_callback_register(h, from_client_get, NULL,
		      NETCONF_BASE_NAMESPACE, "get") < 0)
	goto done;
    if (rpc_callback_register(h, from_client_close_session, NULL,
		      NETCONF_BASE_NAMESPACE, "close-session") < 0)
	goto done;
    if (rpc_callback_register(h, from_client_kill_session, NULL,
		      NETCONF_BASE_NAMESPACE, "kill-session") < 0)
	goto done;
    /* In backend_commit.? */
    if (rpc_callback_register(h, from_client_commit, NULL,
		      NETCONF_BASE_NAMESPACE, "commit") < 0)
	goto done;
    if (rpc_callback_register(h, from_client_discard_changes, NULL,
		      NETCONF_BASE_NAMESPACE, "discard-changes") < 0)
	goto done;
    /* if-feature confirmed-commit */
    if (rpc_callback_register(h, from_client_cancel_commit, NULL,
		      NETCONF_BASE_NAMESPACE, "cancel-commit") < 0)
	goto done;
    /* if-feature validate */
    if (rpc_callback_register(h, from_client_validate, NULL,
		      NETCONF_BASE_NAMESPACE, "validate") < 0)
	goto done;

    /* In backend_client.? RPC from RFC 5277 */
    if (rpc_callback_register(h, from_client_create_subscription, NULL,
		      EVENT_RFC5277_NAMESPACE, "create-subscription") < 0)
	goto done;
    /* Clixon RPC */
    if (rpc_callback_register(h, from_client_debug, NULL,
			      CLIXON_LIB_NS, "debug") < 0)
	goto done;
    if (rpc_callback_register(h, from_client_ping, NULL,
			      CLIXON_LIB_NS, "ping") < 0)
	goto done;
    if (rpc_callback_register(h, from_client_stats, NULL,
			      CLIXON_LIB_NS, "stats") < 0)
	goto done;
    if (rpc_callback_register(h, from_client_restart_plugin, NULL,
			      CLIXON_LIB_NS, "restart-plugin") < 0)
	goto done;
    if (rpc_callback_register(h, from_client_process_control, NULL,
			      CLIXON_LIB_NS, "process-control") < 0)
	goto done;
    retval =0;
 done:
    return retval;
}
