/*
 *
  ***** BEGIN LICENSE BLOCK *****
 
  Copyright (C) 2009-2016 Olof Hagsand and Benny Holmgren
  Copyright (C) 2017-2019 Olof Hagsand
  Copyright (C) 2020-2022 Olof Hagsand and Rubicon Communications, LLC (Netgate)

  This file is part of CLIXON.

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.

  Alternatively, the contents of this file may be used under the terms of
  the GNU General Public License Version 3 or later (the "GPL"),
  in which case the provisions of the GPL are applicable instead
  of those above. If you wish to allow use of your version of this file only
  under the terms of the GPL, and not to allow others to
  use your version of this file under the terms of Apache License version 2, 
  indicate your decision by deleting the provisions above and replace them with
  the  notice and other provisions required by the GPL. If you do not delete
  the provisions above, a recipient may use your version of this file under
  the terms of any one of the Apache License version 2 or the GPL.

  ***** END LICENSE BLOCK *****

  * Actually  HTTP2 + OPENSSL client integrated with clixon events
  * Ubuntu package:
  *    apt install libnghttp2-dev
  * Example run: clixon_util_ssl -H nghttp2.org
 */

#ifdef HAVE_CONFIG_H
#include "clixon_config.h" /* generated by config & autoconf */
#endif

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <syslog.h>
#include <signal.h>
#include <netdb.h>      /* gethostbyname */
#include <arpa/inet.h>  /* inet_pton */
#include <netinet/tcp.h> /* TCP_NODELAY */

#include <openssl/ssl.h>

/* cligen */
#include <cligen/cligen.h>

/* clixon */
#include "clixon/clixon.h"

#define UTIL_TLS_OPTS "hD:f:d:p:c:k:"

/*! XXX work in progress */
#define TLS_CERTDIR "/home/olof/tmp/certs"

/* User data handle to nghttp2 lib */
typedef struct {
    int              sd_s;
    SSL             *sd_ssl;
} session_data;

static int
socket_connect_inet(char              *hostname,
		    uint16_t           port,
		    int               *sock0)
{
    int                retval = -1;
    int                s = -1;
    struct sockaddr_in addr;
    int                ret;
    struct hostent    *host;
    int                one = 1;

    clicon_debug(1, "%s to %s:%hu", __FUNCTION__, hostname, port);
    memset(&addr, 0, sizeof(addr));
    addr.sin_family = AF_INET;
    addr.sin_port = htons(port);
    if ((ret = inet_pton(addr.sin_family, hostname, &addr.sin_addr)) < 0){
	clicon_err(OE_UNIX, errno, "inet_pton");
	goto done;
    }
    if (ret == 0){ /* Try DNS NOTE OBSOLETE */
	if ((host = gethostbyname(hostname)) == NULL){
	    clicon_err(OE_UNIX, errno, "gethostbyname");
	    goto done;
	}
	addr.sin_addr.s_addr = *(long*)(host->h_addr); /* XXX Just to get it to work */
    }
    /* special error handling to get understandable messages (otherwise ENOENT) */
    if ((s = socket(addr.sin_family, SOCK_STREAM, 0)) < 0) {
	clicon_err(OE_CFG, errno, "socket");
	return -1;
    }
    if (connect(s, (struct sockaddr*)&addr, sizeof(addr)) < 0){
	clicon_err(OE_CFG, errno, "connecting socket inet4");
	close(s);
	goto done;
    }
    /* libev requires this */
    setsockopt(s, IPPROTO_TCP, TCP_NODELAY, (char *)&one, sizeof(one));
    if (sock0 != NULL)
	*sock0 = s;
    retval = 0;
  done:
    if (sock0 == NULL && s >= 0)
	close(s);
    return retval;
}

static int
ssl_input_cb(int   s, 
	     void *arg)
{
    int           retval = -1;
    session_data *sd = (session_data *)arg;
    SSL          *ssl;
    char          buf[1024];
    int           n;
    //    int           readlen;
    
    ssl = sd->sd_ssl;
    /* get reply & decrypt */
    if ((n = SSL_read(ssl, buf, sizeof(buf))) < 0){
	clicon_err(OE_XML, errno, "SSL_read");
	goto done;
    }
    if (n == 0){
	fprintf(stdout, "%s closed\n", __FUNCTION__);
	goto done;
    }
    //XXX
#if 0
    buf[n] = 0;
    fprintf(stdout, "%s\n", buf);
#endif
    retval = 0;
 done:
    return retval;
}

/*! Verify tls auth
 * @see  tlsauth_verify_callback
 */
static int
tlsauth_verify_callback(int preverify_ok, X509_STORE_CTX *x509_ctx)
{
    return 1; /* success */
}

static int
usage(char *argv0)
{
    fprintf(stderr, "usage:%s [options]\n"
	    "where options are\n"
            "\t-h \t\tHelp\n"
    	    "\t-D <level> \tDebug\n"
	    "\t-f <file> \tNetconf input file (overrides stdin)\n"
	    "\t-d <dest> \tIP destination\n"
	    "\t-p <port> \tport\n"
	    "\t-c <path> \tcert\n"
   	    "\t-k <path> \tkey\n"
	    ,
	    argv0);
    exit(0);
}

int
main(int    argc,
     char **argv)
{
    int           retval = -1;
    clicon_handle h;
    int           c;
    char         *hostname = NULL;
    uint16_t      port = 443;
    SSL_CTX      *ctx = NULL;
    int           ss = -1;
    SSL          *ssl;
    int           ret;
    int           dbg = 0;
    session_data *sd = NULL;
    int           sslerr;
    int           verify;
    char         *input_filename = NULL;
    char         *cert_path = TLS_CERTDIR "/andy.crt";
    char         *key_path = TLS_CERTDIR "/andy.key";
    FILE         *fp = stdin; /* base file, stdin, can be overridden with -f */

    /* In the startup, logs to stderr & debug flag set later */
    clicon_log_init(__FILE__, LOG_INFO, CLICON_LOG_STDERR); 

    if ((h = clicon_handle_init()) == NULL)
	goto done;
    while ((c = getopt(argc, argv, UTIL_TLS_OPTS)) != -1)
	switch (c) {
	case 'h':
	    usage(argv[0]);
	    break;
    	case 'D':
	    if (sscanf(optarg, "%d", &dbg) != 1)
		usage(argv[0]);
	    break;
	case 'f':
	    if (optarg == NULL || *optarg == '-')
		usage(argv[0]);
	    input_filename = optarg;
	    break;
	case 'd': /* hostname */
	    hostname = optarg;
	    break;
	case 'p':
	    if (sscanf(optarg, "%hu", &port) != 1)
		usage(argv[0]);
	    break;
	case 'c':
	    if (optarg == NULL || *optarg == '-')
		usage(argv[0]);
	    cert_path = optarg;
	    break;
	case 'k':
	    if (optarg == NULL || *optarg == '-')
		usage(argv[0]);
	    key_path = optarg;
	    break;
	default:
	    usage(argv[0]);
	    break;
	}
    if (hostname == NULL){
	fprintf(stderr, "-d <hostname> is mandatory\n");
	usage(argv[0]);
    }
    if (cert_path == NULL || key_path == NULL){
	fprintf(stderr, "-c <cert path> and -k <key path> are mandatory\n");
	usage(argv[0]);
    }
    clicon_debug_init(dbg, NULL);

    if (input_filename){
	if ((fp = fopen(input_filename, "r")) == NULL){
	    clicon_err(OE_YANG, errno, "open(%s)", input_filename);	
	    goto done;
	}
    }
    if ((ctx = SSL_CTX_new(TLS_client_method())) == NULL) {
	clicon_err(OE_SSL, 0, "SSL_CTX_new");
	goto done;
    }
    SSL_CTX_set_verify(ctx, SSL_VERIFY_PEER, tlsauth_verify_callback);

    /* get peer certificate 
       nc_client_tls_update_opts */
    if (SSL_CTX_use_certificate_file(ctx, cert_path, SSL_FILETYPE_PEM) != 1) {
	clicon_err(OE_SSL, 0, "SSL_CTX_use_certificate_file");
	goto done;
    }
    if (SSL_CTX_use_PrivateKey_file(ctx, key_path, SSL_FILETYPE_PEM) != 1) {
	clicon_err(OE_SSL, 0, "SSL_CTX_use_PrivateKey_file");
	goto done;
    }
    if (0 && !SSL_CTX_load_verify_locations(ctx, NULL, TLS_CERTDIR)) {
	clicon_err(OE_SSL, 0, "SSL_CTX_load_verify_locations");
	goto done;
    }

    if (socket_connect_inet(hostname, port, &ss) < 0)
	goto done;
    ssl = SSL_new(ctx);     /* create new SSL connection state */
    SSL_set_fd(ssl, ss);    /* attach the socket descriptor */
    SSL_set_mode(ssl, SSL_MODE_AUTO_RETRY);
    if (!SSL_set1_host(ssl, hostname)) {
	clicon_err(OE_SSL, 0, "Failed to set expected server hostname.");
        goto done;
    }
    /* perform the connection */
    if ((ret = SSL_connect(ssl)) < 1){
	sslerr = SSL_get_error(ssl, ret);
	clicon_debug(1, "%s SSL_read() n:%d errno:%d sslerr:%d", __FUNCTION__, ret, errno, sslerr);

	switch (sslerr){
	case SSL_ERROR_SSL:                  /* 1 */
	    goto done;
	    break;
	default:
	    clicon_err(OE_XML, errno, "SSL_connect");
	    goto done;
	    break;
	}
    }
    /* check certificate verification result */
    verify = SSL_get_verify_result(ssl);
    switch (verify) {
    case X509_V_OK:
	break;
    default:
	clicon_err(OE_SSL, errno, "verify problems: %d", verify);
	goto done;
    }
    if ((sd = malloc(sizeof(*sd))) == NULL){
	clicon_err(OE_UNIX, errno, "malloc");
	goto done;
    }
    memset(sd, 0, sizeof(*sd));
    sd->sd_s = ss;
    sd->sd_ssl = ssl;
    if ((ret = SSL_write(ssl, "foo", 4)) < 1){
	sslerr = SSL_get_error(ssl, ret);
	clicon_debug(1, "%s SSL_read() n:%d errno:%d sslerr:%d", __FUNCTION__, ret, errno, sslerr);	
    }
    if (clixon_event_reg_fd(ss, ssl_input_cb, sd, "ssl socket") < 0)
	goto done;
    if (clixon_event_loop(h) < 0)
	goto done;
    retval = 0;
 done:
    if (ss != -1)
	close(ss);
    if (ctx)
	SSL_CTX_free(ctx);        /* release context */
    return retval;
}


