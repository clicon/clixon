/*
 *
  ***** BEGIN LICENSE BLOCK *****

  Copyright (C) 2025 Olof Hagsand

  This file is part of CLIXON.

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.

  Alternatively, the contents of this file may be used under the terms of
  the GNU General Public License Version 3 or later (the "GPL"),
  in which case the provisions of the GPL are applicable instead
  of those above. If you wish to allow use of your version of this file only
  under the terms of the GPL, and not to allow others to
  use your version of this file under the terms of Apache License version 2,
  indicate your decision by deleting the provisions above and replace them with
  the  notice and other provisions required by the GPL. If you do not delete
  the provisions above, a recipient may use your version of this file under
  the terms of any one of the Apache License version 2 or the GPL.

  ***** END LICENSE BLOCK *****

 *
 * XML diff/compare functions
 */
#ifdef HAVE_CONFIG_H
#include "clixon_config.h" /* generated by config & autoconf */
#endif

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <ctype.h>
#include <string.h>
#include <syslog.h>
#include <fcntl.h>
#include <assert.h>
#include <arpa/inet.h>
#include <sys/param.h>
#include <netinet/in.h>

/* cligen */
#include <cligen/cligen.h>

/* clixon */
#include "clixon_queue.h"
#include "clixon_hash.h"
#include "clixon_handle.h"
#include "clixon_string.h"
#include "clixon_map.h"
#include "clixon_yang.h"
#include "clixon_xml.h"
#include "clixon_log.h"
#include "clixon_debug.h"
#include "clixon_err.h"
#include "clixon_options.h"
#include "clixon_data.h"
#include "clixon_yang_module.h"
#include "clixon_plugin.h"
#include "clixon_xml_nsctx.h"
#include "clixon_xpath_ctx.h"
#include "clixon_xpath.h"
#include "clixon_path.h"
#include "clixon_netconf_lib.h"
#include "clixon_xml_sort.h"
#include "clixon_yang_type.h"
#include "clixon_text_syntax.h"
#include "clixon_nacm.h"
#include "clixon_xml_io.h"
#include "clixon_xml_map.h"
#include "clixon_xml_bind.h"
#include "clixon_xml_diff.h"

/* Local types
 */
/* Merge code needs a two-phase pass where objects subject to merge are first checked for,
 * the actually inserted.
 * This is to mitigate a search problem where objects inserted are among the ones checked for
 */
typedef struct  {
    cxobj     *mt_x0c;
    cxobj     *mt_x1c;
    yang_stmt *mt_yc;
} merge_twophase;

/* Forward declaration */
static int xml_diff2patch(cxobj *x1, cxobj *x2, uint16_t flags, cxobj *xpatch, int *nr);

/*! Compute if two XML trees are equal or not
 *
 * @param[in]  x0   First XML tree
 * @param[in]  x1   Second XML tree
 * @retval     1    Not equal
 * @retval     0    Equal
 * @see xml_diff which returns diff sets
 * @see xml_diff2cbuf   Diff buffer in XML
 * @see text_diff2cbuf  Diff buffer in curly
 */
int
xml_tree_equal(cxobj *x0,
               cxobj *x1)
{
    int        retval = 1; /* Not equal */
    int        eq;
    yang_stmt *y0c;
    yang_stmt *y1c;
    char      *b0;
    char      *b1;
    cxobj     *x0c; /* x0 child */
    cxobj     *x1c; /* x1 child */
    int        extflag = 0;

    /* Traverse x0 and x1 in lock-step */
    x0c = x1c = NULL;
    x0c = xml_child_each(x0, x0c, CX_ELMNT);
    x1c = xml_child_each(x1, x1c, CX_ELMNT);
    for (;;){
        if (x0c == NULL && x1c == NULL)
            goto ok;
        y0c = NULL;
        y1c = NULL;
        /* If cl:ignore-compare extension, return equal */
        if (x0c && (y0c = xml_spec(x0c)) != NULL){
            if (yang_extension_value(y0c, "ignore-compare", CLIXON_LIB_NS, &extflag, NULL) < 0)
                goto done;
            if (extflag){ /* skip */
                if (x1c) {
                    x0c = xml_child_each(x0, x0c, CX_ELMNT);
                    continue;
                }
                else
                    goto ok;
            }
        }
        if (x1c && (y1c = xml_spec(x1c)) != NULL){
            if (yang_extension_value(y1c, "ignore-compare", CLIXON_LIB_NS, &extflag, NULL) < 0)
                goto done;
            if (extflag){ /* skip */
                if (x1c) {
                    x1c = xml_child_each(x1, x1c, CX_ELMNT);
                    continue;
                }
                else
                    goto ok;
            }
        }
        if (x0c == NULL)
            goto done;
        else if (x1c == NULL)
            goto done;
        /* Both x0c and x1c exists, check if they are yang-equal. */
        if ((eq = xml_cmp(x0c, x1c, 0, 0, NULL)) != 0){
            goto done;
        }
        else{ /* equal */
            /* xml-spec NULL could happen with anydata children for example,
             * if so, continue compare children but without yang
             */
            if (y0c && y1c && y0c != y1c){ /* choice */
                goto done;
            }
            else
                if (y0c && yang_keyword_get(y0c) == Y_LEAF){
                    /* if x0c and x1c are leafs w bodies, then they may be changed */
                    b0 = xml_body(x0c);
                    b1 = xml_body(x1c);
                    if (b0 == NULL && b1 == NULL)
                        ;
                    else if (b0 == NULL || b1 == NULL
                             || strcmp(b0, b1) != 0
                             ){
                        goto done;
                    }
                }
                else {
                    eq = xml_tree_equal(x0c, x1c);
                    if (eq)
                        goto done;
                }
        }
        x0c = xml_child_each(x0, x0c, CX_ELMNT);
        x1c = xml_child_each(x1, x1c, CX_ELMNT);
    }
 ok:
    retval = 0;
 done:
    return retval;
}

/*! Handle order-by user(leaf)list for xml_diff
 *
 * Loop over sublists started by x0c and x1c respectively until end or yang is no longer yc
 * Just mark all nodes from x0c to end as DEL and all nodes from x1c as ADD
 * @param[in]  x0    First XML tree
 * @param[in]  x1    Second XML tree
 * @param[in]  x0c   Start of sublist in first XML tree
 * @param[in]  x1c   Start of sublist in second XML tree
 * @param[in]  yc    Yang of ordered-by user (leaf)list
 * @retval     0     Ok
 * @retval    -1     rror
 */
static int
xml_diff_ordered_by_user(cxobj     *x0,
                         cxobj     *x1,
                         cxobj     *x0c,
                         cxobj     *x1c,
                         yang_stmt *yc)
{
    int    retval = -1;
    cxobj *xi;
    cxobj *xj;

    /* Simpler algoithm: Just delete whole old list and add new list if ANY changes */
    xi = x0c;
    do {
        xml_flag_set(xi, XML_FLAG_DEL);
    } while ((xi = xml_child_each(x0, xi, CX_ELMNT)) != NULL &&
           xml_spec(xi) == yc);
    xj = x1c;
    do {
        xml_flag_set(xj, XML_FLAG_ADD);
    } while ((xj = xml_child_each(x1, xj, CX_ELMNT)) != NULL &&
             xml_spec(xj) == yc);
    retval = 0;
    // done:
    return retval;
}

/*! Recursive help function to compute differences between two xml trees
 *
 * @param[in]  x0         First XML tree
 * @param[in]  x1         Second XML tree
 * @param[out] x0vec      Pointervector to XML nodes existing in only first tree
 * @param[out] x0veclen   Length of first vector
 * @param[out] x1vec      Pointervector to XML nodes existing in only second tree
 * @param[out] x1veclen   Length of x1vec vector
 * @param[out] changed_x0 Pointervector to XML nodes changed orig value
 * @param[out] changed_x1 Pointervector to XML nodes changed wanted value
 * @param[out] changedlen Length of changed vector
 * @retval     0          Ok
 * @retval    -1          Error
 * Algorithm to compare two sorted lists A, B:
 *   A 0 1 2 3 5 6
 *   B 0 2 4 5 6
 * Let (a, b) be first elements of (A, B) respectively(*)
 *   a = b :  EITHER leafs: a!=b : add a in changed_x0, b in changed_x1,
 *            OR: Set (A,B) to children of (a,b) and call algorithm recursively
 *         , get next (a,b)
 *   a < b : add a in x0, get next a
 *   a > b : add b in x1, get next b
 * (*) "comparing" a&b here is made by xml_cmp() which judges equality from a structural
 *     perspective, ie both have the same yang spec, if they are lists, they have the
 *     the same keys. NOT that the values are equal!
 * Also, a node is skipped if:
 * 1) its xml flag has XML_FLAG_SKIP
 * 2) its yang has extension clixon-lib:ignore-compare
 * @see xml_diff2cbuf, clixon_text_diff2cbuf  for +/- diff for XML and TEXT formats
 * @see text_diff2cbuf for curly
 * @see xml_tree_equal Equal or not
 * @note reordering in ordered-by user is NOT supported
 */
static int
xml_diff1(cxobj     *x0,
          cxobj     *x1,
          cxobj   ***x0vec,
          size_t    *x0veclen,
          cxobj   ***x1vec,
          size_t    *x1veclen,
          cxobj   ***changed_x0,
          cxobj   ***changed_x1,
          size_t    *changedlen)
{
    int        retval = -1;
    cxobj     *x0c = NULL; /* x0 child */
    cxobj     *x1c = NULL; /* x1 child */
    yang_stmt *y0c;
    yang_stmt *y1c;
    char      *b0;
    char      *b1;
    int        eq;
    cxobj     *xi;
    cxobj     *xj;
    int        extflag;

    /* Traverse x0 and x1 in lock-step */
    x0c = x1c = NULL;
    x0c = xml_child_each(x0, x0c, CX_ELMNT);
    x1c = xml_child_each(x1, x1c, CX_ELMNT);
    for (;;){
        if (x0c == NULL && x1c == NULL)
            goto ok;
        y0c = NULL;
        y1c = NULL;
        /* If cl:ignore-compare extension, return equal */
        if (x0c) {
            if (xml_flag(x0c, XML_FLAG_SKIP) != 0x0){ /* skip */
                x0c = xml_child_each(x0, x0c, CX_ELMNT);
                continue;
            }
            else
                if ((y0c = xml_spec(x0c)) != NULL){
                    if (yang_extension_value(y0c, "ignore-compare", CLIXON_LIB_NS, &extflag, NULL) < 0)
                        goto done;
                    if (extflag){ /* skip */
                        x0c = xml_child_each(x0, x0c, CX_ELMNT);
                        continue;
                    }
                }
        }
        if (x1c) {
            if (xml_flag(x1c, XML_FLAG_SKIP) != 0x0){ /* skip */
                x1c = xml_child_each(x1, x1c, CX_ELMNT);
                continue;
            }
            else
                if ((y1c = xml_spec(x1c)) != NULL){
                    if (yang_extension_value(y1c, "ignore-compare", CLIXON_LIB_NS, &extflag, NULL) < 0)
                        goto done;
                    if (extflag){ /* skip */
                        x1c = xml_child_each(x1, x1c, CX_ELMNT);
                        continue;
                    }
                }
        }
        if (x0c == NULL){
            if (cxvec_append(x1c, x1vec, x1veclen) < 0)
                goto done;
            x1c = xml_child_each(x1, x1c, CX_ELMNT);
            continue;
        }
        else if (x1c == NULL){
            if (cxvec_append(x0c, x0vec, x0veclen) < 0)
                goto done;
            x0c = xml_child_each(x0, x0c, CX_ELMNT);
            continue;
        }
        /* Both x0c and x1c exists, check if they are yang-equal. */
        eq = xml_cmp(x0c, x1c, 0, 0, NULL);
        /* override ordered-by user with special look-ahead checks */
        if (eq && y0c && y1c && y0c == y1c && yang_find(y0c, Y_ORDERED_BY, "user")){
            if (xml_diff_ordered_by_user(x0, x1, x0c, x1c, y0c) < 0)
                goto done;
            /* Add all in x0 marked as DELETE in x0vec
             * Flags can remain: XXX should apply to all
             */
            xi = x0c;
            do {
                if (xml_flag(xi, XML_FLAG_DEL)){
                    if (cxvec_append(xi, x0vec, x0veclen) < 0)
                        goto done;
                }
            }
            while ((xi = xml_child_each(x0, xi, CX_ELMNT)) != NULL &&
                   xml_spec(xi) == y0c);
            x0c = xi;

            /* Add all in x1 marked as ADD in x1vec */
            xj = x1c;
            do {
                if (xml_flag(xj, XML_FLAG_ADD))
                    if (cxvec_append(xj, x1vec, x1veclen) < 0)
                        goto done;
            }
            while ((xj = xml_child_each(x1, xj, CX_ELMNT)) != NULL &&
                   xml_spec(xj) == y1c);
            x1c = xj;
            continue;
        }
        else if (eq < 0){
            if (cxvec_append(x0c, x0vec, x0veclen) < 0)
                goto done;
            x0c = xml_child_each(x0, x0c, CX_ELMNT);
            continue;
        }
        else if (eq > 0){
            if (cxvec_append(x1c, x1vec, x1veclen) < 0)
                goto done;
            x1c = xml_child_each(x1, x1c, CX_ELMNT);
            continue;
        }
        else{ /* equal */
            /* xml-spec NULL could happen with anydata children for example,
             * if so, continute compare children but without yang
             */
            if (y0c && y1c && y0c != y1c){ /* choice */
                if (cxvec_append(x0c, x0vec, x0veclen) < 0)
                    goto done;
                if (cxvec_append(x1c, x1vec, x1veclen) < 0)
                    goto done;
            }
            else if (y0c && yang_keyword_get(y0c) == Y_LEAF){
                /* if x0c and x1c are leafs w bodies, then they may be changed */
                b0 = xml_body(x0c);
                b1 = xml_body(x1c);
                if (b0 == NULL && b1 == NULL)
                    ;
                else if (b0 == NULL || b1 == NULL
                         || strcmp(b0, b1) != 0
                         ){
                    if (cxvec_append(x0c, changed_x0, changedlen) < 0)
                        goto done;
                    (*changedlen)--; /* append two vectors */
                    if (cxvec_append(x1c, changed_x1, changedlen) < 0)
                        goto done;
                }
            }
            else if (xml_diff1(x0c, x1c,
                               x0vec, x0veclen,
                               x1vec, x1veclen,
                               changed_x0, changed_x1, changedlen)< 0)
                goto done;
        }
        x0c = xml_child_each(x0, x0c, CX_ELMNT);
        x1c = xml_child_each(x1, x1c, CX_ELMNT);
    }
 ok:
    retval = 0;
 done:
    return retval;
}

/*! Compute differences between two xml trees
 *
 * @param[in]  x0         First XML tree
 * @param[in]  x1         Second XML tree
 * @param[out] first      Pointervector to XML nodes existing in only first tree
 * @param[out] firstlen   Length of first vector
 * @param[out] second     Pointervector to XML nodes existing in only second tree
 * @param[out] secondlen  Length of second vector
 * @param[out] changed_x0 Pointervector to XML nodes changed orig value
 * @param[out] changed_x1 Pointervector to XML nodes changed wanted value
 * @param[out] changedlen Length of changed vector
 * @retval     0          OK
 * @retval    -1          Error
 * All xml vectors should be freed after use.
 * @see xml_tree_equal  same algorithm but do not bother with what has changed
 * @see clixon_xml_diff_print  same algorithm but print in +/- diff format
 */
int
xml_diff(cxobj     *x0,
         cxobj     *x1,
         cxobj   ***first,
         size_t    *firstlen,
         cxobj   ***second,
         size_t    *secondlen,
         cxobj   ***changed_x0,
         cxobj   ***changed_x1,
         size_t    *changedlen)
{
    int retval = -1;

    *firstlen = 0;
    *secondlen = 0;
    *changedlen = 0;
    if (x0 == NULL && x1 == NULL)
        return 0;
    if (x1 == NULL){
        if (cxvec_append(x0, first, firstlen) < 0)
            goto done;
        goto ok;
    }
    if (x0 == NULL){
        if (cxvec_append(x0, second, secondlen) < 0)
            goto done;
        goto ok;
    }
    if (xml_diff1(x0, x1,
                  first, firstlen,
                  second, secondlen,
                  changed_x0, changed_x1, changedlen) < 0)
        goto done;
 ok:
    retval = 0;
 done:
    return retval;
}

/*! Merge a base tree x0 with x1 with yang spec y
 *
 * @param[in]  x0  Base xml tree (can be NULL in add scenarios)
 * @param[in]  y0  Yang spec corresponding to xml-node x0. NULL if x0 is NULL
 * @param[in]  x0p Parent of x0
 * @param[in]  x1  xml tree which modifies base
 * @param[out] reason If retval=0 a malloced string
 * @retval     1      OK
 * @retval     0      Yang error, reason is set
 * @retval    -1      Error
 * Assume x0 and x1 are same on entry and that y is the spec
 */
static int
xml_merge1(cxobj              *x0,  /* the target */
           yang_stmt          *y0,
           cxobj              *x0p,
           cxobj              *x1,  /* the source */
           char              **reason)
{
    int             retval = -1;
    char           *x1cname; /* child name */
    cxobj          *x0c; /* base child */
    cxobj          *x0b; /* base body */
    cxobj          *x1c; /* mod child */
    char           *x1bstr; /* mod body string */
    yang_stmt      *yc;  /* yang child */
    cbuf           *cbr = NULL; /* Reason buffer */
    int             i;
    merge_twophase *twophase = NULL;
    int             twophase_len;
    cvec           *nsc = NULL;
    cg_var         *cv;
    char           *ns;
    char           *px;
    char           *pxe;
    int             ret;

    if (x1 == NULL || xml_type(x1) != CX_ELMNT || y0 == NULL){
        clixon_err(OE_XML, EINVAL, "x1 is NULL or not XML element, or lacks yang spec");
        goto done;
    }
    if (x0 == NULL){
        if (xml_nsctx_node(x1, &nsc) < 0)
            goto done;
        if (xml_rm(x1) < 0)
            goto done;
        /* This is to make the anydata case a little more robust, more could be done */
        if (xml_spec(x1) == NULL){
            if (xml_addsub(x0p, x1) < 0)
                goto done;
        }
        else
            if (xml_insert(x0p, x1, INS_LAST, NULL, NULL) < 0)
                goto done;
        cv = NULL;
        while ((cv = cvec_each(nsc, cv)) != NULL){
            px = cv_name_get(cv);
            ns = cv_string_get(cv);
            /* Check if namespace exists */
            if ((ret = xml2prefix(x1, ns, &pxe)) < 0)
                goto done;
            if (ret == 0 ||  /* Not exist */
                clicon_strcmp(px, pxe) != 0){ /* Exists and not equal (can be NULL) */
                if (xmlns_set(x1, px, ns) < 0)
                    goto done;
                xml_sort(x1);
            }
        }
        goto ok;
    }
    if (yang_keyword_get(y0) == Y_LEAF_LIST || yang_keyword_get(y0) == Y_LEAF){
        x1bstr = xml_body(x1);
        if (x1bstr){
            if ((x0b = xml_body_get(x0)) == NULL){
                if ((x0b = xml_new("body", x0, CX_BODY)) == NULL)
                    goto done;
            }
            if (xml_value_set(x0b, x1bstr) < 0)
                goto done;
        }
        if (xml_parent(x0) == NULL &&
            xml_insert(x0p, x0, INS_LAST, NULL, NULL) < 0)
            goto done;
        if (assign_namespace_element(x1, x0, x0p) < 0)
            goto done;
    } /* if LEAF|LEAF_LIST */
    else { /* eg Y_CONTAINER, Y_LIST  */
        if (assign_namespace_element(x1, x0, x0p) < 0)
            goto done;
        twophase_len = xml_child_nr(x1);
        if ((twophase = calloc(twophase_len, sizeof(*twophase))) == NULL){
            clixon_err(OE_UNIX, errno, "calloc");
            goto done;
        }
        i = 0;
        /* Loop through children of the modification tree */
        x1c = NULL;
        while ((x1c = xml_child_each(x1, x1c, CX_ELMNT)) != NULL) {
            x1cname = xml_name(x1c);
            /* Get yang spec of the child */
            if ((yc = yang_find_datanode(y0, x1cname)) == NULL){
                /*
                 * Actually the CLICON_YANG_SCHEMA_MOUNT option should be checked below
                 * to be consistent with what is done e.g. in
                 * clixon_datastore_write.c::text_modify() when yang_find_datanode()
                 * returns NULL.
                 * However the clixon_handle needed to check this option is not
                 * available here.
                 * So check for the YANG_FLAG_MOUNTPOINT flag on y0 as an alternative.
                 * It will only have been set if CLICON_YANG_SCHEMA_MOUNT is enabled
                 * and it will be set for exactly those cases where the xml_spec()
                 * call is needed.
                 */
                if (yang_flag_get(y0, YANG_FLAG_MOUNTPOINT))
                    yc = xml_spec(x1c);
            }
            if (yc == NULL) {
                if (reason){
                    if ((cbr = cbuf_new()) == NULL){
                        clixon_err(OE_XML, errno, "cbuf_new");
                        goto done;
                    }
                    cprintf(cbr, "XML node %s/%s has no corresponding yang specification (Invalid XML or wrong Yang spec?", xml_name(x1), x1cname);
                    if ((*reason = strdup(cbuf_get(cbr))) == NULL){
                        clixon_err(OE_UNIX, errno, "strdup");
                        goto done;
                    }
                }
                goto fail;
            }
            /* See if there is a corresponding node in the base tree */
            x0c = NULL;
            if (yc && match_base_child(x0, x1c, yc, &x0c) < 0)
                goto done;
            /* If x0 already has a value, do not replace it with a default value in x1 */
            if (x0c && xml_flag(x1c, XML_FLAG_DEFAULT))
                continue;
            /* Save x0c, x1c, yc and merge in second wave, so that x1c entries dont "interfer"
             * with itself, ie that later searches are among earlier objects already added
             * to x0 */
            twophase[i].mt_x0c = x0c;
            twophase[i].mt_x1c = x1c;
            twophase[i].mt_yc  = yc;
            i++;
        } /* while */
        twophase_len = i; /* Inital length included non-elements */
        /* Second run where actual merging is done
         * Loop through children of the modification tree */
        for (i=0; i<twophase_len; i++){
            assert(twophase[i].mt_x1c);
            if ((ret = xml_merge1(twophase[i].mt_x0c,
                                  twophase[i].mt_yc,
                                  x0,
                                  twophase[i].mt_x1c,
                                  reason)) < 0)
                goto done;
            if (ret == 0)
                goto fail;
        }
        if (xml_parent(x0) == NULL &&
            xml_insert(x0p, x0, INS_LAST, NULL, NULL) < 0)
            goto done;
    } /* else Y_CONTAINER  */
 ok:
    retval = 1;
 done:
    if (nsc)
        cvec_free(nsc);
    if (twophase)
        free(twophase);
    if (cbr)
        cbuf_free(cbr);
    return retval;
 fail:
    retval = 0;
    goto done;
}

/*! Merge XML trees x1 into x0 according to yang spec yspec
 *
 * @param[in]  x0     Base xml tree (can be NULL in add scenarios)
 * @param[in]  x1     xml tree which modifies base
 * @param[in]  yspec  Yang spec
 * @param[out] reason If retval=0, reason is set. Malloced. Needs to be freed by caller
 * @retval     1      OK
 * @retval     0      Yang error, reason is set
 * @retval    -1      Error
 * @note both x0 and x1 need to be top-level trees AND bound to YANG
 */
int
xml_merge(cxobj     *x0,
          cxobj     *x1,
          yang_stmt *yspec,
          char     **reason)
{
    int        retval = -1;
    char      *x1cname; /* child name */
    cxobj     *x0c; /* base child */
    cxobj     *x1c; /* mod child */
    yang_stmt *yc;
    yang_stmt *ymod;
    cbuf      *cbr = NULL; /* Reason buffer */
    int        i;
    merge_twophase *twophase = NULL;
    int        twophase_len;
    int        ret;

    if (x0 == NULL || x1 == NULL){
        clixon_err(OE_UNIX, EINVAL, "parameters x0 or x1 is NULL");
        goto done;
    }
    twophase_len = xml_child_nr(x1);
    if ((twophase = calloc(twophase_len, sizeof(*twophase))) == NULL){
        clixon_err(OE_UNIX, errno, "calloc");
        goto done;
    }
    /* Loop through children of the modification tree */
    i = 0;
    x1c = NULL;
    while ((x1c = xml_child_each(x1, x1c, CX_ELMNT)) != NULL) {
        x1cname = xml_name(x1c);
        if ((ys_module_by_xml(yspec, x1c, &ymod)) < 0)
            goto done;
        if (ymod == NULL){
            if (reason &&
                (*reason = strdup("Namespace not found or yang spec not loaded")) == NULL){
                    clixon_err(OE_UNIX, errno, "strdup");
                    goto done;
            }
            goto fail;
        }
        /* Get yang spec of the child */
        if ((yc = yang_find_datanode(ymod, x1cname)) == NULL){
            if (reason){
                if ((cbr = cbuf_new()) == NULL){
                    clixon_err(OE_XML, errno, "cbuf_new");
                    goto done;
                }
                cprintf(cbr, "XML node %s/%s has no corresponding yang specification (Invalid XML or wrong Yang spec?)", xml_name(x1), x1cname);
                if ((*reason = strdup(cbuf_get(cbr))) == NULL){
                    clixon_err(OE_UNIX, errno, "strdup");
                    goto done;
                }
            }
            goto fail;
        }
        x0c = NULL;
        /* See if there is a corresponding node (x1c) in the base tree (x0) */
        if (yc && match_base_child(x0, x1c, yc, &x0c) < 0)
            goto done;
        /* If x0 already has a value, do not replace it with a default value in x1 */
        if (x0c && xml_flag(x1c, XML_FLAG_DEFAULT))
            continue;
        /* Save x0c, x1c, yc and merge in second wave, so that x1c entries don't "interfere"
         * with itself, ie that later searches are among earlier objects already added
         * to x0 */
        twophase[i].mt_x0c = x0c;
        twophase[i].mt_x1c = x1c;
        twophase[i].mt_yc  = yc;
        i++;
    }
    twophase_len = i; /* Inital length included non-elements */
    /* Second run where actual merging is done
     * Loop through children of the modification tree */
    for (i=0; i<twophase_len; i++){
        assert(twophase[i].mt_x1c);
        if ((ret = xml_merge1(twophase[i].mt_x0c,
                              twophase[i].mt_yc,
                              x0,
                              twophase[i].mt_x1c,
                              reason)) < 0)
            goto done;
        if (ret == 0)
            goto fail;
    }
    retval = 1; /* OK */
 done:
    if (twophase)
        free(twophase);
    if (cbr)
        cbuf_free(cbr);
    return retval;
 fail:
    retval = 0;
    goto done;
}

/*! Create diff_rebase struct
 *
 * @retval  dr   New diff_rebase struct
 * @retval  NULL Error
 */
diff_rebase_t *
diff_rebase_new(void)
{
    diff_rebase_t *dr = NULL;

    if ((dr = malloc(sizeof(*dr))) == NULL){
        clixon_err(OE_UNIX, errno, "malloc");
        goto done;
    }
    memset(dr, 0, sizeof(*dr));
 done:
    return dr;
}

/*! Free diff_rebase struct
 *
 * @param[in]  dr   New diff_rebase struct
 * @retval     0    OK
 */
int
diff_rebase_free(diff_rebase_t *dr)
{
    if (dr->dr_addparent)
        free(dr->dr_addparent);
    if (dr->dr_addchild)
        free(dr->dr_addchild);
    if (dr->dr_remove)
        free(dr->dr_remove);
    if (dr->dr_changefrom)
        free(dr->dr_changefrom);
    if (dr->dr_changeto)
        free(dr->dr_changeto);
    free(dr);
    return 0;
}

/*! Add node
 *
 * @param[in]  dr   New diff_rebase struct
 * @param[in]  xp   Parent node
 * @param[in]  xc   Child to copy
 * @retval     0    OK
 * @retval    -1    Error
 */
static int
diff_rebase_add(diff_rebase_t *dr,
                cxobj         *xp,
                cxobj         *xc)
{
    int retval = -1;

    if (cxvec_append(xp, &dr->dr_addparent, &dr->dr_addlen) < 0)
        goto done;
    (dr->dr_addlen)--; /* append two vectors */
    if (cxvec_append(xc, &dr->dr_addchild, &dr->dr_addlen) < 0)
        goto done;
    retval = 0;
 done:
    return retval;
}

/*! Remove object
 *
 * @param[in]  dr   New diff_rebase struct
 * @param[in]  x    Remove object
 * @retval     0    OK
 * @retval    -1    Error
 */
static int
diff_rebase_rm(diff_rebase_t *dr,
               cxobj         *x)
{
    int retval = -1;

    if (cxvec_append(x, &dr->dr_remove, &dr->dr_removelen) < 0)
        goto done;
    retval = 0;
 done:
    return retval;
}

/*! Change node
 *
 * @param[in]  dr    New diff_rebase struct
 * @param[in]  xfrom From node
 * @param[in]  xto   To node
 * @retval     0     OK
 * @retval    -1     Error
 */
static int
diff_rebase_change(diff_rebase_t *dr,
                   cxobj         *xfrom,
                   cxobj         *xto)
{
    int retval = -1;

    if (cxvec_append(xfrom, &dr->dr_changefrom, &dr->dr_changelen) < 0)
        goto done;
    (dr->dr_changelen)--; /* append two vectors */
    if (cxvec_append(xto, &dr->dr_changeto, &dr->dr_changelen) < 0)
        goto done;
    retval = 0;
 done:
    return retval;
}

/*! Execute add, remove and change ops
 *
 * @param[in]  dr    New diff_rebase struct
 * @param[in]  xfrom From node
 * @param[in]  xto   To node
 * @retval     0     OK
 * @retval    -1     Error
 * @note  need sort after
 */
int
diff_rebase_exec(diff_rebase_t *dr)
{
    int    retval = -1;
    cxobj *x;
    char  *val;
    int    i;

    for (i=0; i<dr->dr_addlen; i++){
        if ((x = xml_dup(dr->dr_addchild[i])) == NULL)
            goto done;
        if (xml_addsub(dr->dr_addparent[i], x) < 0)
            goto done;
    }
    for (i=0; i<dr->dr_removelen; i++){
        xml_purge(dr->dr_remove[i]);
    }
    for (i=0; i<dr->dr_changelen; i++){
        val = xml_value(dr->dr_changefrom[i]);
        xml_value_set(dr->dr_changeto[i], val);
    }
    retval = 0;
 done:
    return retval;
}

/*! Check single node equivalence
 *
 * @param[in]  x0   XML object 0
 * @param[in]  x1   XML object 1
 * @param[out] eq   0: equal, <0: x0 < x1, >0: x0 > x1
 * @retval     0    OK
 * @retval    -1    Error
 */
static int
xml_node_same(cxobj *x0,
              cxobj *x1,
              int   *obj)
{
    int        retval = -1; /* Not equal */
    yang_stmt *y0;
    yang_stmt *y1;
    int        ret;

    if (x0 == NULL && x1 == NULL){
        *obj = 0;
        goto ok;
    }
    else if (x0 == NULL){
        *obj = 1;
        goto ok;
    }
    else if (x1 == NULL){
        *obj = -1;
        goto ok;
    }
    if ((ret = xml_cmp(x0, x1, 0, 0, NULL)) != 0){
        *obj = ret;
        goto ok;
    }
    /* Same object */
    y0 = xml_spec(x0);
    y1 = xml_spec(x1);
    assert(y0 && y1);
    if (y0 != y1) /* choice */{
        *obj = 1;
        goto done;
    }
    *obj = 0;
 ok:
    retval = 0;
 done:
    return retval;
}

/*! Check single node equivalence
 *
 * @param[in]  x0     XML object 0
 * @param[in]  x1     XML object 1
 * @param[out] eq     0: Object is leaf and changed value, else equal or not leaf
 * @param[out] value0 If eq=0, value in x0
 * @param[out] value1 If eq=0, value in x1
 * @retval     0      OK
 * @retval    -1      Error
 */
static int
xml_node_eq(cxobj *x0,
            cxobj *x1,
            int   *eq,
            char **value0,
            char **value1)
{
    int        retval = -1; /* Not equal */
    yang_stmt *y0;
    yang_stmt *y1;
    char      *b0;
    char      *b1;

    assert(x0 && x1);
    /* Same object */
    y0 = xml_spec(x0);
    y1 = xml_spec(x1);
    assert(y0 && y1);
    if (yang_keyword_get(y0) == Y_LEAF){
        b0 = xml_body(x0);
        b1 = xml_body(x1);
        if (b0 == NULL && b1 == NULL)
            *eq = 1;
        else if (b0 == NULL || b1 == NULL
                 || strcmp(b0, b1) != 0
                 ){
            *eq = 0;
            if (value0)
                *value0 = b0;
            if (value1)
                *value1 = b1;
        }
        else
            *eq = 1;
    }
    else
        *eq = 1;
    retval = 0;
    // done:
    return retval;
}

/*! Rebase conflict, add netconf errmsg if first and print debug
 *
 * The values of the xpaths are context-dependent and dependent on the algorithm
 * The Error message gives some interpretation of the xpaths
 * @param[in]  h       Clixon handle
 * @param[in]  xpath0  XPath of origin
 * @param[in]  xpath1  XPath of candidate
 * @param[in]  xpath2  XPath of running
 * @param[in]  value0  Value0
 * @param[in]  value1  Value1
 * @param[in]  msg     Error message
 * @param[out] cbmsg   Write NETCONF error message if empty on input
 * @retval     0       OK
 * @retval    -1       Error
 */
static int
xml_rebase_conflict(clixon_handle h,
                    const char   *xpath0,
                    const char   *xpath1,
                    const char   *xpath2,
                    const char   *value0,
                    const char   *value1,
                    const char   *msg,
                    cbuf         *cbret)
{
    int   retval = -1;
    cbuf *cb = NULL;

    clixon_debug(CLIXON_DBG_XML, "Conflict occured: %s: xpath0:%s xpath1:%s xpath2:%s",
                 msg, xpath0?xpath0:"", xpath1?xpath1:"", xpath2?xpath2:"");
    if (cbret && cbuf_len(cbret) == 0){
        if ((cb = cbuf_new()) == NULL){
            clixon_err(OE_UNIX, errno, "cbuf_new");
            goto done;
        }
        cprintf(cb, "Conflict occured: %s: ", msg);
        if (xpath0)
            cprintf(cb, "xpath0: %s ", xpath0);
        if (xpath1)
            cprintf(cb, "xpath1: %s ", xpath1);
        if (xpath2)
            cprintf(cb, "xpath2: %s ", xpath2);
        if (value0)
            cprintf(cb, "value0: %s ", value0);
        if (value1)
            cprintf(cb, "value1: %s ", value1);
        if (netconf_operation_failed(cbret, "application", cbuf_get(cb)) < 0)
            goto done;
    }
    retval = 0;
 done:
    if (cb)
        cbuf_free(cb);
    return retval;
}

/*! Check if conflict when rebasing tree x0 to x2 for x1
 *
 * x0 is original base candidate datastore
 * x1 is modified candidate datastore
 * x2 Current datastore, the new base
 * This function checks issues with replacing the candidate datastore (x1) with the
 * current running config (x2) and replaying the the config changes (x0->x1)
 * against it.
 * Number of conflicts are returned, and the nature of each conflict is logged with
 * debug flag xml (start with -D xml)
 * One could skip default values
 *
                           update commit
          +--------------------+---+------> private candidate 1
         /                  x1 ^    \
     x0 /  edit-config     x2 /      âŒ„
   +---+--------+--------+---+-------+----> running configuration
    edit-config  \       ^
                  \     /
                   +---+------------------> private candidate 2
                    commit

 * @param[in]  h        Clixon handle
 * @param[in]  x0       XML node of db0 (assumed original)
 * @param[in]  x1       XML node of db1 (assumed candidate)
 * @param[in]  x2       XML node of db2 (assumed running)
 * @param[out] conflict Set to number of conflicts, if any
 * @param[out] cbret    If given, set to rpc-error if conflict>0 of first error
 * @param[out] dr       Diff rebase struct
 * @retval     0        OK
 * @retval    -1        Error
 * @see xml_tree_equal
 * @see xml_diff
 */
int
xml_rebase(clixon_handle  h,
           cxobj         *x0,
           cxobj         *x1,
           cxobj         *x2,
           int           *conflictp,
           cbuf          *cbret,
           diff_rebase_t *dr)
{
    int        retval = -1;
    cxobj     *x0c;
    cxobj     *x1c;
    cxobj     *x2c;
    //    yang_stmt *y0c = NULL;
    yang_stmt *y1c = NULL;
    //    yang_stmt *y2c = NULL;
    int        same10;
    int        same20;
    int        same12;
    char      *xpath0 = NULL;
    char      *xpath1 = NULL;
    char      *xpath2 = NULL;
    int        eq1;
    int        eq2;
    char      *value0;
    char      *value1;
    int        conflict = 0;

    x0c = x1c = x2c = NULL;
    x0c = xml_child_each(x0, x0c, CX_ELMNT);
    x1c = xml_child_each(x1, x1c, CX_ELMNT);
    x2c = xml_child_each(x2, x2c, CX_ELMNT);
    while (x0c != NULL || x1c != NULL || x2c != NULL){
        if (x0c){
            if (xml2xpath(x0c, NULL, 0, 0, &xpath0) < 0)
                goto done;
            // y0c = xml_spec(x0c);
        }
        if (x1c){
            if (xml2xpath(x1c, NULL, 0, 0, &xpath1) < 0)
                goto done;
            y1c = xml_spec(x1c);
        }
        if (x2c){
            if (xml2xpath(x2c, NULL, 0, 0, &xpath2) < 0)
                goto done;
            // y2c = xml_spec(x2c);
        }
        if (xml_node_same(x1c, x0c, &same10) < 0)
            goto done;
        if (xml_node_same(x2c, x0c, &same20) < 0)
            goto done;
        if (xml_node_same(x1c, x2c, &same12) < 0)
            goto done;
        clixon_debug(CLIXON_DBG_XML | CLIXON_DBG_DETAIL, "%d %d %d\n", same10, same20, same12);
        eq1 = 0;
        if (same10 < 0){ /* New in x1c */
            if (same20 < 0){
                if (same12 == 0){
                    if (xml_tree_equal(x1c, x2c) != 0){
                        if (xml_rebase_conflict(h, NULL, xpath1, NULL, NULL, NULL,
                                                "Cannot add node, it is already added", cbret) < 0)
                            goto done;
                        conflict++;
                    }
                    else if (y1c && yang_keyword_get(y1c) == Y_LEAF){
                        if (xml_rebase_conflict(h, NULL, xpath1, NULL, NULL, NULL,
                                                "Cannot add leaf node, another leaf node is added", cbret) < 0)
                            goto done;
                        conflict++;
                    }
                }

                else if (y1c && yang_keyword_get(y1c) == Y_LEAF_LIST){
                    if (xml_rebase_conflict(h, NULL, xpath1, NULL, NULL, NULL,
                                            "Cannot add leaf-list node, another leaf-list node is added", cbret) < 0)
                        goto done;
                    conflict++;
                }
                x2c = xml_child_each(x2, x2c, CX_ELMNT);
            }
            x1c = xml_child_each(x1, x1c, CX_ELMNT);
            goto next;
        }
        else if (same10 == 0){
            if (same20 < 0){ /* New in x2c */
                if (dr != NULL){ /* Add node in x1 */
                    if (diff_rebase_add(dr, x1, x2c) < 0)
                        goto done;
                }
                x2c = xml_child_each(x2, x2c, CX_ELMNT);
                goto next;
            }
            else if (same20 == 0){
                /* Same node, has value changed? */
                eq1 = eq2 = 0;
                if (xml_node_eq(x1c, x0c, &eq1, &value1, &value0) < 0)
                    goto done;
                if (eq1 == 0){
                    if (xml_node_eq(x2c, x0c, &eq2, NULL, NULL) < 0)
                        goto done;
                    if (eq2 == 0){
                        if (xml_rebase_conflict(h, xpath0, NULL, NULL, value0, value1,
                                                "Cannot change node value, it is already changed", cbret) < 0)
                            goto done;
                        conflict++;
                    }
                }
                else if (dr != NULL){
                    if (xml_node_eq(x2c, x0c, &eq1, &value1, &value0) < 0)
                        goto done;
                    if (eq1 == 0){
                        if (diff_rebase_change(dr, xml_body_get(x2c), xml_body_get(x1c)) < 0)
                            goto done;
                    }
                }
            }
            else if (same20 > 0){ /* x2c deleted */
                if (xml_tree_equal(x0c, x1c) == 0){ /* No change in x1 */
                    if (dr != NULL){ /* Delete it in x1 */
                        if (diff_rebase_rm(dr, x1c) < 0)
                            goto done;
                    }
                }
                else{ /* x2c deleted -> Conflict if to x1-x0 */
                    if (xml_rebase_conflict(h, xpath0, NULL, NULL, NULL, NULL,
                                            "Cannot change node value, node is removed", cbret) < 0)
                        goto done;
                    conflict++;
                }
                x0c = xml_child_each(x0, x0c, CX_ELMNT);
                x1c = xml_child_each(x1, x1c, CX_ELMNT);
                goto next;
            }
        }
        else if (same10 > 0){ /* Deleted x1c */
            if (same20 < 0){
                x2c = xml_child_each(x2, x2c, CX_ELMNT);
                goto next;
            }
            else if (same20 == 0){
                if (xml_tree_equal(x0c, x2c) != 0){
                    if (xml_rebase_conflict(h, xpath0, NULL, NULL, NULL, NULL,
                                            "Cannot remove node, node value has changed ", cbret) < 0)
                        goto done;
                    conflict++;
                }
                x0c = xml_child_each(x0, x0c, CX_ELMNT);
                x2c = xml_child_each(x2, x2c, CX_ELMNT);
                goto next;
            }
            else if (same20 > 0){ /* Deleted both in x1c and x2c */
                if (xml_rebase_conflict(h, xpath0, NULL, NULL, NULL, NULL,
                                        "Cannot remove node, it is already removed", cbret) < 0)
                    goto done;
                conflict++;
                x0c = xml_child_each(x0, x0c, CX_ELMNT);
            }
        }
        if (xml_rebase(h, x0c, x1c, x2c, &conflict, cbret, dr) < 0)
            goto done;
        x0c = xml_child_each(x0, x0c, CX_ELMNT);
        x1c = xml_child_each(x1, x1c, CX_ELMNT);
        x2c = xml_child_each(x2, x2c, CX_ELMNT);
    next:
        if (xpath0){
            free(xpath0);
            xpath0 = NULL;
        }
        if (xpath1){
            free(xpath1);
            xpath1 = NULL;
        }
        if (xpath2){
            free(xpath2);
            xpath2 = NULL;
        }
        // y0c = NULL;
        y1c = NULL;
        // y2c = NULL;
    }
    if (conflictp)
        *conflictp += conflict;
    retval = 0;
 done:
    if (xpath0)
        free(xpath0);
    if (xpath1)
        free(xpath1);
    if (xpath2)
        free(xpath2);
    return retval;
}

/*! xml_diff2patch helper function to create or delete node
 *
 * @param[in]  xn      XML tree
 * @param[in]  create  0: delete, 1: create
 * @param[out] xdiff   Diff in patch form
 * @param[out] nr      Patch event sequence number
 * @retval     0       OK
 * @retval    -1       Error
 */
static int
xml_diff2patch_create_delete(cxobj *xn,
                             int    create,
                             cxobj *xpatch,
                             int   *nr)
{
    int    retval = -1;
    cxobj *xedit = NULL;
    cxobj *xv;
    cxobj *xcp;
    char  *api_path;
    cbuf  *cb = NULL;
    cvec  *nsc = NULL;
    int    ret;

    if ((cb = cbuf_new()) == NULL){
        clixon_err(OE_UNIX, errno, "cbuf_new");
        goto done;
    }
    if (xml2api_path(xn, XML_FLAG_TOP, cb) < 0)
        goto done;
    api_path = cbuf_get(cb);
    if (clixon_xml_parse_va(YB_NONE, NULL, &xedit, NULL, "<edit><edit-id>%d</edit-id>"
                            "<operation>%s</operation><target>%s</target><value></value></edit>",
                            (*nr)++, create?"create":"delete", api_path)  < 0)
        goto done;
    if (xml_rootchild(xedit, 0, &xedit) < 0)
        goto done;
    xv = xml_find_type(xedit, NULL, "value", CX_ELMNT);
    if (xml_nsctx_node(xn, &nsc) < 0)
        goto done;
    if ((xcp = xml_dup(xn)) == NULL)
        goto done;
    if (xml_addsub(xv, xcp) < 0)
        goto done;
    if (xmlns_set_all(xcp, nsc) < 0)
        goto done;
    if (xml_addsub(xpatch, xedit) < 0)
        goto done;
    if ((ret = xml_bind_yang0(NULL, xpatch, YB_PARENT, NULL, 0, NULL)) < 0)
        goto done;
    if (ret == 0){
        clixon_err(OE_YANG, 0, "patch YANG Bind failed");
        goto done;
    }
    retval = 0;
 done:
    if (nsc)
        cvec_free(nsc);
    if (cb)
        cbuf_free(cb);
    return retval;
}

/*! xml_diff2patch helper function to compute leaf difference
 *
 * @param[in]  x1     Source XML tree
 * @param[in]  x2     Target XML tree
 * @param[out] xdiff  Diff in patch form
 * @param[out] nr     Patch event sequence number
 * @retval     0      OK
 * @retval    -1      Error
 */
static int
xml_diff2patch_change_leaf(cxobj *x1,
                           cxobj *x2,
                           cxobj *xpatch,
                           int   *nr)
{
    int    retval = -1;
    cxobj *xedit = NULL;
    cxobj *xv;
    cxobj *xcp;
    char  *api_path;
    cbuf  *cb = NULL;
    cvec  *nsc1 = NULL;
    cvec  *nsc2 = NULL;
    int    ret;

    if ((cb = cbuf_new()) == NULL){
        clixon_err(OE_UNIX, errno, "cbuf_new");
        goto done;
    }
    if (xml2api_path(x2, XML_FLAG_TOP, cb) < 0)
        goto done;
    api_path = cbuf_get(cb);
    if (clixon_xml_parse_va(YB_NONE, NULL, &xedit, NULL,
                            "<edit><edit-id>%d</edit-id>"
                            "<operation>replace</operation>"
                            "<target>%s</target>"
                            "<value></value>"
                            "<source-value></source-value>"
                            "</edit>",
                            (*nr)++, api_path)  < 0)
        goto done;
    if (xml_rootchild(xedit, 0, &xedit) < 0)
        goto done;
    xv = xml_find_type(xedit, NULL, "value", CX_ELMNT);
    if (xml_nsctx_node(x2, &nsc2) < 0)
        goto done;
    if ((xcp = xml_dup(x2)) == NULL)
        goto done;
    if (xml_addsub(xv, xcp) < 0)
        goto done;
    if (xmlns_set_all(xcp, nsc2) < 0)
        goto done;
    xv = xml_find_type(xedit, NULL, "source-value", CX_ELMNT);
    if (xml_nsctx_node(x1, &nsc1) < 0)
        goto done;
    if ((xcp = xml_dup(x1)) == NULL)
        goto done;
    if (xml_addsub(xv, xcp) < 0)
        goto done;
    if (xmlns_set_all(xcp, nsc1) < 0)
        goto done;
    if (xml_addsub(xpatch, xedit) < 0)
        goto done;
    if ((ret = xml_bind_yang0(NULL, xpatch, YB_PARENT, NULL, 0, NULL)) < 0)
        goto done;
    if (ret == 0){
        clixon_err(OE_YANG, 0, "patch YANG Bind failed");
        goto done;
    }
    retval = 0;
 done:
    if (nsc1)
        cvec_free(nsc1);
    if (nsc2)
        cvec_free(nsc2);
    if (cb)
        cbuf_free(cb);
    return retval;
}

/*! Handle order-by user(leaf)list for xml_diff2cbuf
 *
 * @param[out] cb      CLIgen buffer
 * @param[in]  x1      Source XML tree
 * @param[in]  x2      Target XML tree
 * @param[in]  flags   Comparison flags, see DIFF_FLAG_ORDER_IGNORE et al
 * @param[in]  x1c     Start of sublist in first XML tree
 * @param[in]  x2c     Start of sublist in second XML tree
 * @param[in]  yc      Yang of x1c/x2c. If NULL special case of anydata
 * @param[in]  level   How many spaces to insert before each line
 * @retval     0       Ok
 * @retval    -1       Error
 * @see xml_diff_ordered_by_user
 * @see text_diff2cbuf_ordered_by_user
 */
static int
xml_diff2patch_ordered_by_user(cxobj     *x1,
                               cxobj     *x2,
                               uint16_t   flags,
                               cxobj     *x1c,
                               cxobj     *x2c,
                               yang_stmt *yc,
                               cxobj     *xpatch,
                               int       *nr)
{
    int    retval = 1;
    cxobj *xi;
    cxobj *xj;

    xj = x2c;
    do { /* Mark all  x2 as ADD */
        xml_flag_set(xj, XML_FLAG_ADD);
    } while ((xj = xml_child_each(x2, xj, CX_ELMNT)) != NULL &&
             xml_spec(xj) == yc);
    /* If in both sets, unmark add/del */
    xi = x1c;
    do {
        xml_flag_set(xi, XML_FLAG_DEL);
        xj = x2c;
        do {
            if (xml_flag(xj, XML_FLAG_ADD) &&
                xml_cmp(xi, xj, 0, 0, NULL) == 0){
                /* Unmark node in x1 and x2 */
                xml_flag_reset(xi, XML_FLAG_DEL);
                xml_flag_reset(xj, XML_FLAG_ADD);
                if (xml_diff2patch(xi, xj, flags, xpatch, nr) < 0)
                    goto done;
                break;
            }
        }
        while ((xj = xml_child_each(x2, xj, CX_ELMNT)) != NULL &&
               xml_spec(xj) == yc);
    }
    while ((xi = xml_child_each(x1, xi, CX_ELMNT)) != NULL &&
           xml_spec(xi) == yc);

    retval = 0;
 done:
    return retval;
}

/*! Recursive helper function of clixon_xml_diff2patch
 *
 * Some notes: ordered-by user elements are either:
 * (1) treated as other elements, which can lead to confusing create/delete rules,
 * under-specified, eg: a,b vs b,a can propose delete a; add a
 * @param[in]  x1      Source XML tree
 * @param[in]  x2      Target XML tree
 * @param[in]  flags   Comparison flags, see DIFF_FLAG_ORDER_IGNORE et al
 * @param[out] xpatch  Diff in patch form on level <yang-patch>
 * @param[out] nr      Patch (sequence) number
 * @retval     0       Ok
 * @retval    -1       Error
 * @note  ordered-by user should use LCS (Longest common subsequence) but does not
 */
static int
xml_diff2patch(cxobj   *x1,
               cxobj   *x2,
               uint16_t flags,
               cxobj   *xpatch,
               int     *nr)
{
    int        retval = -1;
    cxobj     *x1c = NULL; /* x1 child */
    cxobj     *x2c = NULL; /* x2 child */
    cxobj     *xi;
    cxobj     *xj;
    yang_stmt *y0c;
    yang_stmt *y1c;
    int        extflag;
    char      *b0;
    char      *b1;
    int        eq;

    /* Traverse x1 and x2 in lock-step */
    x1c = x2c = NULL;
    x1c = xml_child_each(x1, x1c, CX_ELMNT);
    x2c = xml_child_each(x2, x2c, CX_ELMNT);
    for (;;){
        if (x1c == NULL && x2c == NULL)
            goto ok;
        /* Skip if marked as DENY by NACM */
        if (x1c && xml_flag(x1c, XML_FLAG_DENY) != 0){
            x1c = xml_child_each(x1, x1c, CX_ELMNT);
            continue;
        }
        else if (x2c && xml_flag(x2c, XML_FLAG_DENY) != 0){
            x2c = xml_child_each(x2, x2c, CX_ELMNT);
            continue;
        }
        y0c = NULL;
        y1c = NULL;
        /* If cl:ignore-compare extension, skip */
        if (x1c && (y0c = xml_spec(x1c)) != NULL){
            if (yang_extension_value(y0c, "ignore-compare", CLIXON_LIB_NS, &extflag, NULL) < 0)
                goto done;
            if (extflag){ /* skip */
                x1c = xml_child_each(x1, x1c, CX_ELMNT);
                continue;
            }
        }
        if (x2c && (y1c = xml_spec(x2c)) != NULL){
            if (yang_extension_value(y1c, "ignore-compare", CLIXON_LIB_NS, &extflag, NULL) < 0)
                goto done;
            if (extflag){ /* skip */
                x2c = xml_child_each(x2, x2c, CX_ELMNT);
                continue;
            }
        }
        if (x1c == NULL){
            if (xml_diff2patch_create_delete(x2c, 1, xpatch, nr) < 0)
                goto done;
            x2c = xml_child_each(x2, x2c, CX_ELMNT);
            continue;
        }
        else if (x2c == NULL){
            if (xml_diff2patch_create_delete(x1c, 0, xpatch, nr) < 0)
                goto done;
            x1c = xml_child_each(x1, x1c, CX_ELMNT);
            continue;
        }
        /* Both x1c and x2c exists, check if yang equal */
        eq = xml_cmp(x1c, x2c, 0, 0, NULL);
        b0 = xml_body(x1c);
        b1 = xml_body(x2c);
        if ((flags & DIFF_FLAG_ORDER_IGNORE) != 0 &&
            eq && y0c && y1c && y0c == y1c && yang_find(y0c, Y_ORDERED_BY, "user")){
            if (xml_diff2patch_ordered_by_user(x1, x2, flags, x1c, x2c, y0c, xpatch, nr) < 0)
                goto done;
            /* Show all marked as DELETE as - entries
             */
            xi = x1c;
            do {
                if (xml_flag(xi, XML_FLAG_DEL)){
                    xml_flag_reset(xi, XML_FLAG_DEL);
                    if (xml_diff2patch_create_delete(xi, 0, xpatch, nr) < 0)
                        goto done;
                }
            }
            while ((xi = xml_child_each(x1, xi, CX_ELMNT)) != NULL &&
                   xml_spec(xi) == y0c);
            x1c = xi; /* skip entries in this yang class */
            /* Show all marked as ADD as + entries
             */
            xj = x2c;
            do {
                if (xml_flag(xj, XML_FLAG_ADD)){
                    xml_flag_reset(xj, XML_FLAG_ADD);
                    if (xml_diff2patch_create_delete(xj, 1, xpatch, nr) < 0)
                        goto done;
                }
            }
            while ((xj = xml_child_each(x2, xj, CX_ELMNT)) != NULL &&
                   xml_spec(xj) == y1c);
            x2c = xj;
            continue;
        } /* ordered-by user */
        else if (eq < 0){
            if (xml_diff2patch_create_delete(x1c, 0, xpatch, nr) < 0)
                goto done;
            x1c = xml_child_each(x1, x1c, CX_ELMNT);
            continue;
        }
        else if (eq > 0){
            if (xml_diff2patch_create_delete(x2c, 1, xpatch, nr) < 0)
                goto done;
            x2c = xml_child_each(x2, x2c, CX_ELMNT);
            continue;
        }
        else{ /* equal */
            if (y0c && y1c && y0c != y1c){ /* equal + choice */
                if (xml_diff2patch_create_delete(x1c, 0, xpatch, nr) < 0)
                    goto done;
                if (xml_diff2patch_create_delete(x2c, 1, xpatch, nr) < 0)
                    goto done;
            }
            else if (y0c && yang_keyword_get(y0c) == Y_LEAF){
                /* if x1c and x2c are leafs w bodies, then they may be changed */
                if (b0 == NULL && b1 == NULL)
                    ;
                else if (b0 == NULL || b1 == NULL || strcmp(b0, b1) != 0){
                    if (xml_diff2patch_change_leaf(x1c, x2c, xpatch, nr) < 0)
                        goto done;
                }
            }
            else if (y0c == NULL && y1c == NULL && (b0 || b1)) { /* Anydata terminals */
                if (b0 == NULL || b1 == NULL || strcmp(b0, b1) != 0){
                    if (xml_diff2patch_change_leaf(x1c, x2c, xpatch, nr) < 0)
                        goto done;
                }
            }
            else if (xml_diff2patch(x1c, x2c, flags, xpatch, nr) < 0)
                goto done;
        }
        /* Get next */
        x1c = xml_child_each(x1, x1c, CX_ELMNT);
        x2c = xml_child_each(x2, x2c, CX_ELMNT);
    }
 ok:
    retval = 0;
 done:
    return retval;
}

/*! Print XML diff of two cxobj trees into YANG patch format according to RFC9144
 *
 * YANG dependent
 * Mark x1 and x2 as TOP for api-path matching to work
 * @param[in]  x1      Source XML tree
 * @param[in]  x2      Target XML tree
 * @param[in]  flags   Comparison flags, see DIFF_FLAG_ORDER_IGNORE et al
 * @param[out] xpatch  Diff in patch form on level <yang-patch>
 * @retval     0       Ok
 * @retval    -1       Error
 * @code
 *    cxobj *xpatch;
 *    if ((xpatch = xml_new("yang-patch", NULL, CX_ELMNT)) == NULL)
 *       err();
 *    if (clixon_xml_diff2patch(x1, x2, xpatch) < 0)
 *       err();
 *    cligen_output(stdout, "%s", cbuf_get(cb));
 * @endcode
 * @see xml_diff which returns diff sets
 * @see clixon_compare_xmls which uses files and is independent of YANG
 * @see xml_diff2cbuf
 * @see clixon_xml_diff_nacm_read  Call before to mark NACM non-readable nodes
 * @note  ordered-by user should use LCS (Longest common subsequence) but does not
 */
int
clixon_xml_diff2patch(cxobj   *x1,
                      cxobj   *x2,
                      uint16_t flags,
                      cxobj   *xpatch)
{
    int retval = -1;
    int nr = 1;

    if (x1)
        xml_flag_set(x1, XML_FLAG_TOP);
    if (x2)
        xml_flag_set(x2, XML_FLAG_TOP);
    if (xml_diff2patch(x1, x2, flags, xpatch, &nr) < 0)
        goto done;
    retval = 0;
 done:
    if (x1)
        xml_flag_reset(x1, XML_FLAG_TOP);
    if (x2)
        xml_flag_reset(x2, XML_FLAG_TOP);
    return retval;
}

/*! Do NACM read data check, mark non-readable nodes with DENY flag
 *
 * Dont actually remove them
 * @param[in]  h     Clixon handle
 * @param[in]  xt    XML top
 * @param[in]  xpath XPath
 * @retval      0    OK
 * @retval     -1    Error
 * see code in backend_get.c
 * get_common(), get_nacm_and_reply()
 */
int
clixon_xml_diff_nacm_read(clixon_handle h,
                          cxobj        *xt,
                          char         *xpath)
{
    int     retval = -1;
    cxobj  *xnacm;
    char   *username;

    xnacm = clicon_nacm_cache(h);
    username = clicon_username_get(h);
    if (xnacm != NULL){ /* Do NACM validation */
        /* NACM datanode/module purge read access violation */
        if (nacm_datanode_read1(h, xt, username, xnacm) < 0)
            goto done;
    }
    retval = 0;
 done:
    return retval;
}
