/*
 *
  ***** BEGIN LICENSE BLOCK *****
 
  Copyright (C) 2009-2016 Olof Hagsand and Benny Holmgren
  Copyright (C) 2017-2019 Olof Hagsand
  Copyright (C) 2020-2022 Olof Hagsand and Rubicon Communications, LLC(Netgate)

  This file is part of CLIXON.

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.

  Alternatively, the contents of this file may be used under the terms of
  the GNU General Public License Version 3 or later (the "GPL"),
  in which case the provisions of the GPL are applicable instead
  of those above. If you wish to allow use of your version of this file only
  under the terms of the GPL, and not to allow others to
  use your version of this file under the terms of Apache License version 2, 
  indicate your decision by deleting the provisions above and replace them with
  the  notice and other provisions required by the GPL. If you do not delete
  the provisions above, a recipient may use your version of this file under
  the terms of any one of the Apache License version 2 or the GPL.

  ***** END LICENSE BLOCK *****

 *
 * Errors may be syslogged using LOG_ERR, and printed to stderr, as controlled
 * by clicon_log_init
 * global error variables are set:
 *  clicon_errno, clicon_suberrno, clicon_err_reason.
 */

#ifdef HAVE_CONFIG_H
#include "clixon_config.h" /* generated by config & autoconf */
#endif

#include <stdio.h>
#include <stdarg.h>
#include <stdint.h>
#include <stdlib.h>
#include <fcntl.h>
#include <errno.h>
#include <unistd.h>
#include <syslog.h>
#include <string.h>
#include <time.h>
#include <sys/time.h>
#include <sys/types.h>

/* cligen */
#include <cligen/cligen.h>

/* clixon */
#include "clixon_log.h"
#include "clixon_queue.h"
#include "clixon_err.h"

/*
 * Types
 */
struct errvec{
    char *ev_str;
    int   ev_err;
};

struct err_state{
    int  es_errno;
    int  es_suberrno;
    char es_reason[ERR_STRLEN];
};

/* Clixon error category callbacks provides a way to specialize
 * error handling to something that clixon is not aware of
 * An example is Openssl BIO I/O abstraction objects, see man BIO_new()
 */
struct clixon_err_cats {
    qelem_t             cec_qelem; /* List header */
    enum clicon_err     cec_category;
    void               *cec_handle;
    clixon_cat_log_cb  *cec_logfn;
};
typedef struct clixon_err_cats clixon_err_cats;

/* Internal global list of category callbacks */
static clixon_err_cats *_err_cat_list = NULL;

/*
 * Variables
 */
int  clicon_errno  = 0;    /* See enum clicon_err XXX: hide this and change to err_category */
int  clicon_suberrno  = 0; /* Corresponds to errno.h XXX: change to errno */
char clicon_err_reason[ERR_STRLEN] = {0, };

/*
 * Error descriptions. Must stop with NULL element.
 */
static struct errvec EV[] = {
    {"Database error",         OE_DB},
    {"Daemon error",           OE_DAEMON},
    {"Event error",            OE_EVENTS},
    {"Config error",           OE_CFG},
    {"Netconf error",          OE_NETCONF},
    {"Protocol error",         OE_PROTO},
    {"Regexp error",           OE_REGEX},
    {"UNIX error",             OE_UNIX},
    {"Syslog error",           OE_SYSLOG},
    {"Routing daemon error",   OE_ROUTING},
    {"XML error",              OE_XML},
    {"JSON error",             OE_JSON},
    {"RESTCONF error",         OE_RESTCONF},
    {"Plugins",                OE_PLUGIN},
    {"Yang error",             OE_YANG},
    {"FATAL",                  OE_FATAL},
    {"Undefined",              OE_UNDEF},
    /* From here error extensions using clixon_err_cat_reg */
    {"OpenSSL error",          OE_SSL},
    {"SNMP error",             OE_SNMP},
    {"Nghttp2 error",          OE_NGHTTP2},
    {NULL,                     -1}
};

static char *
clicon_strerror1(int           err,
		 struct errvec vec[])
{
    struct errvec *ev;

    for (ev=vec; ev->ev_err != -1; ev++)
	if (ev->ev_err == err)
	    break;
    return ev?(ev->ev_str?ev->ev_str:"unknown"):"CLICON unknown error";
}

/*! Clear error state and continue.
 *
 * Clear error state and get on with it, typically non-fatal error and you wish to continue.
 */
int
clicon_err_reset(void)
{
    clicon_errno = 0;
    clicon_suberrno = 0;
    memset(clicon_err_reason, 0, ERR_STRLEN);
    return 0;
}

/*! Find error category struct given name
 */
static struct clixon_err_cats *
find_category(int category)
{
    clixon_err_cats *cec = NULL;
    int              found = 0;

    if ((cec = _err_cat_list) != NULL){
	do {
	    if (cec->cec_category == category){
		found++;
		break;
	    }
	    cec = NEXTQ(clixon_err_cats *, cec);
	} while (cec && cec != _err_cat_list);
    }
    return found?cec:NULL;
}

/*! Report an error.
 *
 * Library routines should call this function when an error occurs.
 * The function does he following:
 * - Logs to syslog with LOG_ERR
 * - Set global error variable name clicon_errno
 * - Set global reason string clicon_err_reason
 * @note: err direction (syslog and/or stderr) controlled by clicon_log_init()
 *
 * @param[in]    fn       Inline function name (when called from clicon_err() macro)
 * @param[in]    line     Inline file line number (when called from clicon_err() macro)
 * @param[in]    category Clixon error category, See enum clicon_err
 * @param[in]    suberr   Error number, typically errno
 * @param[in]    format   Error string, format with argv
 * @see clicon_err_reset  Reset the global error variables.
 */
int
clicon_err_fn(const char *fn,
	      const int  line,
	      int        category,
	      int        suberr,
	      const char *format, ...) 
{
    va_list args;
    int     len;
    char   *msg    = NULL;
    int     retval = -1;
    struct clixon_err_cats *cec;
    
    /* Set the global variables */
    clicon_errno    = category;
    clicon_suberrno = suberr;

    /* first round: compute length of error message */
    va_start(args, format);
    len = vsnprintf(NULL, 0, format, args);
    va_end(args);

    /* allocate a message string exactly fitting the message length */
    if ((msg = malloc(len+1)) == NULL){
	fprintf(stderr, "malloc: %s\n", strerror(errno)); /* dont use clicon_err here due to recursion */
	goto done;
    }

    /* second round: compute write message from format and args */
    va_start(args, format);
    if (vsnprintf(msg, len+1, format, args) < 0){
	va_end(args);
	fprintf(stderr, "vsnprintf: %s\n", strerror(errno)); /* dont use clicon_err here due to recursion */
	goto done;
    }
    va_end(args);
    strncpy(clicon_err_reason, msg, ERR_STRLEN-1);

    /* Check category callbacks as defined in clixon_err_cat_reg */
    if ((cec = find_category(category)) != NULL &&
	cec->cec_logfn){
	cbuf *cb = NULL;
	if ((cb = cbuf_new()) == NULL){
	    fprintf(stderr, "cbuf_new: %s\n", strerror(errno)); /* dont use clicon_err here due to recursion */
	    goto done;
	}
	if (cec->cec_logfn(cec->cec_handle, suberr, cb) < 0)
	    goto done;
	/* Here we could take care of specific errno, like application-defined errors */
	if (fn)
	    clicon_log(LOG_ERR, "%s: %d: %s: %s: %s",
		       fn,
		       line,
		       clicon_strerror(category),
		       cbuf_get(cb),
		       msg);
	else
	    clicon_log(LOG_ERR, "%s: %s: %s",
		       clicon_strerror(category),
		       cbuf_get(cb),
		       msg);
	if (cb)
	    cbuf_free(cb);
    }
    else if (suberr){   /* Actually log it */
	/* Here we could take care of specific errno, like application-defined errors */
	if (fn)
	    clicon_log(LOG_ERR, "%s: %d: %s: %s: %s", 
		       fn,
		       line,
		       clicon_strerror(category),
		       msg,
		       suberr==XMLPARSE_ERRNO?"XML parse error":strerror(suberr));
	else
	    clicon_log(LOG_ERR, "%s: %s: %s", 
		       clicon_strerror(category),
		       msg,
		       suberr==XMLPARSE_ERRNO?"XML parse error":strerror(suberr));
    }
    else{
	if (fn)
	    clicon_log(LOG_ERR, "%s: %d: %s: %s", 
		       fn,
		       line,
		       clicon_strerror(category),
		       msg);
	else
	    clicon_log(LOG_ERR, "%s: %s", 
		       clicon_strerror(category),
		       msg);
    }
    retval = 0;
  done:
    if (msg)
	free(msg);
    return retval;
}

/*! Translate from numeric error to string representation
 */
char *
clicon_strerror(int err)
{
    return clicon_strerror1(err, EV);
}

/*! Push an error state, if recursive error handling
 */
void*
clicon_err_save(void)
{
    struct err_state *es;

    if ((es = malloc(sizeof(*es))) == NULL)
	return NULL;
    es->es_errno = clicon_errno;
    es->es_suberrno = clicon_suberrno;
    strncpy(es->es_reason, clicon_err_reason, ERR_STRLEN);
    return (void*)es;
}

/*! Pop an error state, if recursive error handling
 */
int
clicon_err_restore(void* handle)
{
    struct err_state *es;

    if ((es = (struct err_state *)handle) != NULL){
	clicon_errno = es->es_errno;
	clicon_suberrno = es->es_suberrno;
	strncpy(clicon_err_reason, es->es_reason, ERR_STRLEN);
	free(es);
    }
    return 0;
}

/*! Register error categories for application-based error handling
 *
 * @param[in]  category  Applies for this category (first arg to clicon_err())
 * @param[in]  logfn     Call att error for generating application-defined errstring
 */
int
clixon_err_cat_reg(enum clicon_err       category,
		   void                 *handle,
		   clixon_cat_log_cb     logfn)
{
    clixon_err_cats *cec;

    if ((cec = malloc(sizeof *cec)) == NULL){
	clicon_err(OE_UNIX, errno, "malloc");
	return -1;
    }
    memset(cec, 0, sizeof *cec);
    cec->cec_category = category;
    cec->cec_handle = handle;
    cec->cec_logfn = logfn;
    INSQ(cec, _err_cat_list);    
    return 0;
}

int
clixon_err_exit(void)
{
    clixon_err_cats *cec = NULL;

    while ((cec = _err_cat_list) != NULL){
	DELQ(cec, _err_cat_list, clixon_err_cats *);
	free(cec);
    } 
    return 0;
}
