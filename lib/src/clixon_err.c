/*
 *
  ***** BEGIN LICENSE BLOCK *****
 
  Copyright (C) 2009-2016 Olof Hagsand and Benny Holmgren
  Copyright (C) 2017-2019 Olof Hagsand
  Copyright (C) 2020-2022 Olof Hagsand and Rubicon Communications, LLC(Netgate)

  This file is part of CLIXON.

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.

  Alternatively, the contents of this file may be used under the terms of
  the GNU General Public License Version 3 or later (the "GPL"),
  in which case the provisions of the GPL are applicable instead
  of those above. If you wish to allow use of your version of this file only
  under the terms of the GPL, and not to allow others to
  use your version of this file under the terms of Apache License version 2, 
  indicate your decision by deleting the provisions above and replace them with
  the  notice and other provisions required by the GPL. If you do not delete
  the provisions above, a recipient may use your version of this file under
  the terms of any one of the Apache License version 2 or the GPL.

  ***** END LICENSE BLOCK *****

 *
 * Errors may be syslogged using LOG_ERR, and printed to stderr, as controlled
 * by clixon_log_init
 */

#ifdef HAVE_CONFIG_H
#include "clixon_config.h" /* generated by config & autoconf */
#endif

#include <stdio.h>
#include <stdarg.h>
#include <stdint.h>
#include <stdlib.h>
#include <fcntl.h>
#include <errno.h>
#include <unistd.h>
#include <syslog.h>
#include <string.h>
#include <time.h>
#include <sys/param.h>
#include <sys/time.h>
#include <sys/types.h>

/* cligen */
#include <cligen/cligen.h>

/* clixon */
#include "clixon_queue.h"
#include "clixon_hash.h"
#include "clixon_handle.h"
#include "clixon_yang.h"
#include "clixon_xml.h"
#include "clixon_log.h"
#include "clixon_debug.h"
#include "clixon_err.h"
#include "clixon_netconf_lib.h"
#include "clixon_xml_io.h"
#include "clixon_yang_module.h"
#include "clixon_plugin.h"

/*
 * Types
 */
struct errvec{
    char *ev_str;
    int   ev_err;
};

struct err_state{
    int  es_category;
    int  es_subnr;
    char es_reason[ERR_STRLEN];
};

/* Clixon error category callbacks provides a way to specialize
 * error handling to something that clixon is not aware of
 * An example is Openssl BIO I/O abstraction objects, see man BIO_new()
 */
struct clixon_err_cats {
    qelem_t             cec_qelem; /* List header */
    enum clixon_err     cec_category;
    void               *cec_handle;
    clixon_cat_log_cb  *cec_logfn;
};
typedef struct clixon_err_cats clixon_err_cats;

/*
 * Local Variables
 */

/* Cache handle since some error calls does not have handle access */
static clixon_handle _err_clixon_h = NULL;
/* Internal global list of category callbacks */
static clixon_err_cats *_err_cat_list = NULL;

/* See enum clixon_err XXX: hide this and change to err_category */
static int  _err_category         = 0; 

/* Corresponds to errno.h XXX: change to errno */
static int  _err_subnr      = 0;

/* Clixon error reason */
static char _err_reason[ERR_STRLEN] = {0, };

/*
 * Error descriptions. Must stop with NULL element.
 */
static struct errvec EV[] = {
    {"Database error",         OE_DB},
    {"Daemon error",           OE_DAEMON},
    {"Event error",            OE_EVENTS},
    {"Config error",           OE_CFG},
    {"Netconf error",          OE_NETCONF},
    {"Protocol error",         OE_PROTO},
    {"Regexp error",           OE_REGEX},
    {"UNIX error",             OE_UNIX},
    {"Syslog error",           OE_SYSLOG},
    {"Routing daemon error",   OE_ROUTING},
    {"XML error",              OE_XML},
    {"JSON error",             OE_JSON},
    {"RESTCONF error",         OE_RESTCONF},
    {"Plugins",                OE_PLUGIN},
    {"Yang error",             OE_YANG},
    {"FATAL",                  OE_FATAL},
    {"Undefined",              OE_UNDEF},
    /* From here error extensions using clixon_err_cat_reg */
    {"OpenSSL error",          OE_SSL},
    {"SNMP error",             OE_SNMP},
    {"Nghttp2 error",          OE_NGHTTP2},
    {NULL,                     -1}
};

/*! Initialize clixon errors
 *
 * Mainly to cache handle since many clixon_err calls may not have access to a handle
 * @param[in]  h       Clixon handle
 * @see clixon_log_init  inits log
 */
int
clixon_err_init(clixon_handle h)
{
    if (h == NULL){
        errno = EINVAL;
        return -1;
    }
    _err_clixon_h = h;
    return 0;
}

/*! Access function: return clixon category of last error
 * 
 * @retval      category     Clixon error category
 * @see clixon_err_save
 */
int
clixon_err_category(void)
{
    return _err_category;
}

/*! Access function: return clixon errno of last error
 * 
 * @retval      errno     Clixon sub error number
 * @see clixon_err_save
 */
int
clixon_err_subnr(void)
{
    return _err_subnr;
}

/*! Access function: return clixon error reason string of last error (direct pointer)
 * 
 * @retval      reason     Pointer to static string
 * Consider copy or malloc instead of pointer to static string?
 * @see clixon_err_save
 */
char *
clixon_err_reason(void)
{
    return _err_reason;
}

static char *
clixon_strerror1(int           err,
                 struct errvec vec[])
{
    struct errvec *ev = NULL;

    for (ev=vec; ev->ev_err != -1; ev++)
        if (ev->ev_err == err)
            break;
    return ev?(ev->ev_str?ev->ev_str:"unknown"):"Clixon unknown error";
}

/*! Translate from numeric error to string representation
 */
char *
clixon_err_str(void)
{
    return clixon_strerror1(_err_category, EV);
}

/*! Clear error state and continue.
 *
 * Clear error state and get on with it, typically non-fatal error and you wish to continue.
 */
int
clixon_err_reset(void)
{
    _err_category = 0;
    _err_subnr = 0;
    memset(_err_reason, 0, ERR_STRLEN);
    return 0;
}

/*! Find error category struct given name
 *
 * @param[in] category Error category
 * @retval    cec      error category callback structs
 * @retval    NULL     Not found
 */
static struct clixon_err_cats *
find_category(int category)
{
    clixon_err_cats *cec = NULL;
    int              found = 0;

    if ((cec = _err_cat_list) != NULL){
        do {
            if (cec->cec_category == category){
                found++;
                break;
            }
            cec = NEXTQ(clixon_err_cats *, cec);
        } while (cec && cec != _err_cat_list);
    }
    return found?cec:NULL;
}

/*! Report an error, constant args variant, see clixon_err() for most common function
 *
 * @param[in]    h        Clixon handle
 * @param[in]    fn       Inline function name (when called from clixon_err() macro)
 * @param[in]    line     Inline file line number (when called from clixon_err() macro)
 * @param[in]    category Clixon error category, See enum clixon_err
 * @param[in]    suberr   Error number, typically errno
 * @param[in]    msg      Error string
 * @retval       0        OK
 * @retval      -1        Error
 * @see clixon_err_fn for a variable-argument variant
 */
static int
clixon_err_args(clixon_handle h,
                const char   *fn,
                const int     line,
                int           category,
                int           suberr,
                char         *msg)
{
    int                     retval = -1;
    struct clixon_err_cats *cec;
    cbuf                   *cb = NULL;
    
    /* Set the global variables */
    strncpy(_err_reason, msg, ERR_STRLEN-1);
    _err_category = category;
    _err_subnr = suberr;
    /* Check category callbacks as defined in clixon_err_cat_reg */
    if ((cec = find_category(category)) != NULL &&
        cec->cec_logfn){
        if ((cb = cbuf_new()) == NULL){
            fprintf(stderr, "cbuf_new: %s\n", strerror(errno)); /* dont use clixon_err here due to recursion */
            goto done;
        }
        if (cec->cec_logfn(cec->cec_handle, suberr, cb) < 0)
            goto done;
        /* Here we could take care of specific errno, like application-defined errors */
        if (fn)
            clixon_log_fn(h, 0, LOG_ERR, NULL, "%s: %d: %s: %s: %s",
                       fn,
                       line,
                       clixon_strerror1(category, EV),
                       cbuf_get(cb),
                       msg);
        else
            clixon_log_fn(h, 0, LOG_ERR, NULL, "%s: %s: %s",
                       clixon_strerror1(category, EV),
                       cbuf_get(cb),
                       msg);
    }
    else if (suberr){   /* Actually log it */
        /* Here we could take care of specific errno, like application-defined errors */
        if (fn)
            clixon_log_fn(h, 0, LOG_ERR, NULL, "%s: %d: %s: %s: %s",
                          fn,
                          line,
                          clixon_strerror1(category, EV),
                          msg,
                          suberr==XMLPARSE_ERRNO?"XML parse error":strerror(suberr));
        else
            clixon_log_fn(h, 0, LOG_ERR, NULL, "%s: %s: %s",
                       clixon_strerror1(category, EV),
                       msg,
                       suberr==XMLPARSE_ERRNO?"XML parse error":strerror(suberr));
    }
    else{
        if (fn)
            clixon_log_fn(h, 0, LOG_ERR, NULL, "%s: %d: %s: %s",
                       fn,
                       line,
                       clixon_strerror1(category, EV),
                       msg);
        else
            clixon_log_fn(h, 0, LOG_ERR, NULL, "%s: %s",
                       clixon_strerror1(category, EV),
                       msg);
    }
    retval = 0;
 done:
    if (cb)
        cbuf_free(cb);
    return retval;
}

/*! Generate netconf error msg to cbuf using callback to use in string printout or logs
 *
 * If no callback is registered, a default error message is genereated
 * @param[in]     xerr    Netconf error message on the level: <rpc-error>
 * @param[out]    cberr   Translation from netconf err to cbuf.
 * @retval        0       OK, with cberr set
 * @retval       -1       Error
 * @code
 *     cbuf *cb = NULL;
 *     if ((cb = cbuf_new()) ==NULL){
 *        err;
 *     if (netconf_err2cb(h, xerr, cb) < 0)
 *        err;
 *     printf("%s", cbuf_get(cb));
 *     cbuf_free(cb);
 * @endcode
 */
int
netconf_err2cb(clixon_handle h,
               cxobj        *xerr,
               cbuf         *cberr)
{
    int    retval = -1;
    cxobj *x;

    if ((x = xml_find_type(xerr, NULL, "error-type", CX_ELMNT)) != NULL)
        cprintf(cberr, "%s ", xml_body(x));
    if ((x = xml_find_type(xerr, NULL, "error-tag", CX_ELMNT)) != NULL)
        cprintf(cberr, "%s ", xml_body(x));
    if ((x = xml_find_type(xerr, NULL, "error-message", CX_ELMNT)) != NULL)
        cprintf(cberr, "%s ", xml_body(x));
    if ((x = xml_find_type(xerr, NULL, "error-info", CX_ELMNT)) != NULL &&
        xml_child_nr(x) > 0){
        if (clixon_xml2cbuf(cberr, xml_child_i(x, 0), 0, 0, NULL, -1, 0) < 0)
            goto done;
    }
    if ((x = xml_find_type(xerr, NULL, "error-app-tag", CX_ELMNT)) != NULL)
        cprintf(cberr, ": %s ", xml_body(x));
    if ((x = xml_find_type(xerr, NULL, "error-path", CX_ELMNT)) != NULL)
        cprintf(cberr, ": %s ", xml_body(x));
    retval = 0;
 done:
    return retval;
}

/*! Report an error.
 *
 * Do not use this fn directly, use the clixon_err() macro
 * Library routines should call this function when an error occurs.
 * The function does he following:
 * - Logs to syslog with LOG_ERR
 * - Set global error variable name clixon_errno
 * - Set global reason string clixon_err_reason
 * Typically a call to clixon_err() is followed by a return -1 (or NULL) that signals 
 * a fatal error that fails early and loud.
 * However there are some cases where such an error does not cause an exit. This includes
 * CLI operations of callbacks and expand functions. The reason is that user-defined errors
 * should just signal an error and not terminate. To override this one can set a suberr to 
 * ESHUTDOWN.
 *
 * @note: err direction (syslog and/or stderr) controlled by clixon_log_init()
 *
 * @param[in]    fn       Inline function name (when called from clixon_err() macro)
 * @param[in]    line     Inline file line number (when called from clixon_err() macro)
 * @param[in]    category Clixon error category, See enum clixon_err
 * @param[in]    suberr   Error number, typically errno
 * @param[in]    xerr     Optional netconf error xml tree on the form: [rpc-reply/]rpc-error
 * @param[in]    format   Error string, format with argv
 * @retval       0        OK
 * @retval      -1        Error
 * @see clixon_netconf_error For variant with netconf error message
 */
int
clixon_err_fn(clixon_handle h,
              const char   *fn,
              const int     line,
              int           category,
              int           suberr,
              cxobj        *xerr,
              const char   *format, ...)
{
    int     retval = -1;
    va_list ap;
    cbuf   *cb = NULL;

    if (h == NULL)     /* Accept NULL, use saved clixon handle */
        h = _err_clixon_h;
    if (xerr){
        /* Accept xml errors on formats:
         *   <rpc-reply><rpc-error>, 
         *   <rpc-error>
         */
        if (strcmp(xml_name(xerr), "rpc-reply") == 0)
            xerr = xml_find_type(xerr, NULL, "rpc-error", CX_ELMNT);
        if (strcmp(xml_name(xerr), "rpc-error") != 0){
            errno = EINVAL;
            goto done;
        }
    }
    va_start(ap, format);
    /* This checks for customizable errors */
    if (clixon_plugin_errmsg_all(h, fn, line, LOG_TYPE_ERR,
                                 &category, &suberr, xerr, format, ap, &cb) < 0)
        goto done;
    va_end(ap);
    if (cb != NULL){ /* Customized: expand clixon_err_args */
        strncpy(_err_reason, cbuf_get(cb), ERR_STRLEN-1);
        _err_category = category;
        _err_subnr = suberr;
        clixon_log_fn(h, 0, LOG_ERR, NULL, "%s", cbuf_get(cb));
        goto ok;
    }
    if ((cb = cbuf_new()) == NULL){
        fprintf(stderr, "cbuf_new: %s\n", strerror(errno));
        goto done;
    }
    va_start(ap, format);
    vcprintf(cb, format, ap);
    va_end(ap);
    if (xerr) {
        cprintf(cb, ": ");
        /* Translate netconf error to string */
        if (netconf_err2cb(h, xerr, cb) < 0)
            goto done;
    }
    if (clixon_err_args(h, fn, line, category, suberr, cbuf_get(cb)) < 0)
        goto done;
 ok:
    retval = 0;
 done:
    if (cb)
        cbuf_free(cb);
    return retval;
}

/*! Push an error state, if recursive error handling
 *
 * @see clixon_err_vars
 */
void*
clixon_err_save(void)
{
    struct err_state *es;

    if ((es = malloc(sizeof(*es))) == NULL)
        return NULL;
    es->es_category = _err_category;
    es->es_subnr = _err_subnr;
    strncpy(es->es_reason, _err_reason, ERR_STRLEN);
    return (void*)es;
}

/*! Pop an error state, if recursive error handling
 */
int
clixon_err_restore(void* handle)
{
    struct err_state *es;

    if ((es = (struct err_state *)handle) != NULL){
        _err_category = es->es_category;
        _err_subnr = es->es_subnr;
        strcpy(_err_reason, es->es_reason);
        free(es);
    }
    return 0;
}

/*! Register error categories for application-based error handling
 *
 * @param[in]  category  Applies for this category (first arg to clixon_err())
 * @param[in]  logfn     Call att error for generating application-defined errstring
 */
int
clixon_err_cat_reg(enum clixon_err   category,
                   void             *handle,
                   clixon_cat_log_cb logfn)
{
    clixon_err_cats *cec;

    if ((cec = malloc(sizeof *cec)) == NULL){
        clixon_err(OE_UNIX, errno, "malloc");
        return -1;
    }
    memset(cec, 0, sizeof *cec);
    cec->cec_category = category;
    cec->cec_handle = handle;
    cec->cec_logfn = logfn;
    INSQ(cec, _err_cat_list);
    return 0;
}

int
clixon_err_exit(void)
{
    clixon_err_cats *cec = NULL;

    while ((cec = _err_cat_list) != NULL){
        DELQ(cec, _err_cat_list, clixon_err_cats *);
        free(cec);
    }
    return 0;
}
