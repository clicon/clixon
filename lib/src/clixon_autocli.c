/*
 *
  ***** BEGIN LICENSE BLOCK *****
 
  Copyright (C) 2020-2022 Olof Hagsand and Rubicon Communications, LLC(Netgate)

  This file is part of CLIXON.

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.

  Alternatively, the contents of this file may be used under the terms of
  the GNU General Public License Version 3 or later (the "GPL"),
  in which case the provisions of the GPL are applicable instead
  of those above. If you wish to allow use of your version of this file only
  under the terms of the GPL, and not to allow others to
  use your version of this file under the terms of Apache License version 2, 
  indicate your decision by deleting the provisions above and replace them with
  the  notice and other provisions required by the GPL. If you do not delete
  the provisions above, a recipient may use your version of this file under
  the terms of any one of the Apache License version 2 or the GPL.

  ***** END LICENSE BLOCK *****
  *
  * C-code corresponding to clixon-autocli.yang
 */
#ifdef HAVE_CONFIG_H
#include "clixon_config.h" /* generated by config & autoconf */
#endif

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <errno.h>
#include <fcntl.h>
#include <syslog.h>
#include <signal.h>
#include <fnmatch.h>
#include <sys/param.h>

/* cligen */
#include <cligen/cligen.h>

/* clixon */
#include "clixon_queue.h"
#include "clixon_hash.h"
#include "clixon_handle.h"
#include "clixon_string.h"
#include "clixon_yang.h"
#include "clixon_xml.h"
#include "clixon_options.h"
#include "clixon_data.h"
#include "clixon_map.h"
#include "clixon_err.h"
#include "clixon_autocli.h"

/* Mapping from YANG autocli-op to C enum */
static const map_str2int autocli_op_map[] = {
    {"enable",   AUTOCLI_OP_ENABLE},
    {"disable",  AUTOCLI_OP_DISABLE},
    {"compress", AUTOCLI_OP_COMPRESS},
    {NULL,      -1}
};

/* Mapping from YANG list-keyword-type to C enum */
static const map_str2int list_kw_map[] = {
    {"kw-none",  AUTOCLI_LISTKW_NONE},
    {"kw-nokey", AUTOCLI_LISTKW_NOKEY},
    {"kw-all",   AUTOCLI_LISTKW_ALL},
    {NULL,      -1}
};

/* Mapping from YANG autocli cache-type to C enum */
static const map_str2int autocli_cache_map[] = {
    {"disabled",  AUTOCLI_CACHE_DISABLED},
    {"read",      AUTOCLI_CACHE_READ},
    {NULL,       -1}
};

static int
autocli_str2op(char *str)
{
    return clicon_str2int(autocli_op_map, str);
}

static int
autocli_listkw_str2int(char *str)
{
    return clicon_str2int(list_kw_map, str);
}

static int
autocli_cache_str2int(char *str)
{
    return clicon_str2int(autocli_cache_map, str);
}

/*! Check if autocli is enabled
 *
 * @param[in]  h        Clixon handle
 * @param[out] enablep  Return value:
 * @retval     0        OK
 * @retval    -1        Error
 */
int
autocli_enabled(clixon_handle h,
                int          *enablep)
{
    int    retval = -1;
    cxobj *xautocli;
    char  *str;

    if (enablep == NULL){
        clixon_err(OE_YANG, EINVAL, "Argument is NULL");
        goto done;
    }
    if ((xautocli = clicon_conf_autocli(h)) == NULL)
        goto ok;
    if ((str = xml_find_body(xautocli, "enabled")) == NULL){
        clixon_err(OE_XML, EINVAL, "No enabled element");
        goto done;
    }
    *enablep = strcmp(str, "true") == 0;
 ok:
    retval = 0;
 done:
    return retval;
}

/*! Filter module name according to cli_autocli.yang setting
 *
 * Traverse and find module/include/exclude rules
 * @param[in]  h        Clixon handle
 * @param[in]  modname  Name of YANG module, or NULL for ANY module (eg default)
 * @param[out] enablep  Include this module in autocli
 * @retval     0        OK, and enablep set
 * @retval    -1        Error
 * Special rule: module-default=false and no operation=enable rules is disable
 */
int
autocli_module(clixon_handle h,
               const char   *modname,
               int          *enablep)
{
    int    retval = -1;
    cxobj *xrule;
    cxobj *xmod;
    char  *str;
    char  *element;
    int    enable = 0;
    int    op;
    cxobj *xautocli;
    char  *body;

    if (enablep == NULL){
        clixon_err(OE_YANG, EINVAL, "Argument is NULL");
        goto done;
    }
    enable = 0;
    if ((xautocli = clicon_conf_autocli(h)) == NULL)
        goto ok;
    /* Default rule */
    if ((str = xml_find_body(xautocli, "module-default")) == NULL){
        clixon_err(OE_XML, EINVAL, "No module-default rule");
        goto done;
    }
    enable = strcmp(str, "true") == 0;
    if (enable && modname == NULL)
        goto ok;
    xrule = NULL;
    while ((xrule = xml_child_each(xautocli, xrule, CX_ELMNT)) != NULL) {
        if (strcmp(xml_name(xrule), "rule") != 0)
            continue;
        if ((str = xml_find_body(xrule, "operation")) == NULL)
            continue;
        /* Skip other than enable/disable */
        op = autocli_str2op(str);
        if (!enable && op == AUTOCLI_OP_ENABLE) {
            /* Enable rules logic is:
             * - If match, break, done
             */
            xmod = NULL;
            while ((xmod = xml_child_each(xrule, xmod, CX_ELMNT)) != NULL) {
                if ((element = xml_name(xmod)) == NULL)
                    continue;
                if (strcmp(element, "module-name") == 0){
                    if (modname == NULL)
                        break; /* match */
                    if ((body = xml_body(xmod)) == NULL)
                        continue; /* invalid rule? */
                    if (fnmatch(body, modname, 0) == 0)
                        break; /* match */
                }
            }
            if (xmod != NULL){ /* break: found match */
                enable = 1;
                break;
            }
        }
        else if (enable && op == AUTOCLI_OP_DISABLE) {
            xmod = NULL;
            while ((xmod = xml_child_each(xrule, xmod, CX_ELMNT)) != NULL) {
                if ((element = xml_name(xmod)) == NULL)
                    continue;
                if (strcmp(element, "module-name") == 0){
                    if ((body = xml_body(xmod)) == NULL)
                        continue; /* invalid rule? */
                    if (fnmatch(body, modname, 0) == 0)
                        break; /* match */
                }
            }
            if (xmod != NULL){ /* break: found match */
                enable = 0;
                break;
            }
        }
    }
 ok:
    *enablep = enable;
    retval = 0;
 done:
    return retval;
}

/*! Specialization of autocli_compress for extension element
 */
static int
autocli_compress_extension(yang_stmt *ys,
                           yang_stmt *ymod,
                           char      *body,
                           int       *match)
{
    int   retval = -1;
    char *prefix = NULL;
    char *id = NULL;
    char *ns = NULL;
    int   exist = 0;
    int   ret;

    if (nodeid_split(body, &prefix, &id) < 0)
        goto done;
    if (prefix != NULL){
        if ((ret = yang_find_namespace_by_prefix(ys, prefix, &ns)) < 0)
            goto done;
        if (ret == 1){
            /* First try local node, then try module */
            if (yang_extension_value(ys, id, ns, &exist, NULL) < 0)
                goto done;
            if (exist == 0)
                if (yang_extension_value(ymod, id, ns, &exist, NULL) < 0)
                    goto done;
            if (exist == 0)
                *match = 0;
        }
    }
    retval = 0;
 done:
    if (prefix)
        free(prefix);
    if (id)
        free(id);
    return retval;
}

/*! Check if yang symbol shpuld be compressed, ie skipped for its child(ren)
 *
 * For each Traverse "compress" rule, check:
 * 1. Yang keyword match
 * 2. Schema-nodeid match (yang argument)
 * 3. module-name match
 * 4. Single list child?
 * The rules are OR:d, which means:
 * - At least one compress rules that match
 *
 * @param[in]  h        Clixon handle
 * @param[out] compress 
 * @retval     0        OK, and compress set
 * @retval    -1        Error
 * Canonical examples:
The config and state containers are "compressed" out of the schema.
    + op=COMPRESS
    - node-id is config/state
    + yang keyword is CONTAINER
    + module-name=openconfig*

The surrounding container entities are removed from list nodes.
    + op=COMPRESS
    + yang keyword is CONTAINER
    - Only one child + Child keyword is LIST
 */
int
autocli_compress(clixon_handle h,
                 yang_stmt    *ys,
                 int          *compress)
{
    int        retval = -1;
    cxobj     *xautocli = NULL;
    cxobj     *xrule;
    cxobj     *xmod;
    yang_stmt *ymod;
    char      *modname;
    char      *str;
    char      *element;
    char      *nodeid;
    enum rfc_6020 keyw;
    const char *keywstr;
    int        match = 0;
    char      *body;

    if (compress == NULL){
        clixon_err(OE_YANG, EINVAL, "Argument is NULL");
        goto done;
    }
    if ((xautocli = clicon_conf_autocli(h)) == NULL){
        clixon_err(OE_YANG, 0, "No clixon-autocli");
        goto done;
    }
    ymod = ys_module(ys);
    modname = yang_argument_get(ymod);
    keyw = yang_keyword_get(ys);
    keywstr = yang_key2str(keyw);
    nodeid = yang_argument_get(ys);
    xrule = NULL;
    while ((xrule = xml_child_each(xautocli, xrule, CX_ELMNT)) != NULL) {
        if (strcmp(xml_name(xrule), "rule") != 0)
            continue;
        if ((str = xml_find_body(xrule, "operation")) == NULL)
            continue;
        /* Peek in element of rule to skip non-compress operations */
        if (autocli_str2op(str) != AUTOCLI_OP_COMPRESS)
            continue;
        /* At this point this rule is a compress rule
         * compress rule logic is "OR", the logic is:
         * - If match, break, done
         * - If not match, continue to next rule
         */
        match = 1;
        xmod = NULL;
        while ((xmod = xml_child_each(xrule, xmod, CX_ELMNT)) != NULL) {
            if ((element = xml_name(xmod)) == NULL)
                continue;
            if (strcmp(element, "name") == 0 ||
                strcmp(element, "operation") == 0)
                continue;
            if ((body = xml_body(xmod)) == NULL)
                continue;
            if (strcmp(element, "yang-keyword") == 0){
                if (strcmp(body, keywstr) != 0){
                    match = 0;
                    break;
                }
            }
            else if (strcmp(element, "schema-nodeid") == 0){
                if (strcmp(body, nodeid) != 0){
                    match = 0;
                    break;
                }
            }
            else if (strcmp(element, "module-name") == 0){
                if (fnmatch(body, modname, 0) != 0){
                    match = 0;
                    break;
                }
            }
            else if (strcmp(element, "extension") == 0){
                if (autocli_compress_extension(ys, ymod, body, &match) < 0)
                    goto done;
                if (match == 0)
                    break;
            }
            else if (strcmp(element, "yang-keyword-child") == 0){
                enum rfc_6020 subkeyw;
                subkeyw = yang_str2key(body);
                if (yang_single_child_type(ys, subkeyw) == 0){
                    match = 0;
                    break;
                }
            }
        }
        if (match) /* At least one compress rule matches */
            break;
    }
    *compress = match;
    retval = 0;
 done:
    return retval;
}

/*! Return default autocli completion setting
 *
 * Currently only returns list-keyword-default, could be extended to rules
 * @param[in]  h          Clixon handle
 * @param[out] completion Completion enabled
 * @retval     0          OK
 * @retval    -1          Error
 */
int
autocli_completion(clixon_handle h,
                   int          *completion)
{
    int     retval = -1;
    char   *str;
    uint8_t val;
    char   *reason = NULL;
    cxobj  *xautocli;
    int     ret;

    if (completion == NULL){
        clixon_err(OE_YANG, EINVAL, "Argument is NULL");
        goto done;
    }
    if ((xautocli = clicon_conf_autocli(h)) == NULL){
        clixon_err(OE_YANG, 0, "No clixon-autocli");
        goto done;
    }
    if ((str = xml_find_body(xautocli, "completion-default")) == NULL){
        clixon_err(OE_XML, EINVAL, "No completion-default rule");
        goto done;
    }
    if ((ret = parse_bool(str, &val, &reason)) < 0){
        clixon_err(OE_CFG, errno, "parse_bool");
        goto done;
    }
    *completion = val;
    retval = 0;
 done:
    if (reason)
        free(reason);
    return retval;
}

/*! Return autocli grouping treeref option
 *
 * When false replaces uses with grouping, when true use tree reference
 * @param[in]  h          Clixon handle
 * @param[out] treeref    grouping using treerefs enabled
 * @retval     0          OK
 * @retval    -1          Error
 */
int
autocli_grouping_treeref(clixon_handle h,
                         int          *treeref)
{
    int     retval = -1;
    char   *str;
    uint8_t val;
    char   *reason = NULL;
    cxobj  *xautocli;
    int     ret;

    if (treeref == NULL){
        clixon_err(OE_YANG, EINVAL, "Argument is NULL");
        goto done;
    }
    if ((xautocli = clicon_conf_autocli(h)) == NULL){
        clixon_err(OE_YANG, 0, "No clixon-autocli");
        goto done;
    }
    if ((str = xml_find_body(xautocli, "grouping-treeref")) == NULL){
        clixon_err(OE_XML, EINVAL, "No grouping-treeref rule");
        goto done;
    }
    if ((ret = parse_bool(str, &val, &reason)) < 0){
        clixon_err(OE_CFG, errno, "parse_bool");
        goto done;
    }
    *treeref = val;
    retval = 0;
 done:
    if (reason)
        free(reason);
    return retval;
}

/*! Return default autocli list keyword setting
 *
 * Currently only returns list-keyword-default, could be extended to rules
 * @param[in]  h          Clixon handle
 * @param[out] listkw     List keyword setting
 * @retval     0          OK
 * @retval    -1          Error
 */
int
autocli_list_keyword(clixon_handle     h,
                     autocli_listkw_t *listkw)
{
    int    retval = -1;
    char  *str;
    cxobj *xautocli = NULL;

    if (listkw == NULL){
        clixon_err(OE_YANG, EINVAL, "Argument is NULL");
        goto done;
    }
    if ((xautocli = clicon_conf_autocli(h)) == NULL){
        clixon_err(OE_YANG, 0, "No clixon-autocli");
        goto done;
    }
    if ((str = xml_find_body(xautocli, "list-keyword-default")) == NULL){
        clixon_err(OE_XML, EINVAL, "No list-keyword-default rule");
        goto done;
    }
    *listkw = autocli_listkw_str2int(str);
    retval = 0;
 done:
    return retval;
}

/*! Return default autocli treeref state setting, ie generate CLI from YANG non-config
 *
 * @param[in]  h             Clixon handle
 * @param[out] treeref_state If true, generate CLI from state
 * @retval     0             OK
 * @retval    -1             Error
 */
int
autocli_treeref_state(clixon_handle h,
                      int          *treeref_state)
{
    int     retval = -1;
    char   *str;
    uint8_t val;
    char   *reason = NULL;
    cxobj  *xautocli;
    int     ret;

    if (treeref_state == NULL){
        clixon_err(OE_YANG, EINVAL, "Argument is NULL");
        goto done;
    }
    if ((xautocli = clicon_conf_autocli(h)) == NULL){
        clixon_err(OE_YANG, 0, "No clixon-autocli");
        goto done;
    }
    if ((str = xml_find_body(xautocli, "treeref-state-default")) == NULL){
        clixon_err(OE_XML, EINVAL, "No treeref-state-default rule");
        goto done;
    }
    if ((ret = parse_bool(str, &val, &reason)) < 0){
        clixon_err(OE_CFG, errno, "parse_bool");
        goto done;
    }
    *treeref_state = val;
    retval = 0;
 done:
    if (reason)
        free(reason);
    return retval;
}

/*! Return default autocli edit-mode setting
 *
 * @param[in]  h    Clixon handle
 * @param[in]  keyw YANG keyword
 * @param[out] flag If 0 keyw is not a part of default edit-mode, if 1 it is.
 * @retval     0    OK, see result in keyw
 * @retval    -1    Error
 * @note keyw is a sub/superset of RFC 6020,  see clixon-autocli.yang on which are defined
 */
int
autocli_edit_mode(clixon_handle h,
                  const char   *keyw,
                  int          *flag)
{
    int     retval = -1;
    char   *str;
    cxobj  *xautocli;
    char  **vec = NULL;
    int     nvec;
    char   *v;
    int     i;

    if (flag == NULL){
        clixon_err(OE_YANG, EINVAL, "Argument is NULL");
        goto done;
    }
    *flag = 0;
    if ((xautocli = clicon_conf_autocli(h)) == NULL){
        clixon_err(OE_YANG, 0, "No clixon-autocli");
        goto done;
    }
    if ((str = xml_find_body(xautocli, "edit-mode-default")) == NULL){
        clixon_err(OE_XML, EINVAL, "No edit-mode-default rule");
        goto done;
    }
    if ((vec = clixon_strsep3(str, " ", &nvec)) == NULL)
        goto done;
    for (i=0; i<nvec; i++){
        v = vec[i];
        if (strcmp(v, keyw) == 0){
            *flag = 1;
            break;
        }
    }
    retval = 0;
 done:
    if (vec)
        free(vec);
    return retval;
}

/*! Return clispec cache setting
 *
 * @param[in]  h    Clixon handle
 * @param[out] dir  Cache dir
 * @retval     0    OK
 * @retval    -1    Error
 */
int
autocli_cache(clixon_handle    h,
              autocli_cache_t *type,
              char           **dir)
{
    int    retval = -1;
    cxobj *xautocli;
    char  *str;

    if ((xautocli = clicon_conf_autocli(h)) == NULL){
        clixon_err(OE_YANG, 0, "No clixon-autocli");
        goto done;
    }
    if ((str = xml_find_body(xautocli, "clispec-cache")) == NULL){
        clixon_err(OE_XML, EINVAL, "No clispec-cache rule");
        goto done;
    }
    if (type)
        *type = autocli_cache_str2int(str);
    if (dir)
        *dir = clicon_option_str(h, "CLICON_AUTOCLI_CACHE_DIR");
    retval = 0;
 done:
    return retval;
}

/*! Translate to CLI commands in cbuf
 *
 * Howto: join strings and pass them down.
 * Identify unique/index keywords for correct set syntax.
 * @param[in]     h       Clixon handle
 * @param[in,out] cb      Cligen buffer to write to
 * @param[in]     xn      XML Parse-tree (to translate)
 * @param[in]     prepend Print this text in front of all commands.
 * @retval        0       OK
 * @retval       -1       Error
 * @see clixon_cli2file
 */
static int
cli2cbuf(clixon_handle h,
         cbuf         *cb,
         cxobj        *xn,
         const char   *prepend)
{
    int              retval = -1;
    cxobj           *xe = NULL;
    cbuf            *cbpre = NULL;
    yang_stmt       *ys;
    int              match;
    char            *body;
    int              compress = 0;
    autocli_listkw_t listkw;
    int              exist = 0;
    char            *name;

    if (autocli_list_keyword(h, &listkw) < 0)
        goto done;
    if (xml_type(xn)==CX_ATTR)
        goto ok;
    if ((ys = xml_spec(xn)) == NULL)
        goto ok;
    if (yang_extension_value(ys, "hide-show", CLIXON_AUTOCLI_NS, &exist, NULL) < 0)
        goto done;
    if (exist)
        goto ok;
    exist = 0;
    if (yang_extension_value(ys, "alias", CLIXON_AUTOCLI_NS, &exist, &name) < 0)
        goto done;
    if (!exist)
        name = xml_name(xn);
    /* If leaf/leaf-list or presence container, then print line */
    if (yang_keyword_get(ys) == Y_LEAF ||
        yang_keyword_get(ys) == Y_LEAF_LIST){
        if (prepend)
            cprintf(cb, "%s", prepend);
        if (listkw != AUTOCLI_LISTKW_NONE)
            cprintf(cb, "%s ", name);
        if ((body = xml_body(xn)) != NULL){
            if (index(body, ' '))
                cprintf(cb, "\"%s\"", body);
            else
                cprintf(cb, "%s", body);
        }
        cprintf(cb, "\n");
        goto ok;
    }
    /* Create prepend variable string */
    if ((cbpre = cbuf_new()) == NULL){
        clixon_err(OE_PLUGIN, errno, "cbuf_new");
        goto done;
    }
    if (prepend)
        cprintf(cbpre, "%s", prepend);

    /* If non-presence container && HIDE mode && only child is
     * a list, then skip container keyword
     * See also yang2cli_container */
    if (autocli_compress(h, ys, &compress) < 0)
        goto done;
    if (!compress)
        cprintf(cbpre, "%s ", xml_name(xn));

    /* If list then first loop through keys */
    if (yang_keyword_get(ys) == Y_LIST){
        xe = NULL;
        while ((xe = xml_child_each(xn, xe, -1)) != NULL){
            if ((match = yang_key_match(ys, xml_name(xe), NULL)) < 0)
                goto done;
            if (!match)
                continue;
            if (listkw == AUTOCLI_LISTKW_ALL)
                cprintf(cbpre, "%s ", xml_name(xe));
            cprintf(cbpre, "%s ", xml_body(xe));
        }
    }
    else if ((yang_keyword_get(ys) == Y_CONTAINER) &&
             yang_find(ys, Y_PRESENCE, NULL) != NULL){
        /* If presence container, then print as leaf (but continue to children) */
        if (prepend)
            cprintf(cb, "%s", prepend);
        if (listkw != AUTOCLI_LISTKW_NONE)
            cprintf(cb, "%s ", xml_name(xn));
        if ((body = xml_body(xn)) != NULL){
            if (index(body, ' '))
                cprintf(cb, "\"%s\"", body);
            else
                cprintf(cb, "%s", body);
        }
        cprintf(cb, "\n");
    }

    /* For lists, print cbpre before its elements */
    if (yang_keyword_get(ys) == Y_LIST)
        cprintf(cb, "%s\n", cbuf_get(cbpre));
    /* Then loop through all other (non-keys) */
    xe = NULL;
    while ((xe = xml_child_each(xn, xe, -1)) != NULL){
        if (yang_keyword_get(ys) == Y_LIST){
            if ((match = yang_key_match(ys, xml_name(xe), NULL)) < 0)
                goto done;
            if (match)
                continue; /* Not key itself */
        }
        if (cli2cbuf(h, cb, xe, cbuf_get(cbpre)) < 0)
            goto done;
    }
 ok:
    retval = 0;
 done:
    if (cbpre)
        cbuf_free(cbpre);
    return retval;
}

/*! Translate from XML to CLI commands, internal
 *
 * Howto: join strings and pass them down.
 * Identify unique/index keywords for correct set syntax.
 * @param[in] h        Clixon handle
 * @param[in] f        Output FILE (eg stdout)
 * @param[in] xn       XML Parse-tree (to translate)
 * @param[in] prepend  Print this text in front of all commands.
 * @param[in] fn       Callback to make print function
 * @retval    0        OK
 * @retval   -1        Error
 */
static int
cli2file(clixon_handle     h,
         FILE             *f,
         cxobj            *xn,
         const char       *prepend,
         clicon_output_cb *fn)
{
    int              retval = -1;
    cxobj           *xe = NULL;
    cbuf            *cbpre = NULL;
    yang_stmt       *ys;
    int              match;
    char            *body;
    int              compress = 0;
    autocli_listkw_t listkw;
    int              exist = 0;
    char            *name;

    if (autocli_list_keyword(h, &listkw) < 0)
        goto done;
    if (xml_type(xn)==CX_ATTR)
        goto ok;
    if ((ys = xml_spec(xn)) == NULL)
        goto ok;
    if (yang_extension_value(ys, "hide-show", CLIXON_AUTOCLI_NS, &exist, NULL) < 0)
        goto done;
    if (exist)
        goto ok;
    exist = 0;
    if (yang_extension_value(ys, "alias", CLIXON_AUTOCLI_NS, &exist, &name) < 0)
        goto done;
    if (!exist)
        name = xml_name(xn);
    /* If leaf/leaf-list or presence container, then print line */
    if (yang_keyword_get(ys) == Y_LEAF ||
        yang_keyword_get(ys) == Y_LEAF_LIST){
        if (prepend)
            (*fn)(f, "%s", prepend);
        if (listkw != AUTOCLI_LISTKW_NONE)
            (*fn)(f, "%s ", name);
        if ((body = xml_body(xn)) != NULL){
            if (index(body, ' '))
                (*fn)(f, "\"%s\"", body);
            else
                (*fn)(f, "%s", body);
        }
        (*fn)(f, "\n");
        goto ok;
    }
    /* Create prepend variable string */
    if ((cbpre = cbuf_new()) == NULL){
        clixon_err(OE_PLUGIN, errno, "cbuf_new");
        goto done;
    }
    if (prepend)
        cprintf(cbpre, "%s", prepend);

    /* If non-presence container && HIDE mode && only child is
     * a list, then skip container keyword
     * See also yang2cli_container */
    if (autocli_compress(h, ys, &compress) < 0)
        goto done;
    if (!compress)
        cprintf(cbpre, "%s ", xml_name(xn));

    /* If list then first loop through keys */
    if (yang_keyword_get(ys) == Y_LIST){
        xe = NULL;
        while ((xe = xml_child_each(xn, xe, -1)) != NULL){
            if ((match = yang_key_match(ys, xml_name(xe), NULL)) < 0)
                goto done;
            if (!match)
                continue;
            if (listkw == AUTOCLI_LISTKW_ALL)
                cprintf(cbpre, "%s ", xml_name(xe));
            cprintf(cbpre, "%s ", xml_body(xe));
        }
    }
    else if ((yang_keyword_get(ys) == Y_CONTAINER) &&
             yang_find(ys, Y_PRESENCE, NULL) != NULL){
        /* If presence container, then print as leaf (but continue to children) */
        if (prepend)
            (*fn)(f, "%s", prepend);
        if (listkw != AUTOCLI_LISTKW_NONE)
            (*fn)(f, "%s ", xml_name(xn));
        if ((body = xml_body(xn)) != NULL){
            if (index(body, ' '))
                (*fn)(f, "\"%s\"", body);
            else
                (*fn)(f, "%s", body);
        }
        (*fn)(f, "\n");
    }

    /* For lists, print cbpre before its elements */
    if (yang_keyword_get(ys) == Y_LIST)
        (*fn)(f, "%s\n", cbuf_get(cbpre));
    /* Then loop through all other (non-keys) */
    xe = NULL;
    while ((xe = xml_child_each(xn, xe, -1)) != NULL){
        if (yang_keyword_get(ys) == Y_LIST){
            if ((match = yang_key_match(ys, xml_name(xe), NULL)) < 0)
                goto done;
            if (match)
                continue; /* Not key itself */
        }
        if (cli2file(h, f, xe, cbuf_get(cbpre), fn) < 0)
            goto done;
    }
 ok:
    retval = 0;
 done:
    if (cbpre)
        cbuf_free(cbpre);
    return retval;
}

/*! Translate from XML to autocli commands
 *
 * Howto: join strings and pass them down.
 * Identify unique/index keywords for correct set syntax.
 * @param[in] h        Clixon handle
 * @param[in] f        Output FILE (eg stdout)
 * @param[in] xn       XML Parse-tree (to translate)
 * @param[in] prepend  Print this text in front of all commands.
 * @param[in] fn       File print function (if NULL, use fprintf)
 * @param[in] skiptop  0: Include top object 1: Skip top-object, only children,
 * @retval    0        OK
 * @retval   -1        Error
 * @see clixon_cli2cbuf
 */
int
clixon_cli2file(clixon_handle     h,
                FILE             *f,
                cxobj            *xn,
                const char       *prepend,
                clicon_output_cb *fn,
                int               skiptop)
{
    int   retval = 1;
    cxobj *xc;

    if (fn == NULL)
        fn = fprintf;
    if (skiptop){
        xc = NULL;
        while ((xc = xml_child_each(xn, xc, CX_ELMNT)) != NULL)
            if (cli2file(h, f, xc, prepend, fn) < 0)
                goto done;
    }
    else {
        if (cli2file(h, f, xn, prepend, fn) < 0)
            goto done;
    }
    retval = 0;
 done:
    return retval;
}

/*! Translate from XML to autocli commands
 *
 * Howto: join strings and pass them down.
 * Identify unique/index keywords for correct set syntax.
 * @param[in] h        Clixon handle
 * @param[in] f        Output FILE (eg stdout)
 * @param[in] xn       XML Parse-tree (to translate)
 * @param[in] prepend  Print this text in front of all commands.
 * @param[in] fn       File print function (if NULL, use fprintf)
 * @param[in] skiptop  0: Include top object 1: Skip top-object, only children,
 * @retval    0        OK
 * @retval   -1        Error
 * @see clixon_cli2file
 */
int
clixon_cli2cbuf(clixon_handle h,
                cbuf         *cb,
                cxobj        *xn,
                const char   *prepend,
                int           skiptop)
{
    int   retval = 1;
    cxobj *xc;

    if (skiptop){
        xc = NULL;
        while ((xc = xml_child_each(xn, xc, CX_ELMNT)) != NULL)
            if (cli2cbuf(h, cb, xc, prepend) < 0)
                goto done;
    }
    else {
        if (cli2cbuf(h, cb, xn, prepend) < 0)
            goto done;
    }
    retval = 0;
 done:
    return retval;
}
